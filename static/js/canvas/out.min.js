(function () {
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    var currentElement = !1,
        PIXEL_RATIO = (function () {
            //https://stackoverflow.com/questions/15661339/how-do-i-fix-blurry-text-in-my-html5-canvas/15666143#15666143
            var a = document.createElement("canvas").getContext("2d"),
                b = window.devicePixelRatio || 1,
                c =
                    a.webkitBackingStorePixelRatio ||
                    a.mozBackingStorePixelRatio ||
                    a.msBackingStorePixelRatio ||
                    a.oBackingStorePixelRatio ||
                    a.backingStorePixelRatio ||
                    1;
            return b / c;
        })();
    function scale_canvas(a, b, c, d) {
        //https://stackoverflow.com/questions/15661339/how-do-i-fix-blurry-text-in-my-html5-canvas/15666143#15666143
        ((a.width = c * PIXEL_RATIO),
            (a.height = d * PIXEL_RATIO),
            (a.style.width = c + "px"),
            (a.style.height = d + "px"),
            b.setTransform(PIXEL_RATIO, 0, 0, PIXEL_RATIO, 0, 0),
            b.save());
    }
    var canvas_offset_x = 0,
        canvas_offset_y = 0;
    function setup_canvasses(a, b) {
        ((canvas_width = a),
            (canvas_height = b),
            scale_canvas(canvas.node(), context, a, b),
            scale_canvas(canvas_single.node(), context_single, a, b),
            scale_canvas(gui_canvas.node(), gui_context, a, b),
            scale_canvas(hover_canvas.node(), hover_context, a, b),
            scale_canvas(cursor_canvas.node(), cursor_context, a, b),
            scale_canvas(grid_canvas.node(), grid_context, a, b),
            (cursor_context.fillStyle = "yellowgreen"),
            (cursor_context.strokeStyle = "yellowgreen"),
            (canvas_offset_x = canvas.node().getBoundingClientRect().left),
            (canvas_offset_y = canvas.node().getBoundingClientRect().top));
    }
    var canvas_width,
        canvas_height,
        VERSION = "20180709",
        radius = 5,
        transform = d3.zoomIdentity,
        canvas = d3.select("#draw_canvas"),
        context = canvas.node().getContext("2d"),
        canvas_single = d3.select("#draw_canvas_single"),
        context_single = canvas_single.node().getContext("2d"),
        gui_canvas = d3.select("#gui_canvas"),
        gui_context = gui_canvas.node().getContext("2d"),
        hover_canvas = d3.select("#hover_canvas"),
        hover_context = hover_canvas.node().getContext("2d"),
        cursor_canvas = d3.select("#cursor_canvas"),
        cursor_context = cursor_canvas.node().getContext("2d"),
        grid_canvas = d3.select("#grid_canvas"),
        grid_context = grid_canvas.node().getContext("2d"),
        full_screen = !1,
        CANVAS_MARGIN = 4,
        _calc_canvas_width = calc_canvas_width(),
        _calc_canvas_width2 = _slicedToArray(_calc_canvas_width, 2),
        canvas_init_width = _calc_canvas_width2[0],
        canvas_init_height = _calc_canvas_width2[1],
        no_wobble = !1; // var minimap_init_width = 240;
    // var minimap_init_height = 140;
    setup_canvasses(canvas_init_width, canvas_init_height); // var minimap_canvas = d3.select("#minimap");
    // var minimap_context = minimap_canvas.node().getContext("2d");
    // scale_canvas(minimap_canvas.node(), minimap_context, minimap_init_width, minimap_init_height);
    // var minimap_overlay_canvas = d3.select("#minimap_overlay");
    // var minimap_overlay_context = minimap_overlay_canvas.node().getContext("2d");
    // scale_canvas(minimap_overlay_canvas.node(), minimap_overlay_context, minimap_init_width, minimap_init_height);
    var shapes_storage,
        MIN_PAR_WIDTH = 8,
        max_border_width = 500,
        ignore_svg_click = !1,
        last_pos = [0, 0],
        last_w = 0,
        last_h = 0,
        grid_step = 4,
        mdd = 4,
        fine_move = !1,
        fine_size = !1,
        anim_dur = 1e3,
        to_canvas = (function () {
            return (
                (from_shape = !1),
                {
                    get_canvas: function () {
                        return (
                            currentElement &&
                                "canvas" != currentElement.iama &&
                                (from_shape = currentElement),
                            { iama: "canvas" }
                        );
                    },
                    set_canvas: function () {
                        set_current_element(this.get_canvas());
                    }, // get_reverse: function(){
                    //     return from_shape;
                    // },
                    set_reverse: function () {
                        from_shape &&
                            ("text" == from_shape.iama &&
                                (from_shape = find_border_by_id(
                                    from_shape.border_id,
                                )),
                            set_current_element(from_shape),
                            (from_shape = !1));
                    },
                }
            );
        })(),
        el_to_copy = !1,
        canvas_status = {
            copy_on: !1,
            view_mode: !1,
            drag_select: !1,
            draw_mode: !1,
            slide_mode: !1,
            slide_exclusion_mode: !1,
            export_mode: !1,
            plumbs_on: !0,
            align_on: !1,
            search_form: !1,
            reset: function () {
                (this.drag_select && drag_select_off(),
                    this.export_mode && drag_export_off(),
                    this.draw_mode && drag_draw_off(),
                    (this.drag_select = !1),
                    (this.draw_mode = !1),
                    (this.slide_mode = !1),
                    (this.slide_exclusion_mode = !1),
                    (this.export_mode = !1),
                    (this.plumbs_on = !0),
                    (this.align_on = !1));
            },
        },
        menu_status = { modal_on: !1 },
        poly_draw = !1,
        points_for_poly = [],
        minimal_menu = !0,
        current_map_name = "",
        pres_mode_for_load = !1,
        slides_mode = !1,
        study_mode = !1,
        reverse = 1e3,
        form_update = !0,
        minscale = 0.15,
        maxscale = 8,
        slider = !1,
        line_generator = d3
            .line()
            .curve(d3.curveCardinal)
            .x(function (a) {
                return a.x;
            })
            .y(function (a) {
                return a.y;
            }),
        line_generator_linear = d3
            .line()
            .curve(d3.curveLinear)
            .x(function (a) {
                return a.x;
            })
            .y(function (a) {
                return a.y;
            }),
        path_end_fig = "arrow",
        help_on = !1,
        form_hidden = !1,
        MARGIN_DIV = 0; //TODO8 naar canvas_status verhuizen
    //hoeveel % van een kant niet wordt gebruikt bij disperse paths over side: 0 is gehele kant
    function calc_canvas_width() {
        var a = window.innerWidth - 2 * CANVAS_MARGIN - 200,
            b = window.innerHeight - 2 * CANVAS_MARGIN; //200 is menu width
        return [a, b];
    }
    var render,
        el_on_single = !1,
        paths_on_single = [];
    function set_current_element(a) {
        var b =
            !!(1 < arguments.length && void 0 !== arguments[1]) && arguments[1];
        if ("canvas" == a.iama && "canvas" == currentElement.iama) return !1;
        (text_for_render.pause_sorting(), text_for_render.invalidate_sorted());
        var c = a != currentElement;
        if (
            ((currentElement = a),
            "text" == a.iama && (a = find_border_by_id(a.border_id)),
            (el_on_single = !1),
            (paths_on_single = []),
            (el_on_single =
                !(
                    merged.is_parent(a) ||
                    "table" in a ||
                    manage_groups.element_in_active_group(a)
                ) &&
                ("border" == a.iama ||
                    "drawing" == a.iama ||
                    "math_shape" == a.iama) &&
                a),
            el_on_single &&
                (paths_on_single = _.flatten(
                    path.find_connections(el_on_single.id).map(function (a) {
                        return shapes_storage.paths.filter(function (b) {
                            return b.id == a.id;
                        });
                    }),
                )),
            0 < paths_on_single.length)
        ) {
            var e = new Set(
                Object.values(shapes_storage.borders_bound).map(function (a) {
                    return a.path_id;
                }),
            );
            0 <
                paths_on_single
                    .map(function (a) {
                        return a.id;
                    })
                    .filter(function (a) {
                        return e.has(a);
                    }).length && ((el_on_single = !1), (paths_on_single = []));
        }
        if (
            (gui_buttons.reset_path_control_points(),
            (c || !el_on_single || b) && render_all(),
            el_on_single ? render_single() : cc.clear_canvas(context_single),
            canvas_status.mobile_mode)
        ) {
            var f, d;
            if ("canvas" == currentElement.iama)
                ((f = last_pos[0]), (d = last_pos[1]));
            else if ("text" == currentElement.iama) {
                var g = [currentElement.x, currentElement.y];
                ((f = g[0]), (d = g[1]));
            } else {
                var h = [
                    currentElement.x,
                    currentElement.y + currentElement.width,
                ];
                ((f = h[0]), (d = h[1]));
            }
            display_cursor_mobile_mode(20, f, d);
        }
    }
    var demo_mode = !1; //TODO8 path control point verdwijnen als endpoint wordt gedragd (doordat op hover wordt geklikt??)
    //TODO2 Import placement weer toevoegen
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                j,
                k,
                l,
                m = [],
                a = !0,
                p = !1;
            try {
                if (((k = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = k.call(d)).done) &&
                        (m.push(g.value), m.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((p = !0), (j = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((l = d["return"]()), Object(l) !== l)
                    )
                        return;
                } finally {
                    if (p) throw j;
                }
            }
            return m;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function conv_arrow_rotation_to_geo_rotation(a) {
        var b = 180 - a;
        return 0 > b ? b + 360 : b;
    }
    function conv_angle(a, b, c) {
        var d =
                !!(3 < arguments.length && arguments[3] !== void 0) &&
                arguments[3],
            e = -a / (180 / Math.PI),
            f = b * Math.cos(e) - c * Math.sin(e),
            g = b * Math.sin(e) + c * Math.cos(e);
        return d
            ? [f - b, g - c]
            : [Math.round(1e5 * f) / 1e5, Math.round(1e5 * g) / 1e5];
    }
    function rotate_point(b, a, c) {
        return [
            Math.cos(b) * a + Math.sin(b) * c,
            -Math.sin(b) * a + Math.cos(b) * c,
        ];
    }
    function round_to(a, b) {
        return Math.round(a * Math.pow(10, b)) / Math.pow(10, b);
    }
    function to_bbox(a) {
        var b =
            1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : 0;
        return {
            top: a.y - b,
            left: a.x - b,
            bottom: a.y + a.height + 2 * b,
            right: a.x + a.width + 2 * b,
        };
    }
    function bbox_to_xywh(a) {
        var b = a.top,
            c = a.left,
            d = a.bottom,
            e = a.right;
        return { x: c, y: b, width: e - c, height: d - b };
    }
    function xywh_to_bbox(a) {
        var b = a.x,
            c = a.y,
            d = a.width,
            e = a.height;
        return { top: c, left: b, bottom: c + e, right: b + d };
    }
    function is_inside(a, b, c) {
        return a > c.left && a < c.right && b > c.top && b < c.bottom;
    }
    function bbox_is_inside_bbox(a, b) {
        return is_inside(a.left, a.top, b) && is_inside(a.right, a.bottom, b);
    }
    function get_bbox_of_figure(a, b) {
        var c = [a.width, a.height],
            d = c[0],
            e = c[1],
            f = [a.x, a.y],
            g = f[0],
            i = f[1];
        return b ? [g, i, d, e] : parse_to_bbox(g, i, d, e);
    }
    function parse_to_bbox(a, b, c, d) {
        function e(c, d) {
            return [a + c, b + d];
        }
        var f = { x0y0: [a, b], x1y0: e(c, 0), x0y1: e(0, d), x1y1: e(c, d) };
        return f;
    }
    function get_path_points_min_max(a) {
        var b = Math.min.apply(
                null,
                a.map(function (a) {
                    return a.x;
                }),
            ),
            c = Math.max.apply(
                null,
                a.map(function (a) {
                    return a.x;
                }),
            ),
            d = Math.min.apply(
                null,
                a.map(function (a) {
                    return a.y;
                }),
            ),
            e = Math.max.apply(
                null,
                a.map(function (a) {
                    return a.y;
                }),
            );
        return [b, c, d, e];
    }
    function pyth_dist(a, b) {
        return Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2);
    }
    function get_bbox_of_group(a) {
        var b = (minY = 1 / 0),
            c = (maxY = -Infinity),
            e = ["path_group", "text_block", "text_path"];
        return (
            a.forEach(function (a) {
                if (
                    "iama" in a &&
                    !e.find(function (b) {
                        return b == a.iama;
                    })
                ) {
                    var d = abs_pos_to_bbox(a);
                    ((b = Math.min(b, d.left)),
                        (minY = Math.min(minY, d.top)),
                        (c = Math.max(c, d.right)),
                        (maxY = Math.max(maxY, d.bottom)));
                }
            }),
            [b, c, minY, maxY]
        );
    }
    function abs_pos_to_bbox(a) {
        var b = [a.x, a.y],
            c = b[0],
            d = b[1],
            e = [a.width, a.height],
            f = e[0],
            g = e[1];
        return {
            top: d,
            bottom: d + g,
            left: c,
            right: c + f,
            width: f,
            height: g,
        };
    }
    function to_discrete_position(a) {
        var b =
                1 < arguments.length && arguments[1] !== void 0
                    ? arguments[1]
                    : parseInt,
            c = _slicedToArray(a, 2),
            d = c[0],
            e = c[1],
            f = b(d / mdd) * mdd,
            g = b(e / mdd) * mdd;
        return [f, g];
    }
    function get_custom_bbox(a) {
        //alleen voor shapes, niet voor elementen in een shape.
        //let wel, kan FO gebruiken ipv g!!!!
        //element = find_g(element);
        var b = get_bbox_of_figure(a, !0, !0),
            c = _slicedToArray(b, 4);
        return (
            (x = c[0]),
            (y = c[1]),
            (w = c[2]),
            (h = c[3]),
            {
                top: y,
                bottom: y + h,
                left: x,
                right: x + w,
                width: w,
                height: h,
            }
        );
    }
    function points_in_area(a, b) {
        var c =
                2 < arguments.length && void 0 !== arguments[2]
                    ? arguments[2]
                    : _.all,
            d = [b.x0y0, b.x1y0, b.x1y1, b.x0y1],
            e = [];
        return (
            a.forEach(function (a) {
                e.push(point_is_inside(a, d));
            }),
            c(e)
        );
    }
    function get_minxy_maxxy_of_array(a) {
        var b = a.map(function (a) {
                return a[0];
            }),
            c = a.map(function (a) {
                return a[1];
            }),
            d = Math.min.apply(null, b),
            e = Math.max.apply(null, b),
            f = Math.min.apply(null, c),
            g = Math.max.apply(null, c);
        return [d, f, e, g];
    }
    var posit2 = {
        get_top_left: function (a) {
            return [a.x, a.y];
        },
        get_bottom_right: function (a) {
            return [a.x + a.width, a.y + a.height];
        },
        get_w_h: function (a) {
            return [a.width, a.height];
        },
        get_trans: function (a) {
            var b =
                    !!(1 < arguments.length && arguments[1] !== void 0) &&
                    arguments[1],
                c =
                    !(2 < arguments.length && arguments[2] !== void 0) ||
                    arguments[2],
                d =
                    !!(3 < arguments.length && arguments[3] !== void 0) &&
                    arguments[3];
            return { translate: [a.x, a.y], rotate: [0], scale: 1 };
        },
        tlbr: function (a) {
            var b = this.get_top_left(a, !0),
                c = this.get_w_h(a),
                d = _slicedToArray(c, 2),
                e = d[0],
                f = d[1];
            return { top: b[1], left: b[0], bottom: b[1] + f, right: b[0] + e };
        },
        get_mid_of_side: function (a, b) {
            try {
                var c = this.get_top_left(a, !0),
                    d = _slicedToArray(c, 2),
                    e = d[0],
                    f = d[1],
                    g = this.get_w_h(a),
                    i = _slicedToArray(g, 2),
                    j = i[0],
                    k = i[1];
                if (0 == b) return [e + j / 2, f];
                if (1 == b) return [e + j, f + k / 2];
                if (2 == b) return [e + j / 2, f + k];
                if (3 == b) return [e, f + k / 2];
            } catch (a) {
                return [1e4, 1e4];
            }
        },
    };
    ("use strict");
    function _createForOfIteratorHelper(b, c) {
        var d =
            ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
            b["@@iterator"];
        if (!d) {
            if (
                Array.isArray(b) ||
                (d = _unsupportedIterableToArray(b)) ||
                (c && b && "number" == typeof b.length)
            ) {
                d && (b = d);
                var e = 0,
                    f = function () {};
                return {
                    s: f,
                    n: function () {
                        return e >= b.length
                            ? { done: !0 }
                            : { done: !1, value: b[e++] };
                    },
                    e: function (a) {
                        throw a;
                    },
                    f: f,
                };
            }
            throw new TypeError(
                "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
            );
        }
        var g,
            h = !0,
            i = !1;
        return {
            s: function () {
                d = d.call(b);
            },
            n: function () {
                var a = d.next();
                return ((h = a.done), a);
            },
            e: function (a) {
                ((i = !0), (g = a));
            },
            f: function () {
                try {
                    h || null == d["return"] || d["return"]();
                } finally {
                    if (i) throw g;
                }
            },
        };
    }
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function _toConsumableArray(a) {
        return (
            _arrayWithoutHoles(a) ||
            _iterableToArray(a) ||
            _unsupportedIterableToArray(a) ||
            _nonIterableSpread()
        );
    }
    function _nonIterableSpread() {
        throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _iterableToArray(a) {
        if (
            ("undefined" != typeof Symbol && null != a[Symbol.iterator]) ||
            null != a["@@iterator"]
        )
            return Array.from(a);
    }
    function _arrayWithoutHoles(a) {
        if (Array.isArray(a)) return _arrayLikeToArray(a);
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    shapes_storage = make_shape_storage();
    function make_shape_storage() {
        //TODO2 load_saved_temp eruit halen als alle canvas maps zijn omgezet naar nieuwe dataformaat
        function a(a) {
            ((v = {}),
                a.texts.forEach(function (a) {
                    a.border_id in v
                        ? v[a.border_id].push(a)
                        : (v[a.border_id] = [a]);
                }),
                (w = {}),
                a.borders_bound.forEach(function (a) {
                    return (w[a.id] = a);
                }),
                (z = {}),
                a.borders.forEach(function (a) {
                    return (z[a.id] = a);
                }),
                (A = a.paths),
                (D = a.icons),
                (E = a.knots),
                (B = a.drawings),
                a.math_shapes && (F = a.math_shapes),
                b(a.images));
        }
        function b(a) {
            Object.keys(a).forEach(function (b) {
                var c = new Image(); //delete data[k].source;
                //beter om te deleted ivm ruimte, maar geeft fout als dan twee keer
                //zelfde bestand achterelkaar wordt ingeladen, zondat de map opnieuw in te lezen
                ((c.src = a[b].source), (c.border_data = a[b]), (C[b] = c));
            });
        }
        function c() {
            (Object.values(w).forEach(function (a) {
                return delete a.redraw_data;
            }),
                Object.values(z).forEach(function (a) {
                    return delete a.redraw_data;
                }),
                A.forEach(function (a) {
                    return delete a.redraw_data;
                }),
                B.forEach(function (a) {
                    return delete a.redraw_data;
                }),
                Object.values(v).forEach(function (a) {
                    a.forEach(function (a) {
                        return delete a.parts;
                    });
                }));
            var a = JSON.parse(JSON.stringify(v));
            (Object.values(z).forEach(function (a) {
                return position_texts(a.id);
            }),
                Object.values(w).forEach(function (a) {
                    return position_texts(a.id);
                }));
            var b = {};
            return (
                Object.keys(C).forEach(function (a) {
                    var c = Object.assign({}, C[a].border_data);
                    ((c.source = C[a].getAttribute("src")), (b[a] = c));
                }),
                {
                    borders_bound: w,
                    borders: z,
                    paths: A,
                    drawings: B,
                    images: b,
                    icons: D,
                    texts: a,
                    knots: E,
                    math_shapes: F,
                }
            );
        }
        function d(a) {
            var b =
                    !(1 < arguments.length && void 0 !== arguments[1]) ||
                    arguments[1],
                c =
                    !(2 < arguments.length && void 0 !== arguments[2]) ||
                    arguments[2],
                d =
                    !(3 < arguments.length && void 0 !== arguments[3]) ||
                    arguments[3],
                e =
                    !(4 < arguments.length && void 0 !== arguments[4]) ||
                    arguments[4],
                f =
                    !(5 < arguments.length && void 0 !== arguments[5]) ||
                    arguments[5],
                g =
                    !(6 < arguments.length && void 0 !== arguments[6]) ||
                    arguments[6],
                h = []; //bbox =left right top bottom
            return (
                b && (h = h.concat(Object.values(z))),
                c && (h = h.concat(A)),
                d && (h = h.concat(B)),
                e && (h = h.concat(D)),
                f && (h = h.concat(E)),
                g && (h = h.concat(Object.values(F))),
                h.filter(function (b) {
                    return (
                        is_inside.apply(
                            void 0,
                            _toConsumableArray(posit2.get_top_left(b)).concat([
                                a,
                            ]),
                        ) &&
                        is_inside.apply(
                            void 0,
                            _toConsumableArray(
                                posit2.get_bottom_right(b),
                            ).concat([a]),
                        )
                    );
                })
            );
        }
        function e(a, b, c) {
            var d = document.createElementNS(
                "http://www.w3.org/2000/svg",
                "path",
            );
            d.setAttribute("d", c.d);
            var e = get_points_along_path(d, 10, 0); //get_points_along_path_generator
            "drawing" == c.iama &&
                (e = e.map(function (a) {
                    var b = _slicedToArray(a, 2),
                        d = b[0],
                        e = b[1];
                    return [d + c.x, e + c.y];
                }));
            var f = e.map(function (c) {
                return pyth_dist(c, [a, b]);
            });
            return Math.min.apply(
                void 0,
                f.sort(function (c, a) {
                    return a - c;
                }),
            );
        }
        function f(a, b) {
            var c =
                    !(2 < arguments.length && arguments[2] !== void 0) ||
                    arguments[2],
                d =
                    !(3 < arguments.length && arguments[3] !== void 0) ||
                    arguments[3],
                f = [];
            c && d ? (f = A.concat(B)) : d ? (f = B) : c && (f = A);
            var g = i(a, b, f, !0);
            if (!g) return g; //als dichtbij genoeg, anders problemen met canvas click
            var h = g.map(function (c) {
                    return e(a, b, c);
                }),
                j = Math.min.apply(void 0, h);
            if (j < 100) {
                var k = g[h.indexOf(j)];
                return "add_ons" in k
                    ? "head" in k.add_ons &&
                      is_inside(a, b, xywh_to_bbox(k.add_ons.head.bbox))
                        ? k.add_ons.head
                        : "tail" in k.add_ons &&
                            is_inside(a, b, xywh_to_bbox(k.add_ons.tail.bbox))
                          ? k.add_ons.tail
                          : k
                    : k;
            }
        }
        function h(a, b) {
            var c =
                    !(2 < arguments.length && void 0 !== arguments[2]) ||
                    arguments[2],
                d = !1;
            if (
                (d || (d = i(a, b, D)),
                d || (d = i(a, b, E)),
                d || (d = i(a, b, Object.values(F))),
                d || (d = i(a, b, Object.values(z), !1)),
                d || (d = i(a, b, Object.values(w))),
                !!d)
            ) {
                if ("border" == d.iama && merged.is_parent(d)) {
                    var e = i(a, b, Array.from(merged.get_children(d)));
                    e && (d = e);
                }
                var f = i(a, b, find_parts_with_border_id(d.id), !1, 0);
                return c && d && !f ? d : d ? (f ? f : d) : void 0;
            }
        }
        function i(a, b, c) {
            var d =
                    !!(3 < arguments.length && arguments[3] !== void 0) &&
                    arguments[3],
                e = 4 < arguments.length ? arguments[4] : void 0;
            e = e == null ? get_scaled_margin() : get_scaled_margin(e);
            for (
                var f,
                    g = [],
                    h = function f() {
                        var h = c[j],
                            i = !1;
                        if (use_points_for_detection(h)) {
                            //TODO: margin toevoegen ?
                            var k = get_poly_config(h).points,
                                l = k.map(function (a) {
                                    var b = _slicedToArray(a, 2),
                                        c = b[0],
                                        d = b[1];
                                    return [
                                        h.x + c * h.width,
                                        h.y + d * h.height,
                                    ];
                                });
                            i = point_is_inside([a, b], l);
                        } else i = is_inside(a, b, to_bbox(h, e));
                        if (i) {
                            if (!d) return { v: h };
                            g.push(h);
                        }
                    },
                    j = c.length - 1;
                -1 < j;
                j--
            )
                if (((f = h()), f)) return f.v;
            return 0 < g.length ? g : void 0;
        }
        function j(a, b) {
            var c = h(a, b, !0);
            return (
                c && "text" == c.iama && (c = find_border_by_id(c.border_id)),
                void (c && "flipped" in c && flip_shape(c))
            );
        }
        function k(a, b) {
            return i(a, b, Object.values(z));
        }
        function l(a, b) {
            return i(a, b, Object.values(z));
        }
        function m(a) {
            "border_data" in a ? (C[a.border_data.border_id] = a) : o(a);
        }
        function n(a) {
            //TODO6 naam veranderen my_arr kan ook dict zijn
            var b = a.iama;
            if ("border" == b) return a.bound ? w : z;
            return "path_group" == b
                ? A
                : "text" == b
                  ? v
                  : "drawing" == b
                    ? B
                    : "fa_icon" == b
                      ? D
                      : "knot" == b
                        ? E
                        : "math_shape" == b
                          ? F
                          : void 0;
        }
        function o(a) {
            var b = n(a);
            Array.isArray(b)
                ? b.push(a)
                : "text" == a.iama
                  ? r(a)
                  : (b[a.id] = a);
        }
        function p(a) {
            a.draw_order = Date.now();
        } //TODO1 drawings hebben geen id en zullen dus bij slides niet goed gaan
        //drawings dus ook een id geven ??
        function q(a) {
            if (a in z) return z[a];
            if (a in w) return w[a];
            if (a in F) return F[a];
            var b = E.concat(A) //.concat(drawing)
                .filter(function (b) {
                    return b.id == a;
                });
            return 0 != b.length && b[0]; //t=shapes_storage.borders_bound[id]
        }
        function r(a) {
            (a.border_id in v ? v[a.border_id].push(a) : (v[a.border_id] = [a]),
                text_for_render.invalidate_sorted());
        }
        function s(a) {
            ((v[a.border_id] = v[a.border_id].filter(function (b) {
                return b != a;
            })),
                text_for_render.invalidate_sorted());
        }
        function t(a) {
            var b,
                c = _createForOfIteratorHelper(B);
            try {
                for (c.s(); !(b = c.n()).done; ) {
                    var d = b.value;
                    if ("add_ons" in d) {
                        if (d.add_ons.head == a) return d;
                        if (d.add_ons.tail == a) return d;
                    }
                }
            } catch (a) {
                c.e(a);
            } finally {
                c.f();
            }
        }
        var u =
                !!(0 < arguments.length && arguments[0] !== void 0) &&
                arguments[0],
            v = {},
            w = {},
            z = {},
            A = [],
            B = [],
            C = {},
            D = [],
            E = [],
            F = {};
        u &&
            (function d(c) {
                return Array.isArray(c.borders)
                    ? (a(c), !0)
                    : void ((v = c.texts),
                      (w = c.borders_bound),
                      (z = c.borders),
                      (A = c.paths),
                      (D = c.icons),
                      (E = c.knots),
                      (B = c.drawings),
                      c.math_shapes && (F = c.math_shapes),
                      b(c.images));
            })(u);
        return {
            get_text_array_from_ids: function b(a) {
                var c = [];
                return (
                    a.forEach(function (a) {
                        if (a in v) {
                            var b = z[a],
                                d = b && "flipped" in b;
                            d
                                ? ((to_add = v[a].filter(function (a) {
                                      return a.flipped == b.flipped;
                                  })),
                                  to_add.forEach(function (a) {
                                      return c.push(a);
                                  }))
                                : v[a].forEach(function (a) {
                                      return c.push(a);
                                  });
                        }
                    }),
                    c
                );
            },
            add_shapes: function b(a) {
                a.forEach(o);
            },
            add_shape: o,
            add_text: r,
            add_existing_shape: m,
            find_clickable_shape: function c(a, b) {
                var d = gui_buttons.is_resize_button(a, b);
                return d
                    ? d
                    : ((d = gui_buttons.is_flip_button(a, b)), d)
                      ? d
                      : ((d = gui_buttons.is_connect_button(a, b)), d)
                        ? d
                        : ((d = gui_buttons.is_morph_button(a, b)), d)
                          ? d
                          : ((d = gui_buttons.is_path_control_point(a, b)), d)
                            ? d
                            : ((d = gui_buttons.is_line_end_button(a, b)), d)
                              ? d
                              : ((d = h(a, b, !1)), d ? d : f(a, b));
            },
            find_draggable_shape: function b(a) {
                a = a || d3.event.sourceEvent || d3.event;
                var c = get_xy_inverted_from_event(a),
                    d = _slicedToArray(c, 2),
                    k = d[0],
                    l = d[1];
                if (canvas_status.view_mode) return j(k, l);
                if (
                    canvas_status.slide_mode ||
                    (canvas_status.export_mode && !printer.is_fixed_A_ratio())
                ) {
                    var m = gui_buttons.is_path_control_point(k, l);
                    return m ? m : i(k, l, [slider]);
                }
                var g = gui_buttons.is_resize_button(k, l);
                return (g || (g = gui_buttons.is_connect_button(k, l)),
                g || (g = gui_buttons.is_morph_button(k, l)),
                g || (g = gui_buttons.is_par_handle(k, l)),
                g || (g = gui_buttons.is_path_control_point(k, l)),
                g || (g = gui_buttons.is_line_end_button(k, l)),
                !g && gui_buttons.is_flip_button(k, l))
                    ? void 0
                    : (g || (g = h(k, l, !0)), g ? g : f(k, l, !1, !0));
            },
            find_connectable_shape: k,
            find_text_droppable_shape: l,
            texts: v,
            borders_bound: w,
            borders: z,
            paths: A,
            drawings: B,
            images: C,
            icons: D,
            knots: E,
            math_shapes: F,
            find_shapes_in_bbox: d,
            find_shape: h,
            get_data_for_save: c,
            remove: function b(a) {
                if ("text" == a.iama) return (s(a), !1);
                var c = n(a);
                if (Array.isArray(c)) {
                    var d = c.indexOf(a);
                    -1 != d && c.splice(d, 1);
                } else delete c[a.id]; //sort_text_array();
            },
            remove_text: s,
            move_covered_to_top: function a() {
                var b = {
                        top: currentElement.y,
                        left: currentElement.x,
                        bottom: currentElement.y + currentElement.height,
                        right: currentElement.x + currentElement.width,
                    },
                    c = Object.values(shapes_storage.borders).filter(
                        function (a) {
                            return (
                                is_inside(a.x, a.y, b) ||
                                is_inside(a.x + a.width, a.y + a.height, b)
                            );
                        },
                    );
                c.forEach(function (a) {
                    return p(a);
                });
            },
            move_to_top: p,
            get_all: function a() {
                return Object.values(z)
                    .concat(Object.values(F))
                    .concat(Object.values(w))
                    .concat(A)
                    .concat(B)
                    .concat(D)
                    .concat(E)
                    .concat(_.flatten(Object.values(v)));
            },
            search_shapes_with_id: q,
            find_parent_of_drawing_add_on: t,
        };
    }
    function find_borders_bound_by_path_id(a) {
        return Object.values(shapes_storage.borders_bound).filter(function (b) {
            return b.path_id == a;
        });
    }
    function get_text_with_border_id(a) {
        var b =
            !!(1 < arguments.length && arguments[1] !== void 0) && arguments[1];
        if (
            !b &&
            shapes_storage.borders[a] &&
            "flipped" in shapes_storage.borders[a]
        ) {
            var c = shapes_storage.borders[a].flipped;
            return shapes_storage.texts[a].filter(function (a) {
                return a.flipped == c;
            });
        }
        return shapes_storage.texts[a] || [];
    }
    function find_border_by_id(a) {
        if (a in shapes_storage.borders) return shapes_storage.borders[a];
        if (a in shapes_storage.borders_bound)
            return shapes_storage.borders_bound[a];
        if (a in shapes_storage.borders_bound)
            return shapes_storage.math_shapes[a];
        var b = shapes_storage.knots.filter(function (b) {
            return b.id == a;
        });
        return b[0];
    }
    function find_path_by_id(a) {
        var b = shapes_storage.paths.filter(function (b) {
            return b.id == a;
        });
        return b[0];
    }
    function use_points_for_detection(a) {
        return "border" == a.iama && "rect" != a.shape && "ellipse" != a.shape;
    }
    function is_shape_inside_bbox(a, b) {
        return (
            is_inside.apply(
                void 0,
                _toConsumableArray(posit2.get_top_left(a)).concat([b]),
            ) &&
            is_inside.apply(
                void 0,
                _toConsumableArray(posit2.get_bottom_right(a)).concat([b]),
            )
        );
    } //TODO1 drawing op single renderen (langzaam als bv op pantheon getekend path wordt verplaatst)
    //TODO1 slide mode als view mode: view mode aanzetten zodat slide show gestart?
    //TODO1 feedback message toevoegen als view mode uitgescakeld
    ("use strict");
    var text_for_render = (function () {
        function a() {
            (console.log("going to work"),
                (d = Date.now()),
                (g = !0),
                (f = !1),
                h.postMessage([
                    d,
                    _.flatten(Object.values(shapes_storage.texts)) || [],
                    shapes_storage.borders,
                ]));
        }
        var b = !1,
            c = [],
            d = !1,
            f = !1,
            g = !0,
            h = new Worker("/static/js/canvas/worker_sort_text.js");
        return (
            (h.onmessage = function (h) {
                h.data[0] == d
                    ? ((f = !0), (g = !1), (c = h.data[1]))
                    : ((g = !1), !b && a());
            }),
            {
                pause_sorting: function a() {
                    return (b = !0);
                },
                start_sorting: function a() {
                    return (b = !1);
                },
                get_texts: function h(e) {
                    return f
                        ? c.filter(function (a) {
                              return e.has(a.border_id);
                          })
                        : (g || b || a(),
                          shapes_storage.get_text_array_from_ids(e));
                },
                invalidate_sorted: function a() {
                    ((f = !1), (d = Date.now()));
                },
            }
        );
    })();
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function get_new_ids(a) {
        function b(a, b) {
            //return table[old_id] = new_id
            for (
                var c = /"id":"([#|_|A-z][0-9]{4})"/g, d = [], e = {}, f = !0;
                (f = c.exec(a));

            )
                d.push(f[1]);
            ((d = d.sort()),
                d.forEach(function (a) {
                    e[a] = b();
                }));
            var g = new Set(Object.keys(e)),
                h = Object.values(e);
            return e;
        }
        var c = JSON.stringify(a),
            e = b(c, next_id_gen("#", 0)); //twee keer ids converteren om te vermijden dat overlap tussen oude en nieuwe ids bestaan (bv als shapes ids 5 tm 15 naar een lege map worden gekopieerd)
        Object.keys(e).forEach(function (a) {
            var b = new RegExp(a, "g");
            c = c.replace(b, e[a]);
        });
        var e = b(c, get_new_id);
        return (
            Object.keys(e).forEach(function (a) {
                var b = new RegExp(a, "g");
                c = c.replace(b, e[a]);
            }),
            JSON.parse(c)
        );
    }
    function find_highest_ids_per_prefix(a) {
        function b(c) {
            var d = c.slice(0, 1),
                a = c.slice(1);
            return [d, a];
        }
        for (var c = {}, d = 0; d < a.length; d++)
            if (a[d].id && a[d].iama && "path_group" != a[d].iama) {
                var e = b(a[d].id),
                    f = _slicedToArray(e, 2),
                    g = f[0],
                    h = f[1];
                (g in c || (c[g] = "0000"), (c[g] = get_max(c[g], h)));
            }
        return c;
    }
    function get_max(c, d) {
        return ("_" == c && (c = "0"), "_" == d && (d = "0"), c > d ? c : d);
    }
    function pad_id(a) {
        return (
            (res = ""),
            10 > a && (res += "0"),
            100 > a && (res += "0"),
            1e3 > a && (res += "0"),
            res
        );
    }
    function next_id_gen(a, b) {
        var c = b;
        return function () {
            if (9999 < c) {
                var b = get_new_id_prefix_and_num(),
                    d = _slicedToArray(b, 2),
                    e = d[0],
                    f = d[1];
                ((a = e), (c = f));
            }
            return (
                (res = pad_id(c)),
                (res += c.toString()),
                (c += 1),
                a + res
            );
        };
    }
    function get_new_id_prefix_and_num() {
        var a = find_highest_ids_per_prefix(shapes_storage.get_all()),
            b = Object.keys(a)
                .filter(function (a) {
                    return "_" != a;
                })
                .sort(); //underscore gefilterd omdat die hoogste ascii heeft en daardoor fromcharcode +1 verkeerd zou gaan.
        //slaat daardoor wel een hele boel mogelijke id's in _ serie over......
        if (0 < b.length) {
            for (var c = 0; c < b.length; c++)
                if (9999 > a[b[c]]) return [b[c], parseInt(a[b[c]]) + 1];
            return [String.fromCharCode(b.slice(-1)[0].charCodeAt(0) + 1), 0];
        }
        return ["A", 0];
    }
    var get_id_for_table = !1;
    function make_table_id_func() {
        var a =
                0 < arguments.length && arguments[0] !== void 0
                    ? arguments[0]
                    : "t",
            b =
                1 < arguments.length && arguments[1] !== void 0
                    ? arguments[1]
                    : 0;
        return function () {
            return (
                (b += 1),
                a + "0".repeat(4 - b.toString().length) + b.toString()
            );
        };
    }
    function table_init() {
        tables = {};
        var a = Object.values(shapes_storage.borders).filter(function (a) {
            return "table" in a;
        });
        if (0 == a.length) b = 0;
        else {
            ((s = Array.from(
                new Set(
                    a.map(function (a) {
                        return a.table;
                    }),
                ),
            )),
                s.forEach(function (a) {
                    return reconstruct_table(a);
                })); //var start_count = Math.max.apply(undefined, s.map(d=>d.charCodeAt(0)));
            var b = Math.max.apply(
                void 0,
                s.map(function (a) {
                    return parseInt(a.slice(1));
                }),
            ); //start_count = String.fromCharCode(new_table_id);
        }
        get_id_for_table = make_table_id_func("t", b);
    }
    function find_highest_id_and_prefix(a, b) {
        var c = find_highest_ids_per_prefix(a),
            e = "@",
            f = "0000"; //eerste karakter voor A
        return (
            Object.keys(c).forEach(function (a) {
                ((e = get_max(a, e)), (f = get_max(f, c[a])));
            }),
            b ? (b in c ? [e, parseInt(c[b])] : [e, 0]) : [e, parseInt(c[e])]
        );
    } // function clean_ids(){
    //     const ids_dict = find_highest_ids_per_prefix(gs);
    //     var shapes = shapes_storage.get_all_with_id();
    //     let keys_to_clean =  Object.keys(ids_dict).filter(d=>ids_dict[d] < '1000')
    //     keys_to_clean.forEach(  )
    //     //alle shapes verwijderen uit shapes storage
    //     // nieuwe ids maken
    //     data = get_new_ids(data);
    //     //alle shapes weer toevoegen aan shapes storage
    // }
    get_id_for_table = make_table_id_func("t", 0);
    var get_new_id = next_id_gen("_", 0); //TODO1 clean_ids functie maken voor oude maps
    ("use strict");
    var all_form_elements = [
            //'fs_hierarchy',
            "fs_path_label",
            "fs_para",
            "form_border_width",
            "form_border_dash",
            "fs_path",
            "fs_font",
            "form_fill",
            "form_font",
            "form_font_size",
            "fs_border",
            "fs_fig_stuff", //'form_morph',
            "fs_image",
            "form_styling",
            "ffw_fill",
            "ffw_text",
            "ffw_stroke",
            "ffw_stroke2",
            "form_textblock_border",
            "fs_grouping",
            "fs_grouping_quick",
            "form_border_side",
            "fs_path_advanced", //'fs_study_mode'
            "fs_import", //'fs_table', 'fs_table_edit',
            "fs_zoom_pos",
            "fs_drawing",
            "fs_graphing",
            "fs_board",
            "colors_svg",
            "fs_rect_canvas",
            "fs_rough",
        ],
        non_minimal_fieldsets = [
            "fs_zoom_pos", //'fs_set_defaults',//'fs_hierarchy','fs_table',
            "fs_import",
            "fs_grouping",
            "fs_path_advanced",
        ],
        path_form_elements = [
            "fs_path_label",
            "form_fill",
            "fs_colors",
            "fs_border",
            "fs_grouping_quick",
            "colors_svg",
            "form_border_width",
            "form_border_dash",
            "fs_path",
            "ffw_fill",
            "ffw_stroke",
            "fs_path_advanced",
            "fs_zoom_pos",
            "fs_rough",
        ],
        paragraph_form_elements = [
            "form_font_list",
            "fs_font",
            "form_font",
            "form_font_size",
            "form_fill",
            "fs_border",
            "form_border_width",
            "form_border_dash",
            "fs_para",
            "form_font_class",
            "form_font_size",
            "form_styling",
            "ffw_fill",
            "ffw_text",
            "ffw_stroke",
            "form_border_side",
            "fs_zoom_pos",
            "colors_svg",
            "fs_grouping_quick",
        ],
        svg_form_elements = [
            "form_fill",
            "fs_drawing",
            "fs_grouping_quick",
            "ffw_fill",
            "fs_zoom_pos",
            "fs_import",
            "colors_svg",
            "fs_rough",
        ],
        drawing_form_elements = [
            "form_fill",
            "fs_colors",
            "fs_border",
            "form_border_width",
            "form_border_dash",
            "ffw_fill",
            "ffw_stroke",
            "colors_svg",
            "fs_grouping_quick",
            "fs_path_label",
        ],
        path_add_on_form_elements = [
            "form_fill",
            "fs_colors",
            "fs_border",
            "form_border_width",
            "fs_path_label",
            "form_border_dash",
            "ffw_fill",
            "ffw_stroke",
            "colors_svg",
            "fs_grouping_quick",
        ],
        most_common = [
            //'fs_hierarchy',
            "form_font_class",
            "ffw_text",
            "fs_zoom_pos",
            "form_border_width",
            ,
            "form_border_dash",
            "fs_grouping",
            "fs_grouping_quick",
            "fs_font",
            "form_fill",
            "form_font",
            "form_font_size",
            "fs_border",
            "fs_fig_stuff", //'form_morph',
            "form_disperse",
            "form_styling",
            "ffw_fill",
            "ffw_stroke",
            "form_border_side",
            "colors_svg",
            "fs_rough",
        ],
        figs = {
            line_for_graph: {
                svg_fig: "path",
                my_name: "line_for_graph",
                myclasses: ["no_fill"],
                dims: { width: 120, height: 10 },
                styles: { "stroke-width": "3px" },
                my_form_elements: [
                    "form_fill",
                    "fs_graphing",
                    "ffw_stroke",
                    "fs_border",
                    "form_border_width",
                    "form_border_dash",
                    "fs_grouping",
                    "colors_svg",
                    "fs_grouping_quick",
                ],
                my_menu: "empty",
            },
            x_axis: {
                svg_fig: "d3_axis",
                my_name: "x_axis",
                dims: { width: 120, height: 10 },
                myclasses: ["font4", "i_am_grouped"],
                my_style_classes: ["style_20"],
                styles: { "stroke-width": "2px", stroke: "rgb(75,75,75)" },
                copyable: !1,
                my_form_elements: [
                    "fs_path_label",
                    "form_fill",
                    "ffw_text",
                    "ffw_stroke",
                    "fs_font",
                    "form_font",
                    "form_font_size",
                    "fs_border",
                    "form_border_width",
                    "form_border_dash",
                    "fs_grouping_quick",
                ],
                my_menu: "empty",
            },
            y_axis: {
                svg_fig: "d3_axis",
                my_name: "y_axis",
                dims: { width: 10, height: 120 },
                myclasses: ["font4", "i_am_grouped"],
                my_style_classes: ["style_20"],
                styles: { "stroke-width": "2px", stroke: "rgb(75,75,75)" },
                copyable: !1,
                my_form_elements: [
                    "fs_path_label",
                    "form_fill",
                    "ffw_text",
                    "ffw_stroke",
                    "fs_font",
                    "form_font",
                    "form_font_size",
                    "fs_border",
                    "form_border_width",
                    "form_border_dash",
                    "fs_grouping_quick",
                ],
                my_menu: "empty",
            },
            axes_board: {
                svg_fig: "rect",
                my_name: "axes_board",
                dims: {
                    graph_axis_crossed: !0,
                    gridded: !0,
                    width: 400,
                    height: 400,
                    domain_x: [-2, 2],
                    domain_y: [2, -2],
                },
                myclasses: ["evade_me", "sticky", "no_nums"],
                my_style_classes: ["style_18"],
                styles: { "stroke-width": "1px" },
                copyable: !1,
                my_form_elements: [
                    "form_fill",
                    "fs_board",
                    "ffw_fill",
                    "fs_grouping",
                    "fs_grouping_quick",
                    "colors_svg",
                    "fs_border",
                    "form_border_width",
                    "form_border_dash",
                ],
            },
            graph_basic: {
                svg_fig: "rect",
                my_name: "graph_basic",
                dims: {
                    width: 250,
                    height: 250,
                    domain_x: [-2, 2],
                    domain_y: [2, -2],
                },
                myclasses: ["evade_me", "canvas_layer"],
                my_style_classes: ["style_20"],
                styles: { "stroke-width": "0px" },
                copyable: !1,
                my_form_elements: [
                    "form_fill",
                    "fs_graphing",
                    "ffw_fill",
                    "fs_grouping",
                    "fs_grouping_quick",
                    "colors_svg",
                ],
            },
            country_basic: {
                svg_fig: "path",
                my_name: "path_basic",
                dims: { width: 120, height: 90 },
                myclasses: ["path", ""],
                my_style_classes: ["style_20"],
                my_form_elements: most_common,
                my_menu: "fig",
                copyable: !1,
            },
            path_basic: {
                svg_fig: "path",
                my_name: "path_basic",
                dims: { width: 120, height: 90 },
                myclasses: ["evade_me", "path", ""],
                my_style_classes: ["style_20"],
                styles: { "stroke-width": "2px", "pointer-events": "stroke" },
                my_form_elements: most_common
                    .filter(function (a) {
                        return (
                            "ffw_stroke" != a &&
                            "fs_hierarchy" != a &&
                            "form_border_side" != a &&
                            "fs_fig_stuff" != a
                        );
                    })
                    .concat(["fs_path_label", "fs_path_advanced"]),
                my_menu: "fig",
                copyable: !0,
                custom_bbox: !0,
            },
            polygon: {
                svg_fig: "polygon",
                my_name: "polygon",
                dims: { width: 120, height: 90 },
                myclasses: ["evade_me", "polygon_basic"],
                my_style_classes: ["style_20"],
                my_form_elements: most_common,
                my_menu: "fig",
                copyable: !0,
            }, //poly_points: {
            custom: {
                svg_fig: "polygon",
                my_name: "poly_points", //dims: {'width': 120, 'height': 90 }, //, 'rx': 25, 'ry': 15},
                myclasses: ["evade_me", "polygon_basic", "canvas_layer"],
                my_style_classes: ["style_6"],
                my_form_elements: most_common,
                my_menu: "poly_points",
                copyable: !0,
            },
            poly_points_fo: {
                svg_fig: "polygon",
                my_name: "poly_points_fo", //dims: {'width': 120, 'height': 90 }, //, 'rx': 25, 'ry': 15},
                myclasses: ["evade_me", "polygon_basic"],
                my_style_classes: ["style_4"],
                my_form_elements: most_common,
                my_menu: "fig",
                copyable: !0,
            },
            slide: {
                svg_fig: "polygon",
                my_name: "slide",
                myclasses: ["polygon_basic", "canvas_layer"], //styles: {'fill':'rgba(159,172,201,0.20)', 'stroke-width': '1px', 'stroke':'black', 'stroke-dasharray':' 15 35'},
                my_style_classes: ["slider"],
                my_form_elements: ["fs_zoom_pos"],
                my_menu: "slide",
                copyable: !1,
            },
            rect_basic: {
                svg_fig: "rect",
                my_name: "rect_basic",
                dims: { width: 180, height: 80, rx: 1, ry: 1 },
                myclasses: ["evade_me"],
                my_style_classes: ["style_20"],
                my_form_elements: most_common,
                my_menu: "fig",
                copyable: !0,
            },
            cell_basic: {
                svg_fig: "rect",
                my_name: "cell_basic",
                dims: { width: 180, height: 80, rx: 2, ry: 2 },
                myclasses: [],
                my_style_classes: ["style_20"],
                my_form_elements: most_common, //.concat([ 'fs_table_edit']),
                my_menu: "fig",
                copyable: !0,
            },
            tan_rect: {
                svg_fig: "rect",
                my_name: "tan_rect",
                dims: { width: 180, height: 80, rx: 2, ry: 2 },
                myclasses: ["evade_me"],
                my_style_classes: ["style_6"],
                my_form_elements: most_common,
                copyable: !1,
            },
            rect_canvas: {
                svg_fig: "rect",
                my_name: "rect_canvas",
                dims: { width: 150, height: 100, rx: 1, ry: 0 },
                myclasses: ["canvas_layer"],
                my_style_classes: ["coney_island1"],
                my_form_elements: [
                    "form_fill",
                    "fs_border",
                    "form_border_width",
                    "form_fill_what",
                    "fs_rect_canvas",
                    "fs_grouping_quick",
                    "form_border_width",
                    "form_group",
                    "form_disperse",
                    "ffw_fill",
                    "ffw_stroke",
                    "fs_grouping",
                    "colors_svg",
                    "form_border_side",
                ],
                copyable: !0,
                my_menu: "rect_canvas",
            },
            ellipse: {
                svg_fig: "ellipse",
                my_name: "ellipse_basic",
                dims: { rx: 60, ry: 40 },
                myclasses: ["mainfig", "evade_me"],
                my_style_classes: ["style_20"],
                my_form_elements: most_common.filter(function (a) {
                    return "form_border_side" != a;
                }),
                my_menu: "fig",
                copyable: !0,
            },
            cp_resize: {
                svg_fig: "circle",
                my_name: "cp_resize",
                dims: { r: 5 },
                styles: {
                    fill: "red",
                    "stroke-width": "2px",
                    stroke: "black",
                    "stroke-dasharray": "0",
                },
                my_style_classes: ["cp_resize"],
                style_on_fig: !0,
                my_form_elements: [],
                copyable: !1,
            },
            cp_helper: {
                svg_fig: "circle",
                my_name: "cp_helper",
                dims: { r: 5 },
                styles: { "stroke-dasharray": "0" },
                my_style_classes: ["cp_helper"],
                style_on_fig: !0,
                my_form_elements: [],
                copyable: !1,
            },
            catcher: {
                svg_fig: "mainfig",
                my_name: "catcher",
                dims: { rx: 10, ry: 10 },
                styles: { "stroke-dasharray": "0" }, //, 'stroke-width': 10   },
                my_style_classes: ["catcher"],
                style_on_fig: !1,
                my_form_elements: [],
                copyable: !1,
            },
            cp_rotate: {
                svg_fig: "circle",
                my_name: "cp_rotate",
                dims: { r: 5 },
                styles: {
                    fill: "orange",
                    "stroke-width": "2px",
                    stroke: "black",
                    "stroke-dasharray": "0",
                },
                my_style_classes: ["cp_rotate"],
                style_on_fig: !0,
                my_form_elements: [],
                copyable: !1,
            },
            fo: {
                svg_fig: "foreignObject",
                my_name: "fo",
                dims: {},
                styles: {},
                copyable: !1,
            },
            knot: {
                svg_fig: "circle",
                my_name: "knot",
                dims: { r: 5, width: 1, height: 1 },
                styles: { fill: "none", stroke: "black" }, //{'fill':'white', 'z-index': -2, 'stroke': 'red', 'fill-opacity': 0.02 },
                myclasses: ["mainfig"],
                my_style_classes: ["style_23"],
                my_form_elements: [
                    "fs_colors",
                    "form_fill",
                    "form_border_width",
                    "fs_grouping",
                    "fs_grouping_quick",
                    "fs_border",
                    "form_border_width",
                    "fs_fig_stuff",
                    "colors_svg",
                ],
                my_menu: "knot",
                copyable: !1,
            },
            knot_gui: {
                svg_fig: "circle",
                my_name: "knot_gui",
                dims: {
                    r: 12,
                    width: 1,
                    height: 1,
                    transform: "translate(-10,10)",
                },
                styles: {},
                myclasses: ["mainfig"],
                my_form_elements: [],
                copyable: !1,
            },
            knot_hierarchy: {
                svg_fig: "circle",
                my_name: "knot_hierarchy",
                dims: { r: 5, width: 1, height: 1 },
                styles: {},
                myclasses: ["mainfig"],
                my_form_elements: [
                    "fs_colors",
                    "form_fill",
                    "form_border_width",
                    "fs_grouping",
                    "fs_grouping_quick",
                    "fs_border",
                    "form_border_width",
                    "fs_fig_stuff",
                ],
                my_menu: "knot",
                copyable: !1,
            },
            poly_point: {
                svg_fig: "circle",
                my_name: "poly_point",
                dims: { r: 5, width: 1, height: 1 },
                styles: {}, //{'fill':'white', 'z-index': -2, 'stroke': 'red', 'fill-opacity': 0.02 },
                myclasses: [],
                my_form_elements: [
                    "fs_colors",
                    "form_fill",
                    "form_border_width",
                    "fs_grouping",
                    "fs_grouping_quick",
                    "fs_border",
                    "form_border_width",
                    "fs_fig_stuff",
                    "colors_svg",
                ],
                my_menu: "knot",
                copyable: !0,
            },
            text_basic: {
                svg_fig: "text",
                my_name: "text_basic",
                dims: {}, //styles: {'font-family': 'verdana' },//'stroke-width': 0, 'stroke': 'black' },
                myclasses: ["mainfig"],
                my_style_classes: ["style_23", "font2"],
                my_form_elements: [
                    "fs_colors",
                    "fs_zoom_pos",
                    "form_border_width",
                    "form_border_dash",
                    "fs_grouping",
                    "fs_grouping_quick",
                    "fs_font",
                    "form_fill",
                    "form_font",
                    "form_font_size",
                    "fs_border",
                    "form_border_width",
                    "ffw_fill",
                    "ffw_stroke",
                    "colors_svg",
                ],
                my_menu: "text",
                copyable: !0,
            },
            text_path: {
                svg_fig: "textPath",
                my_name: "text_path",
                dims: {}, //styles: {'font-family': 'verdana', 'font-size': '16px', 'stroke-width': 0,'stroke': 'black' },
                myclasses: ["mainfig"],
                my_style_classes: ["style_23", "font4"],
                my_form_elements: [
                    "fs_colors",
                    "fs_zoom_pos",
                    "fs_border",
                    "form_border_width", //'fs_path_label',
                    "fs_font",
                    "form_fill",
                    "form_font",
                    "form_font_size",
                    "ffw_fill",
                    "ffw_stroke",
                    "fs_grouping_quick",
                    "colors_svg",
                ],
                my_menu: "text-on-path",
                copyable: !1,
            },
            text_block: {
                svg_fig: "text",
                my_name: "text_block",
                dims: {}, //styles: {'font-family': 'verdana', 'font-size': '16px'},//, 'stroke-width': 0, 'stroke': 'black' },
                myclasses: ["font4"],
                my_style_classes: ["style_23"],
                my_form_elements: [
                    "fs_colors",
                    "fs_zoom_pos",
                    "fs_border",
                    "form_border_width", //'fs_path_label',
                    "fs_font",
                    "form_fill",
                    "form_font",
                    "form_font_size",
                    "ffw_fill",
                    "ffw_text",
                    "ffw_stroke",
                    "ffw_stroke2",
                    "form_textblock_border",
                    "form_border_dash",
                    "fs_grouping_quick",
                    "colors_svg",
                ],
                my_menu: "text-on-path",
                copyable: !1,
            },
            fa_icon: {
                svg_fig: "text",
                my_name: "icon_basic",
                dims: {},
                styles: { "font-family": "FontAwesome" }, //, 'stroke-width':1, 'stroke': 'black'},
                myclasses: ["mainfig"],
                my_style_classes: ["style_23", "font1"],
                my_form_elements: [
                    "fs_colors",
                    "fs_zoom_pos",
                    "fs_grouping",
                    "fs_font",
                    "form_fill",
                    "form_font_size",
                    "colors_svg",
                    "form_disperse",
                    "fs_border",
                    "form_border_width",
                    "form_border_dash",
                    "ffw_fill",
                    "ffw_stroke",
                    "fs_grouping_quick",
                ],
                my_menu: "icon",
                copyable: !0,
            },
            math_basic: {
                svg_fig: "relay",
                my_name: "math_basic",
                dims: { width: 100, height: 100 }, //styles: {'width':100, 'height':100},
                myclasses: ["mainfig"],
                my_style_classes: ["style_23", "font2"],
                my_form_elements: [
                    "fs_colors",
                    "fs_zoom_pos",
                    "fs_grouping",
                    "fs_font",
                    "form_fill",
                    "form_font_size",
                    "fs_fig_stuff",
                    "colors_svg",
                    "form_disperse",
                    "fs_border",
                    "form_border_width",
                    "form_border_dash",
                    "ffw_fill",
                    "ffw_stroke",
                    "fs_grouping_quick",
                ],
                my_menu: "icon",
                copyable: !0,
            },
        },
        poly_config = {
            rect: {
                points: [
                    [0, 0],
                    [1, 0],
                    [1, 1],
                    [0, 1],
                ],
                fo_top_left: [0, 0],
                fo_width: 1,
                fo_height: 1,
                dims: { width: 90, height: 90 },
                borders: [[0], [1], [2], [3]],
            },
            triangle_u: {
                points: [
                    [0.5, 0],
                    [1, 1],
                    [0, 1],
                ],
                fo_top_left: [0.25, 0.5],
                fo_width: 0.5,
                fo_height: 0.5,
                dims: { width: 120, height: 90 },
                borders: [[2, 0], [0], [1], [2]],
            },
            triangle_d: {
                points: [
                    [0, 0],
                    [1, 0],
                    [0.5, 1],
                ],
                fo_top_left: [0.25, 0],
                fo_width: 0.5,
                fo_height: 0.5,
                dims: { width: 120, height: 90 },
                borders: [[0], [1], [1, 2], [2]],
            },
            triangle_l: {
                points: [
                    [1, 0],
                    [1, 1],
                    [0, 0.5],
                ],
                fo_top_left: [0.5, 0.25],
                fo_width: 0.5,
                fo_height: 0.5,
                dims: { width: 90, height: 90 },
                borders: [[2], [0], [1], [1, 2]],
            },
            triangle_r: {
                points: [
                    [0, 0],
                    [1, 0.5],
                    [0, 1],
                ],
                fo_top_left: [0, 0.25],
                fo_width: 0.5,
                fo_height: 0.5,
                dims: { width: 90, height: 90 },
                borders: [[0], [0, 1], [1], [2]],
            },
            rhombus: {
                points: [
                    [0.5, 0],
                    [1, 0.5],
                    [0.5, 1],
                    [0, 0.5],
                ],
                fo_top_left: [0.25, 0.25],
                fo_width: 0.5,
                fo_height: 0.5,
                dims: { width: 90, height: 90 },
                borders: [
                    [3, 0],
                    [0, 1],
                    [1, 2],
                    [2, 3],
                ],
            },
            diamond: {
                points: [
                    [0.2, 0],
                    [0.8, 0],
                    [1, 0.25],
                    [0.5, 1],
                    [0, 0.25],
                ],
                fo_top_left: [0.2, 0],
                fo_width: 0.6,
                fo_height: 0.5,
                dims: { width: 90, height: 90 },
                borders: [
                    [4, 0, 1],
                    [1, 2],
                    [2, 3],
                    [3, 4],
                ],
            },
            hexagon_v: {
                points: [
                    [0.5, 0],
                    [1, 0.25],
                    [1, 0.75],
                    [0.5, 1],
                    [0, 0.75],
                    [0, 0.25],
                ],
                fo_top_left: [0, 0.25],
                fo_width: 1,
                fo_height: 0.5,
                dims: { width: 100, height: 80 },
                borders: [
                    [5, 0],
                    [0, 1, 2],
                    [2, 3],
                    [3, 4, 5],
                ],
            },
            hexagon_h: {
                points: [
                    [0, 0.5],
                    [0.25, 0],
                    [0.75, 0],
                    [1, 0.5],
                    [0.75, 1],
                    [0.25, 1],
                ],
                fo_top_left: [0.25, 0],
                fo_width: 0.5,
                fo_height: 1,
                dims: { width: 100, height: 80 },
                borders: [
                    [0, 1, 2],
                    [2, 3],
                    [3, 4, 5],
                    [5, 0],
                ],
            }, //http://mathcentral.uregina.ca/QQ/database/QQ.09.07/h/lewis1.html
            octagon: (function (a) {
                return (
                    (s = a / (1 + Math.sqrt(2))),
                    (x = (a - s) / 2),
                    {
                        points: [
                            [x, 0],
                            [x + s, 0],
                            [1, x],
                            [1, x + s],
                            [x + s, 1],
                            [x, 1],
                            [0, x + s],
                            [0, x],
                        ],
                        fo_top_left: [x / 2, x / 2],
                        fo_width: x + s,
                        fo_height: x + s,
                        borders: [
                            [7, 0, 1],
                            [1, 2, 3],
                            [3, 4, 5],
                            [5, 6, 7],
                        ],
                        dims: { width: 90, height: 90 },
                    }
                );
            })(1), //vervangen door prallelo_####. Staat er nog voor backward compat
            parallellogram: {
                points: [
                    [0.5, 0],
                    [1, 0],
                    [0.5, 1],
                    [0, 1],
                ],
                fo_top_left: [0.25, 0],
                dims: { width: 90, height: 90 },
                fo_width: 0.5,
                fo_height: 1,
            }, //index van points hetzelfde houden voor up / down left , right.
            //Nummers van point is vast,nummering dus bepaald door right-variant
            //alleen bij arrow_right meest linksboven =0,
            arrow_right: {
                points: [
                    [0, 0.25],
                    [2 / 3, 0.25],
                    [2 / 3, 0],
                    [1, 0.5],
                    [2 / 3, 1],
                    [2 / 3, 0.75],
                    [0, 0.75],
                ],
                fo_top_left: [0, 0.25],
                fo_width: 2 / 3,
                fo_height: 0.5,
                borders: [
                    [0, 1, 2],
                    [2, 3],
                    [3, 4, 5],
                    [4, 6, 1],
                ],
                dims: { width: 110, height: 90 },
                shape: function (a, b, c) {
                    return (
                        [1, 2, 5, 4].forEach(function (c) {
                            return (a[c][0] += b);
                        }),
                        [0, 1].forEach(function (b) {
                            return (a[b][1] += c);
                        }),
                        [6, 5].forEach(function (b) {
                            return (a[b][1] -= c);
                        }),
                        a
                    );
                },
                fo_dims: function (a) {
                    return [a[0], a[1][0] - a[0][0], a[6][1] - a[0][1]];
                },
                reshape_icon: 53,
                cp_index: 1,
            }, //arrows,arrows-h, arrows-v
            //eerste regels tm dims voor initele waardes, daarna shape en dims_fo voor berekenen bij wijzigingen bestaand figuur
            //cp_index is punt waar gui_element bij in de buurt wordt gelegd
            //fo_dims retourneerd [tl, w, h], shape: in abs_points, dx, dy, uit: abs_points, dx, dy
            arrow_left: {
                points: [
                    [1, 0.75],
                    [1 / 3, 0.75],
                    [1 / 3, 1],
                    [0, 0.5],
                    [1 / 3, 0],
                    [1 / 3, 0.25],
                    [1, 0.25],
                ],
                fo_top_left: [1 / 3, 0.25],
                fo_width: 2 / 3,
                fo_height: 0.5,
                borders: [
                    [3, 4, 5],
                    [4, 6, 1],
                    [0, 1, 2],
                    [2, 3],
                ],
                dims: { width: 110, height: 90 },
                shape: function (a, b, c) {
                    return (
                        [1, 2, 5, 4].forEach(function (c) {
                            return (a[c][0] += b);
                        }),
                        [0, 1].forEach(function (b) {
                            return (a[b][1] -= c);
                        }),
                        [6, 5].forEach(function (b) {
                            return (a[b][1] += c);
                        }),
                        a
                    );
                },
                fo_dims: function (a) {
                    //trans, w, h
                    return [a[5], a[0][0] - a[1][0], a[0][1] - a[6][1]];
                },
                cp_index: 5,
                reshape_icon: 53,
            },
            arrow_up: {
                points: [
                    [0.25, 1],
                    [0.25, 1 / 3],
                    [0, 1 / 3],
                    [0.5, 0],
                    [1, 1 / 3],
                    [0.75, 1 / 3],
                    [0.75, 1],
                ],
                fo_top_left: [0.25, 1 / 3],
                fo_width: 0.5,
                fo_height: 2 / 3,
                borders: [
                    [2, 3],
                    [3, 5],
                    [4, 6, 1],
                    [0, 1, 2],
                ],
                dims: { width: 90, height: 110 },
                shape: function (a, b, c) {
                    return (
                        [1, 2, 5, 4].forEach(function (b) {
                            return (a[b][1] += c);
                        }),
                        [0, 1].forEach(function (c) {
                            return (a[c][0] -= b);
                        }),
                        [6, 5].forEach(function (c) {
                            return (a[c][0] += b);
                        }),
                        a
                    );
                },
                fo_dims: function (a) {
                    return [a[1], a[6][0] - a[0][0], a[0][1] - a[1][1]];
                },
                cp_index: 5,
                reshape_icon: 53,
            },
            arrow_down: {
                points: [
                    [0.75, 0],
                    [0.75, 2 / 3],
                    [1, 2 / 3],
                    [0.5, 1],
                    [0, 2 / 3],
                    [0.25, 2 / 3],
                    [0.25, 0],
                ],
                fo_top_left: [0.25, 0],
                fo_width: 0.5,
                fo_height: 2 / 3,
                borders: [
                    [4, 6, 1],
                    [0, 2],
                    [2, 3],
                    [3, 5],
                ],
                dims: { width: 90, height: 110 },
                shape: function (a, b, c) {
                    return (
                        [1, 2, 5, 4].forEach(function (b) {
                            return (a[b][1] += c);
                        }),
                        [0, 1].forEach(function (c) {
                            return (a[c][0] += b);
                        }),
                        [6, 5].forEach(function (c) {
                            return (a[c][0] -= b);
                        }),
                        a
                    );
                },
                fo_dims: function (a) {
                    return [a[6], a[0][0] - a[6][0], a[1][1] - a[0][1]];
                },
                reshape_icon: 53,
                cp_index: 1,
            }, //bij chevron wel opnieuw geteld voor elke variant vanaf punt meest linksboven = index 0
            chevron_right: {
                points: [
                    [0, 0],
                    [0.8, 0],
                    [1, 0.5],
                    [0.8, 1],
                    [0, 1],
                    [0.2, 0.5],
                ],
                fo_top_left: [0.2, 0],
                fo_width: 0.6,
                fo_height: 1,
                borders: [
                    [0, 1],
                    [1, 2],
                    [2, 3],
                    [4, 5],
                ],
                dims: { width: 100, height: 70 },
                shape: function (a, b) {
                    return (
                        [2, 5].forEach(function (c) {
                            return (a[c][0] += b);
                        }),
                        a
                    );
                },
                fo_dims: function (a) {
                    return [[a[5][0], 0], a[1][0] - a[5][0], a[3][1] - a[1][1]];
                },
                reshape_icon: 25,
                cp_index: 2,
            },
            chevron_left: {
                points: [
                    [0.2, 0],
                    [1, 0],
                    [0.8, 0.5],
                    [1, 1],
                    [0.2, 1],
                    [0, 0.5],
                ],
                fo_top_left: [0.2, 0],
                fo_width: 0.6,
                fo_height: 1,
                borders: [
                    [5, 0],
                    [1, 2],
                    [3, 4],
                    [4, 5],
                ],
                dims: { width: 100, height: 70 },
                shape: function (a, b) {
                    return (
                        [2, 5].forEach(function (c) {
                            return (a[c][0] += b);
                        }),
                        a
                    );
                },
                fo_dims: function (a) {
                    return [a[0], a[2][0] - a[0][0], a[4][1] - a[0][1]];
                },
                reshape_icon: 25,
                cp_index: 2,
            },
            chevron_up: {
                points: [
                    [0, 0.2],
                    [0.5, 0],
                    [1, 0.2],
                    [1, 1],
                    [0.5, 0.8],
                    [0, 1],
                ],
                fo_top_left: [0, 0.2],
                fo_width: 1,
                fo_height: 0.6,
                borders: [
                    [0, 1],
                    [1, 2],
                    [3, 4],
                    [5, 0],
                ],
                dims: { width: 60, height: 90 },
                shape: function (a, b, c) {
                    return (
                        [1, 4].forEach(function (b) {
                            return (a[b][1] += c);
                        }),
                        a
                    );
                },
                fo_dims: function (a) {
                    return [a[0], a[2][0] - a[0][0], a[4][1] - a[0][1]];
                },
                reshape_icon: 26,
                cp_index: 1,
            },
            chevron_down: {
                points: [
                    [0, 0],
                    [0.5, 0.2],
                    [1, 0],
                    [1, 0.8],
                    [0.5, 1],
                    [0, 0.8],
                ],
                fo_top_left: [0, 0.2],
                fo_width: 1,
                fo_height: 0.6,
                borders: [
                    [0, 1],
                    [1, 2],
                    [2, 3],
                    [4, 5],
                ],
                dims: { width: 60, height: 90 },
                shape: function (a, b, c) {
                    return (
                        [1, 4].forEach(function (b) {
                            return (a[b][1] += c);
                        }),
                        a
                    );
                },
                fo_dims: function (a) {
                    return [[0, a[1][1]], a[2][0] - a[0][0], a[3][1] - a[1][1]];
                },
                reshape_icon: 26,
                cp_index: 1,
            },
            house_up: {
                points: [
                    [0.5, 0],
                    [1, 0.3],
                    [1, 1],
                    [0, 1],
                    [0, 0.3],
                ],
                fo_top_left: [0, 0.3],
                fo_width: 1,
                fo_height: 0.7,
                borders: [[4, 0], [0, 1], [2], [3, 4]],
                dims: { width: 70, height: 90 },
                shape: function (a, b, c) {
                    return ((a[0][1] -= c), a);
                },
                fo_dims: function (a) {
                    return [a[4], a[1][0] - a[4][0], a[2][1] - a[1][1]];
                },
                reshape_icon: 26,
                cp_index: 1,
            },
            house_down: {
                points: [
                    [0.5, 1],
                    [0, 0.7],
                    [0, 0],
                    [1, 0],
                    [1, 0.7],
                ],
                fo_top_left: [0, 0],
                fo_width: 1,
                fo_height: 0.7,
                borders: [[2], [3, 4], [4, 0], [0, 1]],
                dims: { width: 70, height: 90 },
                shape: function (a, b, c) {
                    return ((a[0][1] -= c), a);
                },
                fo_dims: function (a) {
                    return [a[2], a[4][0] - a[1][0], a[1][1] - a[2][1]];
                },
                reshape_icon: 26,
                cp_index: 1,
            },
            house_left: {
                points: [
                    [0, 0.5],
                    [0.3, 0],
                    [1, 0],
                    [1, 1],
                    [0.3, 1],
                ],
                fo_top_left: [0.3, 0],
                fo_width: 0.7,
                fo_height: 1,
                borders: [[0, 1], [2], [3, 4], [4, 0]],
                dims: { width: 70, height: 90 },
                shape: function (a, b) {
                    return ((a[0][0] -= b), a);
                },
                fo_dims: function (a) {
                    return [a[1], a[2][0] - a[1][0], a[3][1] - a[2][1]];
                },
                reshape_icon: 25,
                cp_index: 1,
            },
            house_right: {
                points: [
                    [1, 0.5],
                    [0.7, 1],
                    [0, 1],
                    [0, 0],
                    [0.7, 0],
                ],
                fo_top_left: [0, 0],
                fo_width: 0.7,
                fo_height: 1,
                borders: [[3, 4], [4, 0], [0, 1], [2]],
                dims: { width: 70, height: 90 },
                shape: function (a, b) {
                    return ((a[0][0] -= b), a);
                },
                fo_dims: function (a) {
                    return [a[3], a[1][0] - a[2][0], a[2][1] - a[3][1]];
                },
                reshape_icon: 25,
                cp_index: 1,
            },
            parallello_hor: {
                points: [
                    [0.25, 0],
                    [1, 0],
                    [0.75, 1],
                    [0, 1],
                ],
                fo_top_left: [0.25, 0],
                fo_width: 0.5,
                fo_height: 1,
                borders: [[3, 0], [1], [1, 2], [3]],
                dims: { width: 70, height: 90 },
                shape: function (a, b) {
                    return ((a[0][0] += b), (a[2][0] -= b), a);
                },
                fo_dims: function (a) {
                    return [a[0], a[2][0] - a[0][0], a[3][1] - a[0][1]];
                },
                reshape_icon: 25,
                cp_index: 1,
            },
            parallello_hor_mirrored: {
                points: [
                    [0, 0],
                    [0.75, 0],
                    [1, 1],
                    [0.25, 1],
                ],
                fo_top_left: [0.25, 0],
                fo_width: 0.5,
                fo_height: 1,
                borders: [[0, 1], [1], [2, 3], [3]],
                dims: { width: 70, height: 90 },
                shape: function (a, b) {
                    return ((a[1][0] += b), (a[3][0] -= b), a);
                },
                fo_dims: function (a) {
                    return [
                        [a[3][0], a[0][1]],
                        a[1][0] - a[3][0],
                        a[2][1] - a[1][1],
                    ];
                },
                reshape_icon: 25,
                cp_index: 1,
            },
            parallello_vert: {
                points: [
                    [0, 0.25],
                    [1, 0],
                    [1, 0.75],
                    [0, 1],
                ],
                fo_top_left: [0, 0.25],
                fo_width: 1,
                fo_height: 0.5,
                borders: [[0], [1, 2], [2], [3, 0]],
                dims: { width: 70, height: 90 },
                shape: function (a, b, c) {
                    return ((a[0][1] -= c), (a[2][1] += c), a);
                },
                fo_dims: function (a) {
                    return [a[0], a[1][0] - a[0][0], a[2][1] - a[0][1]];
                },
                reshape_icon: 26,
                cp_index: 1,
            },
            parallello_vert_mirrored: {
                points: [
                    [0, 0],
                    [1, 0.25],
                    [1, 1],
                    [0, 0.75],
                ],
                fo_top_left: [0, 0.25],
                fo_width: 1,
                borders: [[0], [0, 1], [2], [2, 3]],
                fo_height: 0.5,
                dims: { width: 70, height: 90 },
                shape: function (a, b, c) {
                    return ((a[0][1] -= c), (a[2][1] += c), a);
                },
                fo_dims: function (a) {
                    return [
                        [a[0][0], a[1][1]],
                        a[1][0] - a[0][0],
                        a[3][1] - a[1][1],
                    ];
                },
                reshape_icon: 26,
                cp_index: 1,
            },
        },
        polygon_shapes = Object.keys(poly_config),
        simple_perc = function (a) {
            return function (b, c, d) {
                return b + c * a * d;
            };
        },
        perc_with_min = function (a, b) {
            return function (c, d, e) {
                return a * d > b ? simple_perc(a)(c, d, e) : c + b * e;
            };
        },
        line_styles = {
            straight: { perpendicular: [0.5, 0.5], inline: [0.5, 0.5] },
            fluid: { perpendicular: [0.5, 0.5], inline: [0, 0] },
            manh_swirl: { perpendicular: [1, 1], inline: [0, 0] },
            manhattan: {},
            arced: { perpendicular: [0.4, 0.4], inline: [-20, 0.8] },
            super_swirl: {
                perpendicular: [simple_perc(0.6), simple_perc(0.4)],
                inline: [perc_with_min(-0.2, -20), perc_with_min(-0.3, -50)],
            },
        },
        path_specs = {
            part_of: {
                thickness: "thick_to_thin",
                style: {
                    "stroke-width": "2px",
                    stroke: "black",
                    fill: "rgb(186, 41, 41)",
                    "fill-opacity": 0.8,
                },
            },
            example_of: {
                thickness: "thick_to_thin",
                style: {
                    "stroke-width": "3px",
                    stroke: "rgb(51, 45, 45)",
                    fill: "steelblue",
                    "fill-opacity": 0.8,
                },
            },
            plain: {
                thickness: "single_stroke",
                style: {
                    "stroke-width": "3px",
                    stroke: "rgb(77,64,64)",
                    fill: "None",
                    "fill-opacity": 0.9, //'stroke-linecap': 'round'
                },
            },
            double: {
                thickness: "double",
                style: {
                    "stroke-width": "6px",
                    stroke: "rgb(207, 85, 68)",
                    fill: "None",
                    "fill-opacity": 0.8, //'stroke-linecap': 'round'
                },
            },
            double_inner: {
                thickness: "single_stroke",
                style: {
                    "stroke-width": "4px",
                    stroke: "white",
                    fill: "None",
                    "fill-opacity": 1,
                },
            },
            click_catcher: {
                thickness: "single_stroke",
                style: {
                    "stroke-width": "20px", // 'stroke': 'black',
                    // 'stroke-opacity': 0,
                    fill: "None",
                    "stroke-dasharray": 0,
                },
            },
        }; //'fs_set_defaults',
    //'fs_grouping',  'fs_grouping_quick','fs_fig_stuff',
    //'fs_set_defaults'  'fs_table' ,
    //TODO9 niet alle attrs meer gebruikt. opschonen
    //TODO8 min max /abs controleren
    ("use strict");
    var predef_styles = (function () {
            function a() {
                var a =
                        !!(0 < arguments.length && void 0 !== arguments[0]) &&
                        arguments[0],
                    c =
                        !!(1 < arguments.length && void 0 !== arguments[1]) &&
                        arguments[1];
                (a || (a = active_style.style_class),
                    shapes_storage
                        .get_all()
                        .filter(function (b) {
                            return b.style_class == a;
                        })
                        .forEach(function (d) {
                            (b(d, a),
                                c &&
                                    "border" == d.iama &&
                                    (recalc_border_width(d.id),
                                    position_texts(d.id)));
                        }),
                    render_all(0, !1, !0));
            }
            function b(a) {
                function b(a, b, c) {
                    (a.has_own_style ||
                        ["fill", "stroke", "color", "stroke_width"].forEach(
                            function (c) {
                                a[c] = b[c];
                            },
                        ),
                        a.font_fam_inherited && (a.font_family = b.font_family),
                        a.font_size_inherited &&
                            (a.font_size = infinity.get_font_size(
                                c,
                                e.font_class,
                            )),
                        measure_text(a));
                }
                var d =
                        !!(1 < arguments.length && void 0 !== arguments[1]) &&
                        arguments[1],
                    e = d ? l[d] : a.style_class;
                if (
                    "drawing" == a.iama ||
                    ("path_group" == a.iama && "plain" == a.type)
                )
                    ((a.stroke = is_visible_color(e.fill)
                        ? e.fill
                        : is_visible_color(e.stroke)
                          ? e.stroke
                          : "rgba(10,10,10,0.8)"),
                        (a.fill = a.stroke),
                        (a.color = e.color),
                        a.add_ons &&
                            Object.keys(a.add_ons).forEach(function (b) {
                                ((a.add_ons[b].style.fill = a.fill),
                                    (a.add_ons[b].style.stroke = a.stroke));
                            }));
                else if ("text" == a.iama)
                    (["fill", "stroke", "color", "stroke_width"].forEach(
                        function (b) {
                            a[b] = e[b];
                        },
                    ),
                        (a.font_family = e.font_family),
                        (a.font_fam_inherited = !1));
                else {
                    ([
                        "fill",
                        "stroke",
                        "color",
                        "stroke_width",
                        "font_family",
                        "padding",
                    ].forEach(function (b) {
                        a[b] = e[b];
                    }),
                        (a.text_align = e.alignment));
                    var c = infinity.get_level_of_item(a);
                    if (
                        ((a.font_size = infinity.get_font_size(
                            c,
                            e.font_class || 2,
                        )),
                        "border" == a.iama)
                    ) {
                        var f = get_text_with_border_id(a.id);
                        f.forEach(function (c) {
                            b(c, e, a.level || "L1");
                        });
                    }
                    position_texts(a.id);
                }
            }
            function c() {
                ((document.querySelector("#ffw_fill").style.display = "flex"),
                    (document.querySelector("#ffw_stroke").style.display =
                        "flex"),
                    (document.querySelector("#ffw_text").style.display =
                        "flex"),
                    (document.querySelector("#ffw_stroke2").style.display =
                        "none"));
            }
            function d(a) {
                d3.selectAll("#predef_font_sizes button.onoff-on").classed(
                    "onoff-on",
                    !1,
                );
                var b = l[a].font_class + 2;
                document
                    .querySelector(
                        "#predef_font_sizes button:nth-child(" + b + ")",
                    )
                    .classList.add("onoff-on");
            }
            function f(a) {
                d3.selectAll("#predef_text_align button.onoff-on").classed(
                    "onoff-on",
                    !1,
                );
                var b = l[a].alignment;
                b &&
                    document
                        .querySelector(".predef_text_align_" + b)
                        .classList.add("onoff-on");
            }
            function g(a) {
                var b = l[a].stroke_width;
                b &&
                    (document.querySelector(
                        "#predef_border_width input",
                    ).value = parseFloat(b));
            }
            function h(a) {
                var b = l[a].line_height;
                b &&
                    (document.querySelector(
                        "#predef_fig_line_height input",
                    ).value = parseFloat(b));
            }
            function i(a) {
                var b = l[a].font_family;
                b && (document.querySelector("#predef_font_list").value = b);
            }
            function j(a) {
                var b = l[a].padding;
                b &&
                    (document.querySelector(
                        "#predef_article_padding input",
                    ).value = b);
            }
            function k(a) {
                ((l = a),
                    Object.keys(l).forEach(function (a) {
                        (d3
                            .selectAll(".example_styles > rect.".concat(a))
                            .style("fill", l[a].fill),
                            d3
                                .selectAll(".example_styles > rect.".concat(a))
                                .style("stroke", l[a].stroke),
                            d3
                                .selectAll(".example_styles > rect.".concat(a))
                                .style(
                                    "stroke-width",
                                    l[a].stroke_width + "px",
                                ),
                            d3
                                .selectAll(".example_styles > text.".concat(a))
                                .style(
                                    "fill",
                                    "black" == l[a].color ||
                                        "rgba(0,0,0,1)" == l[a].color
                                        ? "rgba(0,0,0,0)"
                                        : l[a].color,
                                ));
                    }));
            }
            var l = {
                    style_1: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(95, 3, 255, 0.9)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_2: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(2, 92, 252, 0.9)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_0: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(255, 0, 11, 0.9)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_3: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(26, 255, 0, 0.9)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_4: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(246, 252, 5, 0.9)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_5: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(253, 0, 192, 0.9)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_6: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(171, 7, 7, 0.5)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_7: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(129, 79, 179, 0.52)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_8: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(8, 58, 150, 0.55)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_9: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(20, 160, 4, 0.52)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_10: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(214, 219, 0, 0.48)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_11: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(165, 6, 126, 0.39)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_12: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(110, 5, 9, 0.14)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_13: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(74, 5, 107, 0.14)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_14: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(5, 36, 108, 0.18)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_15: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(16, 124, 4, 0.12)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_16: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(246, 252, 5, 0.2)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_17: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(157, 5, 120, 0.13)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_18: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 3,
                        fill: "rgba(0,0,0,0)",
                        color: "rgba(207, 85, 68,1)",
                        alpha: 0,
                        stroke: "rgba(207, 85, 68, 1)",
                    },
                    style_19: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 0,
                        fill: "rgba(0,0,0,0)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_20: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(255,255,255,0.9)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_21: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(49,232,120,0.9)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_22: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(246,247,56,0.9)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_23: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(0,0,0,0.9)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                    style_24: {
                        line_height: 1.4,
                        alignment: "left",
                        font_class: 2,
                        padding: 6,
                        font_family: "Open Sans",
                        stroke_width: 1,
                        fill: "rgba(0,0,0,0.9)",
                        color: "rgba(0,0,0,1)",
                        alpha: 0.9,
                        stroke: "rgba(0,0,0,1)",
                    },
                },
                m = [48, 32, 24, 18, 12],
                n = !1;
            return (
                [
                    "predef_font1_holder",
                    "predef_font2_holder",
                    "predef_font3_holder",
                    "predef_font4_holder",
                    "predef_font5_holder",
                ].forEach(function (b, c) {
                    document.querySelector("." + b).onclick = function (b) {
                        (predef_styles.set_val_to_class(
                            active_style.style_class,
                            "font_class",
                            c,
                        ),
                            d(active_style.style_class),
                            a(!1, !0));
                    };
                }),
                (document.querySelector("#predef_font_list").onchange =
                    function (b) {
                        (predef_styles.set_val_to_class(
                            active_style.style_class,
                            "font_family",
                            this.value,
                        ),
                            a(!1, !0));
                    }),
                (document.querySelector(".predef_text_align_left").onclick =
                    function (b) {
                        (predef_styles.set_val_to_class(
                            active_style.style_class,
                            "alignment",
                            "left",
                        ),
                            f(active_style.style_class),
                            a(!1, !0));
                    }),
                (document.querySelector(".predef_text_align_right").onclick =
                    function (b) {
                        (predef_styles.set_val_to_class(
                            active_style.style_class,
                            "alignment",
                            "right",
                        ),
                            f(active_style.style_class),
                            a(!1, !0));
                    }),
                (document.querySelector(".predef_text_align_center").onclick =
                    function (b) {
                        (predef_styles.set_val_to_class(
                            active_style.style_class,
                            "alignment",
                            "center",
                        ),
                            f(active_style.style_class),
                            a(!1, !0));
                    }),
                plus_minus_generator(
                    document.getElementById("predef_fig_line_height"),
                    function (b) {
                        (predef_styles.set_val_to_class(
                            active_style.style_class,
                            "line_height",
                            parseFloat(b.value),
                        ),
                            a(!1, !0));
                    },
                    0.1,
                    2,
                ),
                plus_minus_generator(
                    document.getElementById("predef_border_width"),
                    function (b) {
                        (predef_styles.set_val_to_class(
                            active_style.style_class,
                            "stroke_width",
                            parseFloat(b.value),
                        ),
                            d3
                                .selectAll(
                                    ".example_styles > rect.".concat(
                                        active_style.style_class,
                                    ),
                                )
                                .style(
                                    "stroke-width",
                                    Math.min(parseFloat(b.value), 0.2),
                                ),
                            a());
                    },
                    0.5,
                    2,
                ),
                plus_minus_generator(
                    document.getElementById("predef_article_padding"),
                    function (b) {
                        (predef_styles.set_val_to_class(
                            active_style.style_class,
                            "padding",
                            parseFloat(b.value),
                        ),
                            a(!1, !0));
                    },
                    1,
                    1,
                ),
                {
                    change_shapes_with_class_for_predef_style_change:
                        function c(a) {
                            //let els = shapes_storage.get_all().filter(d=>d.style_class == style_class && d.iama !="text");
                            var d = shapes_storage
                                .get_all()
                                .filter(function (b) {
                                    return b.style_class == a;
                                });
                            (d.forEach(function (c) {
                                b(c, a);
                            }),
                                render_all(0, !1, !0));
                        },
                    set_font_size_of_predef: function c(a, b) {
                        -1 < a && 5 > a && (m[a] = b);
                    },
                    get_classes: function a() {
                        return l;
                    },
                    style_class_to_custom: function b(a) {
                        a.style_class = !1;
                    },
                    font_sizes: m,
                    get_font_style: function b(a) {
                        var c = "";
                        return (
                            a.font_style && (c += a.font_style + " "),
                            c + a.font_size + 'px "' + a.font_family + '"'
                        );
                    },
                    font_class_to_size: function b(a) {
                        var c =
                            1 < arguments.length && void 0 !== arguments[1]
                                ? arguments[1]
                                : "L1";
                        return m[parseInt(a.slice(-1)) - 1];
                    },
                    is_font_class: function c(a, b) {
                        var d = infinity.get_font_sizes_of_level(b);
                        return d.indexOf(a);
                    },
                    set_styles_from_class: function d(a, c) {
                        ((a.style_class = c), b(a, c));
                    },
                    set_cm_for_predef_style: function b(a) {
                        (d(a),
                            f(a),
                            g(a),
                            h(a),
                            i(a),
                            j(a),
                            c(),
                            (active_style.style_class = a),
                            (n = !0));
                    },
                    styling_predef: function a() {
                        return n;
                    },
                    set_val_to_class: function d(a, b, c) {
                        ((l[a][b] = c),
                            "fill" == b || "stroke" == b
                                ? d3
                                      .selectAll(
                                          ".example_styles > rect.".concat(
                                              active_style.style_class,
                                          ),
                                      )
                                      .style(b, c)
                                : "color" == b &&
                                  d3
                                      .selectAll(
                                          ".example_styles > text.".concat(
                                              active_style.style_class,
                                          ),
                                      )
                                      .style(b, c));
                    },
                    styling_predef_done: function a() {
                        n = !1;
                    },
                    load: k,
                }
            );
        })(),
        active_style = {
            fill: "rgba(0,0,0,0)",
            stroke: "rgba(0,0,0,0)",
            color: "rgba(0,0,0,1)",
            fill_what: "fill",
            line_flow: "fluid",
            line_style: "plain",
            stroke_width: 2,
            shape: "rect",
            style_class: "style_20",
            font_class: "font3",
            pencil_size: 2,
        };
    function get_default_border() {
        var a = ["icon_basic", "line_hor", "line_vert", "math_shape"],
            b = get_new_id(),
            d = predef_styles.get_classes()[active_style.style_class];
        return {
            x: last_pos[0],
            y: last_pos[1],
            width: 10,
            height: 4,
            color: d.color,
            stroke: d.stroke,
            stroke_width: infinity.get_border_width(
                infinity.get_level(),
                active_style.style_class,
            ),
            fill: d.fill,
            id: b,
            iama: "border",
            shape:
                -1 == a.indexOf(active_style.shape)
                    ? active_style.shape
                    : "rect",
            style_class: active_style.style_class,
            font_size: infinity.get_font_size(
                infinity.get_level(),
                d.font_class,
            ),
            font_family: d.font_family,
            num_pars: 0,
            text_align: d.alignment,
            level: infinity.get_level(),
            padding: infinity.get_standard_scaling(d.padding),
        };
    }
    function get_default_drawing(a, b) {
        var d =
                2 < arguments.length && void 0 !== arguments[2]
                    ? arguments[2]
                    : "hand",
            e = predef_styles.get_classes()[active_style.style_class],
            c = {
                width: 5,
                height: 5,
                stroke: is_visible_color(e.fill) ? e.fill : "black", //active_style.fill,
                //stroke_width: active_style.pencil_size,
                stroke_width: infinity.get_standard_scaling(
                    active_style.pencil_size,
                    infinity.get_level(),
                    2,
                ),
                flow: "lineto",
                iama: "drawing",
                level: infinity.get_level(),
                d: "",
                type: d,
            };
        return (
            "rgba(0,0,0,0)" == c.stroke && (c.stroke = "rgba(10,10,10,0.7)"),
            isNaN(a) ||
                isNaN(b) ||
                "hand" != d ||
                ((c.points = []),
                (c.d = "M" + [a, b]),
                c.points.push([[a, b]])),
            c
        );
    }
    function get_default_knot(a, b) {
        //word nooit getekend / gerenderd!!!
        return {
            id: get_new_id(),
            x: a,
            y: b,
            iama: "knot",
            width: 5,
            height: 5,
        };
    }
    function get_default_textpart_for_par(a) {
        var b =
            1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : "";
        return 0 == a.parts.length
            ? {
                  text: b,
                  x: a.x,
                  y: a.y,
                  width: 2,
                  height: a.height,
                  border_id: a.border_id,
                  iama: "text",
                  parent: a,
                  num: 0,
                  line_num: 0,
              }
            : ((last = a.parts[a.parts.length - 1]),
              {
                  text: b,
                  x: last.x + last.w,
                  y: last.y,
                  width: 2,
                  height: a.height,
                  border_id: a.border_id,
                  iama: "text",
                  parent: a,
                  num: last.num,
                  line_num: 0,
              });
    }
    function get_default_text(a, b) {
        var c = get_text_style_from_border(a),
            d = c.font_size,
            e = c.color,
            f = c.font_family,
            g =
                a.style_class in predef_styles.get_classes()
                    ? predef_styles.get_classes()[a.style_class].line_height
                    : 1.2;
        b && (d = b);
        var h = {
            x: parseInt(a.x + d * g),
            y: parseInt(a.y),
            has_own_style: !1,
            stroke: !1, // "rgba(0,0,0,0)",//active_style.stroke,
            stroke_width: !1, //0, //active_style.stroke_width,
            fill: !1, //"rgba(0,0,0,0)", //active_style.fill,
            border_id: a.id,
            text: "",
            line_height: g,
            margin: 0,
            iama: "text",
            chunk_num: 0,
            par_num: 0,
            font_family: f,
            font_size: d,
            color: e,
            font_fam_inherited: !0,
            font_size_inherited: !0,
            parts: [],
            width: MIN_PAR_WIDTH,
            height: parseInt(d) * g,
        };
        return ("flipped" in a && (h.flipped = a.flipped), h);
    }
    function get_default_icon(a, b) {
        var d = fa_handler.get_selected_icon(),
            e = predef_styles.get_classes()[active_style.style_class],
            c = infinity.get_level(),
            f = infinity.get_font_size(c, 0);
        return {
            x: a,
            y: b,
            icon: d,
            stroke: e.stroke,
            stroke_width: 0.5,
            fill: is_visible_color(e.fill) ? e.fill : "rgba(10,10,10,0.8)",
            iama: "fa_icon",
            shape: "icon", //toegevoegd zodat helptext makkelijk wordt getoond
            font_size: f,
            width: f,
            height: f,
            level: c,
        };
    }
    function is_visible_color(a) {
        return ((t = tinycolor(a)), 0 != t.getAlpha() && "ffffff" != t.toHex());
    }
    function get_text_style_from_border(a) {
        var b =
            a.color ||
            (a.style_class
                ? predef_styles.get_classes()[a.style_class].color
                : "black");
        if (a.font_class)
            var c = predef_styles.font_class_to_size(a.font_class, a.level);
        else var c = a.font_size || 12;
        var d = a.font_family;
        return {
            font_size: c,
            color: b,
            font_family: d, //fill, stroke?
        };
    }
    function plus_minus_generator(a, b, c) {
        var d =
            3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : 2;
        c = c || 1;
        var e = a.querySelector(".plus"),
            f = a.querySelector(".minus"),
            g = a.querySelector("input");
        ((e.onmousedown = function () {
            var a = parseFloat(g.value);
            ((g.value = round_to(a + c, d)), b(g));
        }),
            (f.onmousedown = function () {
                var a = parseFloat(g.value);
                ((g.value = round_to(a - c, d)), b(g));
            }),
            (g.onchange = function () {
                b(g);
            }));
    }
    var style_copier = (function () {
        function a(a) {
            var b = currentElement.iama;
            return b in figs && "copyable" in figs[b] && !figs[b].copyable
                ? (text_to_feedback_pane("cannot style copy a ".concat(b)),
                  (i = !1),
                  !1)
                : void ((i = !0),
                  (j =
                      "parent" in currentElement
                          ? currentElement.parent
                          : currentElement));
        }
        function b(a) {
            (manage_groups.get_group(a, !0).forEach(function (a) {
                var b = a.iama;
                if ("path_group" == b) (g(a), path.remake_path(a));
                else if ("math_shape" == b) d(a);
                else if ("text" == b) {
                    var h = part_to_chunk(a);
                    (e(h),
                        measure_text(h),
                        recalc_border_width(h.border_id),
                        recalc_border_height(h.border_id, !0),
                        position_texts(h.border_id));
                } else {
                    f(a);
                    for (
                        var c = get_chunks_by_par(j.id),
                            i = get_chunks_by_par(a.id),
                            k = function b(a) {
                                c[a] &&
                                    i[a].forEach(function (b) {
                                        if (b.chunk_num < c[a].length) {
                                            var d = c[a][b.chunk_num];
                                            (e(b, d), measure_text(b));
                                        }
                                    });
                            },
                            l = 0;
                        l < a.num_pars;
                        l++
                    )
                        k(l);
                    0 != a.num_pars &&
                        (recalc_border_width(a.id),
                        recalc_border_height(a.id, !0),
                        position_texts(a.id));
                }
            }),
                (i = !1),
                (j = !1),
                set_current_element(a));
        }
        function c(a, b) {
            var c =
                !!(2 < arguments.length && arguments[2] !== void 0) &&
                arguments[2];
            (c || (c = j),
                b.forEach(function (b) {
                    b in c && (a[b] = c[b]);
                }));
        }
        function d(a) {
            c(a, ["fill", "stroke", "stroke_width"]);
        }
        function e(a) {
            var b =
                !!(1 < arguments.length && arguments[1] !== void 0) &&
                arguments[1];
            c(
                part_to_chunk(a),
                [
                    "has_own_style",
                    "color",
                    "fill",
                    "font_fam_inherited",
                    "font_family",
                    "font_size_inherited",
                    "font_size",
                    "line_height",
                    "margin",
                    "stroke",
                    "stroke_width",
                ],
                b,
            );
        }
        function f(a) {
            c(a, [
                "color",
                "fill",
                "font_family",
                "font_size",
                "padding",
                "stroke",
                "stroke_width",
                "style_class",
                "text_align",
                "stroke_dasharray",
                "border_sides_arr",
            ]);
        }
        function g(a) {
            //'flow','type'
            c(a, [
                "inner_width",
                "outer_width",
                "fill",
                "stroke",
                "dasharray_inner",
                "dasharray_outer",
            ]);
        }
        function h() {
            ((i = !1), (j = !1));
        }
        var i = !1,
            j = !1;
        return {
            setup_style_copy: a,
            is_on: function a() {
                return i;
            },
            copy_styles_to_shape: b,
            cancel: h,
        };
    })();
    function copy_element_new(a, b) {
        function c(a) {
            return JSON.parse(JSON.stringify(a));
        }
        var d =
                !(2 < arguments.length && void 0 !== arguments[2]) ||
                arguments[2],
            e = get_new_id(),
            f = c(a);
        f.id = e;
        var g = [];
        if (
            d &&
            "id" in a &&
            ((g = get_text_with_border_id(a.id)), 0 < g.length)
        ) {
            g.forEach(function (a) {
                return delete a.parts;
            });
            var g = g.map(function (a) {
                return c(a);
            });
            (g.forEach(function (a) {
                return (a.border_id = e);
            }),
                g.forEach(function (a) {
                    return shapes_storage.add_text(a);
                }));
        }
        return (
            shapes_storage.add_shape(f),
            reposition_protocol(f, b[0] - a.x, b[1] - a.y),
            d && 0 < g.length && (position_texts(a.id), position_texts(f.id)),
            f
        );
    }
    function correct_chunk_style_attributes_if_no_own_style() {
        var a = _.flatten(Object.values(shapes_storage.texts));
        a.forEach(function (a) {
            ("has_own_style" in a && a.has_own_style) ||
                ((a.fill = !1), (a.stroke = !1), (a.stroke_width = !1));
        });
    }
    function correct_chunk_own_style_of_no_styles() {
        var a = _.flatten(Object.values(shapes_storage.texts));
        a.forEach(function (a) {
            a.fill || a.stroke || a.stroke_width || (a.has_own_style = !1);
        });
    } //TODO1 cursor style wordt na einde style copy niet direct aangepast.
    //TODO2 geen path reset knop in contextmenu als end point niet op shape ligt.
    //TODO center on shape: map verplaatsen zodat huidige figuur in midden bij huidige zoomniveau
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function change_path_end_fig(a) {
        var b =
            !(1 < arguments.length && arguments[1] !== void 0) || arguments[1];
        "path_group" == currentElement.iama
            ? manage_groups.get_group(currentElement, !0).forEach(
                  function (c) {
                      (set_current_element(c),
                          path.set_path_attrs(c),
                          (cpa.arrow_width = infinity.get_standard_scaling(
                              10,
                              cpa.level || "L1",
                          )),
                          (cpa.arrow_height = infinity.get_standard_scaling(
                              17,
                              cpa.level || "L1",
                          )),
                          (cpa["arrow_" + a] = !!b && path_end_fig),
                          change_arrow("arrow_" + a));
                  }.bind(this),
              )
            : "drawing" == currentElement.iama;
    }
    function change_arrow(a) {
        cpa[a] || ((cpa[a] = !1), delete cpa.path_g.add_ons[a.split("_")[1]]);
        path.remake_path(!0);
    }
    var OVERLAP = 0.95;
    function path_correction_for_arrow(a, b) {
        //returns new d-string vor path, adjusts c_to_c
        //gedaan omdat anders arrow punt als lijn heel dik is geen punt meer is...
        var c = document.createElementNS("http://www.w3.org/2000/svg", "path"); //parseFloat(currentElement.querySelector('.mainpath').style['stroke-width'])
        if ((c.setAttribute("d", a[0]), (c_to_c = a[1]), b))
            ((d = c.getTotalLength()), (d -= cpa.arrow_height * OVERLAP + 0));
        else var d = cpa.arrow_height * OVERLAP + 0;
        var e = c.getPointAtLength(d);
        return (
            (original_point = c_to_c.midpoints[b].slice()),
            (c_to_c.midpoints[b] = [e.x, e.y]),
            (cpa.arrow_height += 0),
            [make_d(c_to_c, 1 - OVERLAP), original_point]
        );
    }
    function calc_arrow_angle(a, b) {
        //returns angle in degrees to rotate clockwise
        //arrow pointing left moet 0 zijn
        if (a[0] == b[0] && a[1] == b[1]) return 0; //if (!side){
        ((dx = a[0] - b[0]), (dy = a[1] - b[1])); // 	dxa = Math.abs(dx)
        // 	dya = Math.abs(dy)
        // 	if (dx >0 && dxa > dya) {
        // 		side = 3
        // 	}else if(dx < 0 & dxa <dya){
        // 		side = 1
        // 	}else if(dy>0){
        // 		side = 0
        // 	}else{
        // 		side = 2
        // 	}
        // }
        var c = 360 / (2 * Math.PI),
            d = Math.atan(dx / dy),
            e = c * d,
            f = 0; // if (side%2==0){
        // 	var y = line_end[1] - arrow_end[1];
        // 	var x = line_end[0] - arrow_end[0];
        // }else{
        // 	var x = -(arrow_end[1] - line_end[1]);
        // 	var y = arrow_end[0] - line_end[0];
        // }
        //let temp =  Math.atan(x/y) * -(360/(Math.PI*2) )+ 90 * side - 90;
        //console.log(res );
        return (
            (f =
                0 <= dx && 0 <= dy
                    ? -1 * (e - 90) + 180
                    : 0 <= dx && 0 > dy
                      ? 90 - e
                      : 0 > dx && 0 > dy
                        ? -1 * (e - 90)
                        : 270 - e),
            f
        );
    }
    function add_arrow_test(a, b) {
        var c =
                2 < arguments.length && arguments[2] !== void 0
                    ? arguments[2]
                    : "arrow",
            d =
                3 < arguments.length && arguments[3] !== void 0
                    ? arguments[3]
                    : 10,
            e =
                4 < arguments.length && arguments[4] !== void 0
                    ? arguments[4]
                    : 17,
            f = path_to_array(a.d),
            g = "head" == b ? 1 : 0,
            h = 0,
            i = 1;
        0 != g && ((h = f.length - 1), (i = h - 1));
        var j = [f[h].x + a.x, f[h].y + a.y],
            k = [f[i].x + a.x, f[i].y + a.y],
            l = k[0] - j[0],
            o = k[1] - j[1]; //waar het pad zou eindigen zonder arrow
        k = [j[0] + 0.1 * l, j[1] + 0.1 * o];
        var p = [calc_arrow_angle(j, k), j[0], j[1]],
            q = path_end_figs[c].func(d, e, [0, 0]),
            r = calc_bbox_for_arrow.apply(void 0, p.concat([d, e])); //let figure = 'arrow'
        ("add_ons" in a || (a.add_ons = {}),
            (a.add_ons[b] = {
                style: { stroke: "black", stroke_width: 2, fill: "black" },
                specs: q,
                end: g,
                figure: c,
                rotation: p,
                parent_id: a.id,
                side: b,
                bbox: r,
                x: j[0] - d / 2,
                y: j[1] - e / 2,
                width: d,
                height: e,
                iama: "path_addon",
            }));
    }
    function add_shape_to_line_end(a, b, c) {
        //head=1, tail=0
        var d = 1 == b ? a.j : a.i,
            e = b
                ? a.original_point_head || a.midpoints[1]
                : a.original_point_tail || a.midpoints[0],
            f = path_end_figs[c].func(
                cpa.arrow_width,
                cpa.arrow_height,
                [0, 0],
            ),
            g = [calc_arrow_angle(e, a.midpoints[b], d), e[0], e[1]],
            h = get_styles_for_add_on(
                cpa.path_g.add_ons[1 == b ? "head" : "tail"],
            ),
            i = calc_bbox_for_arrow.apply(
                void 0,
                g.concat([cpa.arrow_width, cpa.arrow_height]),
            ); //0 rotation is arrow die naar links wijst, in graden met de klok mee: 90 graden pijl die naar boven wijst
        return {
            style: h,
            specs: f,
            end: b,
            figure: c,
            rotation: g,
            parent_id: cpa.path_g.id,
            bbox: i,
            x: e[0] - cpa.arrow_width / 2,
            y: e[1] - cpa.arrow_height / 2,
            width: cpa.arrow_width,
            height: cpa.arrow_height,
            iama: "path_addon",
        };
    }
    function calc_bbox_for_arrow(a, b, c, d, e) {
        //rad: rotati0n in radians
        //x, y center of rotation
        var f = -a / (180 / Math.PI),
            g = rotate_point(f, e, d / 2),
            h = _slicedToArray(g, 2),
            i = h[0],
            j = h[1],
            k = rotate_point(f, e, -d / 2),
            l = _slicedToArray(k, 2),
            m = l[0],
            n = l[1],
            o = get_minxy_maxxy_of_array([
                [0, 0],
                [i, j],
                [m, n],
            ]),
            p = _slicedToArray(o, 4),
            q = p[0],
            r = p[1],
            s = p[2],
            t = p[3];
        return { x: q + b, y: r + c, width: s - q, height: t - r };
    }
    function get_styles_for_add_on(a) {
        if (a && "style" in a) var b = a.style;
        else var b = { inherited: !0 };
        return (
            b.inherited &&
                ("double" == cpa.type
                    ? ((b.stroke_width = cpa.path_g.outer_width),
                      (b.stroke = cpa.path_g.stroke),
                      (b.fill = cpa.path_g.fill))
                    : ((b.stroke_width = cpa.path_g.inner_width),
                      (b.stroke = cpa.path_g.fill),
                      (b.fill = cpa.path_g.fill))),
            b
        );
    }
    var path_end_figs = {
        arrow: {
            filled: !0,
            fig: "polygon",
            attr: "points",
            style: "stroke-width:1px;fill:black;stroke:black;",
            func: make_arrow_head, //ex: make_arrow_head(10,17, [0,12])
        },
        curved_arrow: {
            fig: "path",
            attr: "d",
            style: "stroke-width:3px;stroke:black;",
            func: make_curved_arrow_head,
        },
        rev_arrow: {
            filled: !0,
            fig: "polygon",
            attr: "points",
            style: "stroke-width:1px;fill:black;stroke:black;",
            func: make_arrow_head_rev, //ex: make_arrow_head(10,17, [0,12])
        }, //    'tripod_zero': {
        //     fig: 'polyline',
        //     attr: 'points',
        //     style: 'stroke-width:1px;fill:none;',
        //     func: make_tripod,
        //     //ex: make_tripod(10,17,[0,12])
        // },
        // 'tripod_one':{
        //     fig: 'polyline',
        //     attr: 'points',
        //     style: 'stroke-width:1px;fill:none;;stroke:black;',
        //     func: make_tripod_one,
        //     //ex: make_tripod_one(10,17,[0,12])
        // },
        // 'tripod_zero':{
        //     fig: 'polyline',
        //     attr: 'points',
        //     style: 'stroke-width:1px;fill:none;;stroke:black;',
        //     func: make_zero_tripod,
        //     //ex: make_tripod_one(10,17,[0,12])
        // },
        // 'only_one':{
        //     fig: 'path',
        //     attr: 'd',
        //     style: 'stroke-width:1px;fill:none;;stroke:black;',
        //     func: make_one_only_one,
        //     //ex: make_one_only_one(10,17,[0,12])
        // },
        // 'zero_one':{
        //     fig: 'path',
        //     attr: 'd',
        //     style: 'stroke-width:1px;fill:none;;stroke:black;',
        //     func: make_zero_one,
        //     //ex: make_one_only_one(10,17,[0,12])
        // },
    };
    function make_zero_one(a, b, c, d) {
        var e = _slicedToArray(d, 2),
            f = e[0],
            g = e[1],
            h = a.select("path");
        return (
            h.empty() && (h = a.append("path")),
            h.attr("d", [
                "M " +
                    f +
                    " " +
                    g +
                    " L " +
                    (f + c) +
                    " " +
                    g +
                    " M " +
                    (f + c / 2) +
                    " " +
                    (g - b / 2) +
                    " L " +
                    (f + c / 2) +
                    " " +
                    (g + b / 2), //' M ' + (x+w)  + ' ' +  (y - h/2)  +   ' L'+ ' '+  (x+w)  + ' ' + (y+h/2)
            ]),
            add_circle(a, b, c, d)
        );
    }
    function add_circle(a, b, c, d) {
        var e = a.select("circle");
        return (
            e.empty() && (e = a.append("circle")),
            e
                .attr("r", 4)
                .attr("cx", d[0] + c)
                .attr("cy", d[1])
                .style("fill", "white"),
            a
        );
    }
    function make_zero_tripod(a, b, c, d) {
        var a = make_tripod(a, b, c, d);
        return add_circle(a, b, c, d);
    }
    function make_one_only_one(a, b, c, d) {
        var e = _slicedToArray(d, 2),
            f = e[0],
            g = e[1];
        return {
            fig: "path",
            d:
                "M " +
                f +
                " " +
                g +
                " L " +
                (f + c) +
                " " +
                g +
                " M " +
                (f + c / 2) +
                " " +
                (g - b / 2) +
                " L " +
                (f + c / 2) +
                " " +
                (g + b / 2) +
                " M " +
                (f + c) +
                " " +
                (g - b / 2) +
                " L " +
                (f + c) +
                " " +
                (g + b / 2),
        };
    }
    function make_tripod_one(a, b, c) {
        var d = _slicedToArray(c, 2),
            e = d[0],
            f = d[1];
        return {
            fig: "poly",
            points: [
                e,
                f + a / 2,
                e + b,
                f,
                e,
                f,
                e + b,
                f,
                e,
                f - a / 2,
                e + b,
                f,
                e + b,
                f - a / 2,
                e + b,
                f + a / 2,
            ],
        };
    }
    function make_tripod(a, b, c) {
        var d = _slicedToArray(c, 2),
            e = d[0],
            f = d[1];
        return { fig: "poly", points: ps };
    }
    function make_arrow_head(a, b) {
        var c =
                2 < arguments.length && void 0 !== arguments[2]
                    ? arguments[2]
                    : [0, 0],
            d = []; //arrow_pos = [0,0]
        return (
            d.push(c),
            d.push([c[0] + b, c[1] + a / 2]),
            d.push([c[0] + b, c[1] - a / 2]),
            { points: d, fig: "poly" }
        );
    }
    function make_arrow_head_rev(a, b, c) {
        var d = [
            [c[0] + b, c[1]],
            [c[0], c[1] + a / 2],
            [c[0], c[1] - a / 2],
        ]; //arrow_pos = [0,0]
        return { points: d, fig: "poly" };
    }
    function make_curved_arrow_head(a, b, c) {
        var e = "M " + (c[0] + b) + ", " + (c[1] - a / 2);
        return (
            (e += " C " + (c[0] - 0.33 * b) + ", " + (c[1] + a / 2)),
            (e += " " + (c[0] - 0.33 * b) + ", " + (c[1] - a / 2)),
            (e += " " + (c[0] + b) + ", " + (c[1] + a / 2)),
            { d: e, fig: "path" }
        );
    }
    (plus_minus_generator(
        document.getElementById("form_add_on_height"),
        change_arrow_size,
        5,
        1,
    ),
        plus_minus_generator(
            document.getElementById("form_add_on_width"),
            change_arrow_size,
            5,
            1,
        ),
        plus_minus_generator(
            document.getElementById("cm_add_on_height"),
            change_arrow_size,
            5,
            1,
        ),
        plus_minus_generator(
            document.getElementById("cm_add_on_width"),
            change_arrow_size,
            5,
            1,
        )); //$('#form_add_on_width, #form_add_on_height').on('input',
    function change_arrow_size(a) {
        function b(a) {
            if (
                "path_group" == a.iama ||
                "path_basic" == a.iama ||
                "drawing" == a.iama
            ) {
                var b = Object.keys(a.add_ons);
                return a.add_ons[b[0]];
            }
            return a;
        }
        var c = a.name,
            d = parseInt(a.value),
            e = b(currentElement);
        if (!e.parent_id) {
            var f = shapes_storage.find_parent_of_drawing_add_on(e),
                g = "width" == c ? d : e.width,
                i = "height" == c ? d : e.height;
            return (
                add_arrow_test(f, e.side, e.figure, g, i),
                set_current_element(
                    1 == e.end ? f.add_ons.head : f.add_ons.tail,
                ),
                !1
            );
        }
        (manage_groups.get_group(currentElement, !0).forEach(function (a) {
            if (((a = b(a)), a)) {
                (path.clear_path_attrs(),
                    path.set_path_attrs(find_path_by_id(a.parent_id)),
                    (cpa["arrow_" + c] = d));
                path.remake_path(!0);
            }
        }),
            render());
    }
    ("use strict");
    function _typeof(a) {
        "@babel/helpers - typeof";
        return (
            (_typeof =
                "function" == typeof Symbol &&
                "symbol" == typeof Symbol.iterator
                    ? function (a) {
                          return typeof a;
                      }
                    : function (a) {
                          return a &&
                              "function" == typeof Symbol &&
                              a.constructor === Symbol &&
                              a !== Symbol.prototype
                              ? "symbol"
                              : typeof a;
                      }),
            _typeof(a)
        );
    }
    function _toConsumableArray(a) {
        return (
            _arrayWithoutHoles(a) ||
            _iterableToArray(a) ||
            _unsupportedIterableToArray(a) ||
            _nonIterableSpread()
        );
    }
    function _nonIterableSpread() {
        throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _iterableToArray(a) {
        if (
            ("undefined" != typeof Symbol && null != a[Symbol.iterator]) ||
            null != a["@@iterator"]
        )
            return Array.from(a);
    }
    function _arrayWithoutHoles(a) {
        if (Array.isArray(a)) return _arrayLikeToArray(a);
    }
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function _defineProperty(a, b, c) {
        return (
            (b = _toPropertyKey(b)) in a
                ? Object.defineProperty(a, b, {
                      value: c,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                  })
                : (a[b] = c),
            a
        );
    }
    function _toPropertyKey(a) {
        var b = _toPrimitive(a, "string");
        return "symbol" == _typeof(b) ? b : b + "";
    }
    function _toPrimitive(a, b) {
        if ("object" != _typeof(a) || !a) return a;
        var c = a[Symbol.toPrimitive];
        if (void 0 !== c) {
            var d = c.call(a, b || "default");
            if ("object" != _typeof(d)) return d;
            throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === b ? String : Number)(a);
    }
    function close_other_fieldsets() {
        //var fs = document.querySelectorAll('#edit_mode_menu fieldset:not(#fs_shapes):not(#fs_styles):not(.collapsed)');
        var a = document.querySelectorAll(
            "#edit_mode_menu fieldset:not(.collapsed):not(#fs_help):not(#fs_study_mode)",
        );
        _.forEach(a, function (a) {
            return toggle_field_set(a);
        });
        var b = document.querySelectorAll(
            "#slides_menu fieldset:not(.collapsed):not(#fs_help_slides)",
        );
        _.forEach(b, function (a) {
            return toggle_field_set(a);
        });
    }
    function toggle_field_set(a) {
        var b = a.querySelector(".fs_toggle");
        return (
            !!b &&
            void ((b.style.display = "" == b.style.display ? "none" : null),
            a.querySelector("legend").classList.toggle("collapsed"),
            a.classList.toggle("collapsed"))
        );
    }
    function close_fieldset(a) {
        var b = a.querySelector(".fs_toggle");
        ((b.style.display = "none"),
            a.querySelector("legend").classList.add("collapsed"),
            a.classList.add("collapsed"));
    }
    for (
        var fsa = document.querySelectorAll(".toolbar1 legend"), i = 0;
        i < fsa.length;
        i++
    )
        fsa[i].onclick = function () {
            (this.parentElement.classList.contains("collapsed") &&
                (close_other_fieldsets(),
                !form_filled && currentElement && fill_forms(currentElement)),
                "fs_help" == this.parentElement.id && (help_on = !help_on),
                toggle_field_set(this.parentElement));
        };
    for (
        var fieldsets = document.querySelectorAll("fieldset"), k = 0;
        k < fieldsets.length;
        k++
    )
        for (
            var h,
                menu = fieldsets[k],
                headers = menu.querySelectorAll(".submenus h4"),
                _i = 0;
            _i < headers.length;
            _i++
        )
            ((h = headers[_i]), (h.onclick = change_submenu));
    function change_submenu(a) {
        for (
            var b, c = a.target.parentElement.querySelectorAll("h4"), d = 0;
            d < c.length;
            d++
        )
            (c[d].classList.remove("active"), c[d] == a.target && (b = d));
        a.target.classList.add("active");
        for (
            var e = direct_child_only_selector(
                    a.target.parentElement.parentElement,
                    ".sub",
                ),
                f = 0;
            f < e.length;
            f++
        )
            e[f].style.display = "none";
        e[b].style.display = "block";
    }
    function direct_child_only_selector(a, b) {
        var c = Array.from(a.querySelectorAll(b));
        return c.filter(function (b) {
            return b.parentElement == a;
        });
    }
    var colorpicker = $("#colorpicker").spectrum({
        showAlpha: !0,
        color: "#ECC",
        showInput: !0,
        className: "full-spectrum",
        showInitial: !0,
        showPalette: !0,
        showSelectionPalette: !0,
        maxSelectionSize: 10, //preferredFormat: "hex",
        localStorageKey: "spectrum.demo",
        move: function (a) {
            if (
                (0 == a._a &&
                    text_to_feedback_pane(
                        "warning: alpha is set to zero (see bar below the color)",
                    ),
                "stroke" == active_style.fill_what
                    ? (active_style.stroke = a.toRgbString())
                    : "text" == active_style.fill_what
                      ? (active_style.color = a.toRgbString())
                      : (active_style.fill = a.toRgbString()),
                canvas_status.draw_mode)
            )
                return (start_new_draw_group(), !1);
            if ("canvas" == currentElement.iama)
                return (
                    (grid_canvas.node().style.backgroundColor =
                        a.toRgbString()),
                    !1
                );
            if (predef_styles.styling_predef()) {
                var b =
                    "fill" == active_style.fill_what
                        ? "fill"
                        : "text" == active_style.fill_what
                          ? "color"
                          : "stroke";
                return (
                    predef_styles.set_val_to_class(
                        active_style.style_class,
                        b,
                        a.toRgbString(),
                    ),
                    "fill" == active_style.fill_what &&
                        (el.style.fill = a.toRgbString()),
                    predef_styles.change_shapes_with_class_for_predef_style_change(
                        active_style.style_class,
                        _defineProperty({}, b, !0),
                    ),
                    !1
                );
            }
            (manage_groups.get_group(currentElement).forEach(function (a) {
                if (a) {
                    if ("path_addon" == a.iama) {
                        a.has_own_style = !0;
                        var b = a.style;
                    } else if ("text" == a.iama) {
                        var b = part_to_chunk(a);
                        b.has_own_style = !0;
                    } else {
                        a.style_class = !1;
                        var b = a;
                    }
                    "stroke" == active_style.fill_what
                        ? (b.stroke = active_style.stroke)
                        : "text" == active_style.fill_what
                          ? ((b.color = active_style.color),
                            "border" == b.iama &&
                                change_text_color_of_chunks(
                                    b.id,
                                    active_style.color,
                                ))
                          : (b.fill = active_style.fill);
                }
            }),
                set_current_element(currentElement, !0));
        },
        show: function () {
            set_color_picker(currentElement);
        },
        beforeShow: function () {},
        hide: function () {
            predef_styles.styling_predef_done();
        },
        change: function () {},
        palette: [
            [
                "rgb(0, 0, 0)",
                "rgb(67, 67, 67)",
                "rgb(102, 102, 102)",
                "rgb(204, 204, 204)",
                "rgb(217, 217, 217)",
                "rgb(255, 255, 255)",
            ],
            [
                "rgb(152, 0, 0)",
                "rgb(255, 0, 0)",
                "rgb(255, 153, 0)",
                "rgb(255, 255, 0)",
                "rgb(0, 255, 0)",
                "rgb(0, 255, 255)",
                "rgb(74, 134, 232)",
                "rgb(0, 0, 255)",
                "rgb(153, 0, 255)",
                "rgb(255, 0, 255)",
            ],
            [
                "rgb(230, 184, 175)",
                "rgb(244, 204, 204)",
                "rgb(252, 229, 205)",
                "rgb(255, 242, 204)",
                "rgb(217, 234, 211)",
                "rgb(208, 224, 227)",
                "rgb(201, 218, 248)",
                "rgb(207, 226, 243)",
                "rgb(217, 210, 233)",
                "rgb(234, 209, 220)",
                "rgb(221, 126, 107)",
                "rgb(234, 153, 153)",
                "rgb(249, 203, 156)",
                "rgb(255, 229, 153)",
                "rgb(182, 215, 168)",
                "rgb(162, 196, 201)",
                "rgb(164, 194, 244)",
                "rgb(159, 197, 232)",
                "rgb(180, 167, 214)",
                "rgb(213, 166, 189)",
                "rgb(204, 65, 37)",
                "rgb(224, 102, 102)",
                "rgb(246, 178, 107)",
                "rgb(255, 217, 102)",
                "rgb(147, 196, 125)",
                "rgb(118, 165, 175)",
                "rgb(109, 158, 235)",
                "rgb(111, 168, 220)",
                "rgb(142, 124, 195)",
                "rgb(194, 123, 160)",
                "rgb(166, 28, 0)",
                "rgb(204, 0, 0)",
                "rgb(230, 145, 56)",
                "rgb(241, 194, 50)",
                "rgb(106, 168, 79)",
                "rgb(69, 129, 142)",
                "rgb(60, 120, 216)",
                "rgb(61, 133, 198)",
                "rgb(103, 78, 167)",
                "rgb(166, 77, 121)",
                "rgb(91, 15, 0)",
                "rgb(102, 0, 0)",
                "rgb(120, 63, 4)",
                "rgb(127, 96, 0)",
                "rgb(39, 78, 19)",
                "rgb(12, 52, 61)",
                "rgb(28, 69, 135)",
                "rgb(7, 55, 99)",
                "rgb(32, 18, 77)",
                "rgb(76, 17, 48)",
            ],
        ],
    }); //verhuizen naar zelfde plek als waar font fam en font size wordt aangepast
    function change_text_color_of_chunks(a, b) {
        var c = get_text_with_border_id(a);
        (c.forEach(function (a) {
            a.has_own_style || (a.color = b);
        }),
            position_texts(a));
    }
    var r1 = 20,
        r2 = 150,
        r3 = 280,
        r4 = 410,
        r5 = 540,
        r6 = 670,
        r7 = 800,
        c1 = 20,
        c2 = 140,
        c3 = 260,
        c4 = 380,
        c5 = 520,
        c6 = 600;
    fig_to_pos = {
        rect: [[c1, 20], 1],
        rhombus: [[c2, 20], 1],
        diamond: [[c3, 20], 1],
        octagon: [[c4, 20], 1], //ellipse_basic:[[635,75],1],
        triangle_l: [[c1, 150], 1],
        triangle_r: [[c2, 150], 1],
        triangle_u: [[c3, 150], 1],
        triangle_d: [[c4, 150], 1],
        hexagon_h: [[c5, 150], 1],
        arrow_up: [[c1, 280], 1],
        arrow_down: [[c2, 280], 1],
        arrow_right: [[c3, 280], 1],
        arrow_left: [[c4, 280], 1],
        hexagon_v: [[c5, 280], 1],
        chevron_right: [[c1, 410], 1],
        chevron_left: [[c2, 410], 1],
        chevron_up: [[c3, 410], 1],
        chevron_down: [[c4, 410], 1],
        house_up: [[c1, 540], 1],
        house_down: [[c2, 540], 1],
        house_left: [[c3, 540], 1],
        house_right: [[c4, 540], 1],
        parallello_hor: [[c1, 670], 1],
        parallello_hor_mirrored: [[c2, 670], 1],
        parallello_vert: [[c3, 670], 1],
        parallello_vert_mirrored: [[c4, 670], 1], //axes_board: [[c5+135, r5+150] ,0.30],
        //graph_basic: [[c5+65, r6+80] ,0.45],
        //text_basic:[[c1-65, r7],2], icon_basic: [[c3-125,r7-50],3.5],
        //rect_canvas: [[c4+100, r7+40],1],
    };
    function fill_example_figs() {
        function a(a, c, f) {
            for (
                var j = _.keys(a),
                    k = function d() {
                        var e = j[l],
                            i = poly_config[e].points,
                            k = poly_config[e].dims.width,
                            m = poly_config[e].dims.height;
                        i = i.map(function (a) {
                            var b = _slicedToArray(a, 2),
                                c = b[0],
                                d = b[1];
                            return [k * c, m * d];
                        });
                        var h = b.append("g"); //g.style('fill', 'white');
                        (h.append("polygon").attr("points", i),
                            h.attr("width", k),
                            h.attr("height", m),
                            h.style("stroke-width", "4px"),
                            h.style("stroke", "#CF5544"),
                            h.classed(c, !0),
                            h.attr(
                                "transform",
                                "translate(" +
                                    fig_to_pos[e][0] +
                                    ") scale(" +
                                    a[j[l]][1] +
                                    ")",
                            ),
                            h.on(
                                "click",
                                (function (a, b) {
                                    return function () {
                                        f(a, b, 0, 0);
                                    };
                                })(j[l], h.node()),
                            ));
                    },
                    l = 0;
                l < j.length;
                l++
            )
                k();
        }
        var b = d3
            .select("body")
            .select("#shapes_svg")
            .append("g")
            .attr("id", "example_fig")
            .attr("transform", "scale(0.275)");
        (a(fig_to_pos, "example_fig", select_shape),
            (c = b
                .append("g")
                .attr(
                    "transform",
                    "translate(".concat(c5 + 10, ",").concat(660, ") scale(2)"),
                )
                .attr("i_am_a", "icon_basic")
                .attr("width", 50)
                .attr("height", 50)),
            c
                .append("rect")
                .attr("x", -5)
                .attr("width", 50)
                .attr("height", 65)
                .attr("class", "example_fig")
                .on("click", function () {
                    select_shape("icon_basic", this);
                })
                .on("dblclick", function () {
                    open_modal("icon_modal");
                }),
            c
                .append("text")
                .text("\uF252")
                .attr("transform", "translate(0,50)")
                .style("font-size", "48px")
                .style("font-family", '"Font Awesome 5 Free"')
                .style("font-weight", 900)
                .style("fill", "#CF5544")
                .style("pointer-events", "none"),
            b
                .append("g")
                .attr(
                    "transform",
                    "translate(".concat(c5 + 45, ",").concat(65, ") scale(1)"),
                )
                .attr("i_am_a", "ellipse")
                .attr("class", "example_fig")
                .attr("width", 90)
                .attr("height", 60)
                .on("click", function () {
                    select_shape("ellipse", this, -45, -30);
                })
                .style("stroke-width", "4px")
                .style("stroke", "#CF5544") //.style('fill', 'white')
                .append("ellipse")
                .attr("rx", 45)
                .attr("ry", 30)); //.attr('transform', 'translate(0,50)')
        var c = b
            .append("g")
            .attr(
                "transform",
                "translate(".concat(c5, ",").concat(r4, ") scale(1)"),
            )
            .attr("width", 30)
            .attr("height", 100);
        (c
            .append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", 100)
            .attr("height", 100)
            .attr("class", "example_fig")
            .style("stroke", "rgba(0,0,0,0") //.style('fill', 'rgba(0,0,0,0)')
            .style("pointer-events", "visible")
            .on("click", function () {
                select_shape("line_hor", this);
            }),
            c
                .append("line")
                .attr("x1", 0)
                .attr("y1", 50)
                .attr("x2", 100)
                .attr("y2", 50)
                .style("stroke-width", "10px")
                .style("stroke", "#CF5544")
                .style("pointer-events", "none"));
        var c = b
            .append("g")
            .attr(
                "transform",
                "translate(".concat(c5, ",").concat(r5, ") scale(1)"),
            ) // .attr('i_am_a', 'drawing')
            .attr("width", 30)
            .attr("height", 100);
        (c
            .append("rect")
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", 100)
            .attr("height", 100)
            .attr("class", "example_fig")
            .style("stroke", "rgba(0,0,0,0") //.style('fill', 'rgba(0,0,0,0)')
            .style("pointer-events", "visible")
            .on("click", function () {
                select_shape("line_vert", this);
            }),
            c
                .append("line")
                .attr("x1", 50)
                .attr("y1", 0)
                .attr("x2", 50)
                .attr("y2", 100)
                .style("stroke-width", "10px")
                .style("stroke", "#CF5544")
                .style("pointer-events", "none"));
        var c = b
            .append("g")
            .attr("transform", "translate(20,840)")
            .attr("width", 30)
            .attr("height", 100);
        (c
            .append("rect")
            .attr("x", 0)
            .attr("y", -60)
            .attr("width", 200)
            .attr("height", 100)
            .attr("class", "example_fig")
            .style("stroke", "rgba(0,0,0,0") //.style('fill', 'rgba(0,0,0,0)')
            .style("pointer-events", "visible")
            .on("click", function () {
                math_jax_specs.loaded || start_math();
                select_shape("math_shape", this, 0, -60);
            }),
            (c = c.append("g").attr("transform", "matrix(0.08,0,0,-0.08,0,0)")),
            [
                [
                    { x: "0", y: "0" },
                    "M52,289q7,42,54,97t116,56q35,0,64,-18t43,-45q42,63,101,63q37,0,64,-22t28,-59q0,-29,-14,-47t-27,-22t-23,-4q-19,0,-31,11t-12,29q0,46,50,63q-11,13,-40,13q-13,0,-19,-2q-38,-16,-56,-66q-60,-221,-60,-258q0,-28,16,-40t35,-12q37,0,73,33t49,81q3,10,6,11t16,2h4q15,0,15,-8q0,-1,-2,-11q-16,-57,-62,-101t-107,-44q-70,0,-106,63q-41,-62,-94,-62h-6q-49,0,-70,26t-22,55q0,32,19,52t45,20q43,0,43,-42q0,-20,-12,-35t-23,-20t-13,-5l-3,-1q0,-1,6,-4t16,-7t19,-3q36,0,62,45q9,16,23,68t28,108t16,66q5,27,5,39q0,28,-15,40t-34,12q-40,0,-75,-32t-49,-82q-2,-9,-5,-10t-16,-2h-14q-6,6,-6,11z",
                ],
                [
                    { x: "794", y: "0" },
                    "M56,237t0,13t14,20h299v150l1,150q10,13,19,13q13,0,20,-15v-298h298q15,-8,15,-20t-15,-20h-298v-298q-8,-14,-18,-14h-2h-2q-12,0,-18,14v298h-299q-14,7,-14,20z",
                ],
                [
                    { x: "1795", y: "0" },
                    "M21,287q0,14,15,48t48,71t74,36q41,0,66,-23t26,-64q-2,-19,-3,-21q0,-3,-16,-46t-33,-97t-16,-86q0,-43,14,-60t42,-18q23,0,43,11t31,23t27,33q0,1,5,20t14,59t19,74q38,150,42,157q13,27,43,27q13,0,21,-7t11,-12t2,-9q0,-13,-49,-210t-56,-216q-28,-83,-97,-132t-138,-50q-45,0,-79,22t-34,66q0,22,7,37t19,22t20,10t17,3q44,0,44,-42q0,-20,-12,-35t-23,-20t-13,-5l-3,-1q2,-5,19,-12t34,-7h8q17,0,26,2q33,9,61,38t43,62t23,56t8,30l-6,-4q-6,-4,-19,-11t-26,-12q-20,-5,-39,-5q-46,0,-81,22t-46,71q-1,7,-1,31q0,57,35,149t35,117q0,1,0,2q0,9,0,12t-4,7t-11,4h-4q-23,0,-42,-19t-30,-41t-17,-42t-8,-22q-2,-2,-16,-2h-14q-6,6,-6,9z",
                ],
            ].forEach(function (a) {
                c.append("path")
                    .attr(
                        "transform",
                        "translate(".concat(a[0].x, ",").concat(a[0].y, ")"),
                    )
                    .attr("d", a[1])
                    .style("fill", "#CF5544")
                    .style("pointer-events", "none");
            }));
    }
    function select_shape(a, b) {
        var c =
                2 < arguments.length && arguments[2] !== void 0
                    ? arguments[2]
                    : 0,
            d =
                3 < arguments.length && arguments[3] !== void 0
                    ? arguments[3]
                    : 0;
        ((active_style.shape = a),
            pick_me_example(b, c, d),
            text_to_feedback_pane(
                "selected: " + a + " Double click canvas to add",
            ),
            (prev_element = void 0));
    }
    function pick_me_example(a) {
        var b =
                1 < arguments.length && arguments[1] !== void 0
                    ? arguments[1]
                    : 0,
            c =
                2 < arguments.length && arguments[2] !== void 0
                    ? arguments[2]
                    : 0;
        (change_halo(a, b, c), set_current_element(a), set_color_picker(a));
    }
    function change_halo(a) {
        var b =
                1 < arguments.length && arguments[1] !== void 0
                    ? arguments[1]
                    : 0,
            c =
                2 < arguments.length && arguments[2] !== void 0
                    ? arguments[2]
                    : 0;
        (d3.select("#shapes_svg").selectAll(".halo").remove(),
            append_halo(a, b, c));
    }
    function append_halo(a, b, c) {
        var d = d3.select(a),
            e = parseFloat(d.attr("width")) + 10,
            f = parseFloat(d.attr("height")) + 10,
            g = "rect";
        ("g" !== d.node().tagName && (d = d3.select(d.node().parentElement)),
            d
                .append(g)
                .attr("height", f)
                .attr("width", e)
                .attr(
                    "transform",
                    "translate(".concat(b - 5, ",").concat(c - 5, ")"),
                )
                .classed("filter", "true")
                .classed("halo", "true")
                .style("fill", "none")
                .style("stroke", "#A217BB")
                .style("stroke-width", 6));
    }
    function parse_htmlstyle_to_object(a) {
        for (var b = {}, c = 0; c < a.length; c++) b[a[c]] = a[a[c]];
        return ("text" in b || (b.text = "black"), b);
    } //colors example styles predefined colors predefined styles predef_styles
    function fill_example_css_styles(a) {
        function b() {
            var a = document
                    .querySelector("#fs_styles")
                    .getBoundingClientRect(),
                b = 240;
            return [a.left - b, a.top];
        }
        for (
            var d,
                e =
                    1 < arguments.length && arguments[1] !== void 0
                        ? arguments[1]
                        : 1,
                f =
                    2 < arguments.length && arguments[2] !== void 0
                        ? arguments[2]
                        : 7,
                h =
                    3 < arguments.length && arguments[3] !== void 0
                        ? arguments[3]
                        : 27,
                j =
                    4 < arguments.length && arguments[4] !== void 0
                        ? arguments[4]
                        : 18,
                k = a.append("g").attr("class", "example_styles"),
                g = 6,
                l = 0;
            l < Object.keys(predef_styles.get_classes()).length;
            l++
        )
            ((d = "style_" + l),
                k
                    .append("rect")
                    .attr("x", e + (h + 5) * (l % g))
                    .attr("y", f + (j + 6) * parseInt(l / g))
                    .attr("width", h)
                    .attr("height", j)
                    .attr("class", d)
                    .style("fill", predef_styles.get_classes()[d].fill)
                    .style("stroke", predef_styles.get_classes()[d].stroke)
                    .style(
                        "stroke-width",
                        predef_styles.get_classes()[d].stroke_width,
                    )
                    .on("contextmenu", function () {
                        var a;
                        ((currentElement = parse_htmlstyle_to_object(
                            this.style,
                        )),
                            set_color_picker(currentElement),
                            (a = cmm).position_and_display.apply(
                                a,
                                _toConsumableArray(b()).concat([
                                    "#cm-predef-styles",
                                    !1,
                                    !1,
                                ]),
                            ),
                            predef_styles.set_cm_for_predef_style(
                                this.classList[0],
                            ),
                            gui_buttons.add_marker_to_example_style(
                                this.classList[0],
                            ),
                            d3.event.preventDefault(),
                            d3.event.stopPropagation());
                    })
                    .on("click", function () {
                        var a = this;
                        return "canvas" == currentElement.iama
                            ? ((active_style.style_class = this.classList[0]),
                              gui_buttons.add_marker_to_example_style(
                                  active_style.style_class,
                              ),
                              text_to_feedback_pane("default style changed"),
                              !1)
                            : canvas_status.draw_mode
                              ? ((active_style.style_class = this.classList[0]),
                                start_new_draw_group(),
                                render_current_draw_group(context_single),
                                !1)
                              : "fa_icon" == currentElement.iama
                                ? (manage_groups
                                      .get_group(currentElement, !0)
                                      .forEach(function (b) {
                                          b.fill =
                                              predef_styles.get_classes()[
                                                  a.classList[0]
                                              ].fill;
                                      }),
                                  render_all(),
                                  !1)
                                : void (check_for_range_and_add_border(),
                                  manage_groups
                                      .get_group(currentElement, !0)
                                      .forEach(function (b) {
                                          ("text" == b.iama &&
                                              ((b = part_to_chunk(b)),
                                              (b.has_own_style = !0),
                                              position_texts(b.border_id)),
                                              predef_styles.set_styles_from_class(
                                                  b,
                                                  a.classList[0],
                                              ),
                                              b.rough && delete b.redraw_data);
                                      }),
                                  gui_buttons.add_marker_to_example_style(
                                      currentElement.style_class,
                                  ),
                                  set_current_element(currentElement, !0));
                    }),
                k
                    .append("text")
                    .attr("x", e + (h + 5) * (l % g) + 2)
                    .attr("y", f + (j + 6) * parseInt(l / g) + j / 2)
                    .attr("class", d)
                    .style(
                        "fill",
                        "black" == predef_styles.get_classes()[d].color ||
                            "rgba(0,0,0,1)" ==
                                predef_styles.get_classes()[d].color
                            ? "rgba(0,0,0,0)"
                            : predef_styles.get_classes()[d].color,
                    )
                    .style("stroke", "rgba(0,0,0,0)") //predef_styles.get_classes()[c].color)
                    .style("font-size", "8px")
                    .style("pointer-events", "none")
                    .text("text"));
    }
    (fill_example_css_styles(d3.select("#colors_svg")),
        fill_example_css_styles(d3.select("#cm_colors_svg"), 12),
        fill_example_figs());
    function toggle_move_fine(a) {
        return (
            (fine_move = !fine_move),
            toggle_button(document.querySelector("#form_move_delta")),
            fine_move
        ); //return move_delta == 1
    }
    function toggle_size_fine(a) {
        return (
            (fine_size = !fine_size),
            toggle_button(document.querySelector("#form_size_delta")),
            fine_size
        ); //return size_delta == 1
    }
    ((document.querySelector("#form_size_delta").onclick = toggle_size_fine),
        (document.querySelector("#form_move_delta").onclick =
            toggle_move_fine));
    var toggle_side_bar = function b(a) {
        var c = document
            .querySelector("#sidebar")
            .classList.contains("menu_hidden");
        (1 == arguments.length && (c = a),
            document
                .querySelector("#sidebar")
                .classList.toggle("menu_hidden", !c),
            (document.querySelector("#show_button").style.display = c
                ? "none"
                : "block"),
            (form_hidden = !c),
            rescale_canvasses());
    };
    ($("#form_menu_hide").on("click", function (a) {
        (toggle_side_bar(), a.stopPropagation());
    }),
        (document.querySelector("#show_button").onclick = function (a) {
            (toggle_side_bar(), a.stopPropagation());
        }));
    function close_main_feedback_func() {
        document.querySelector("#fs_feedback").style.display = "none";
    }
    function create_feedback_func() {
        var a =
            !!(0 < arguments.length && arguments[0] !== void 0) && arguments[0];
        a || (a = document.querySelector("#fs_feedback"));
        var b;
        return function (c) {
            var d =
                    !!(1 < arguments.length && arguments[1] !== void 0) &&
                    arguments[1],
                e =
                    2 < arguments.length && arguments[2] !== void 0
                        ? arguments[2]
                        : 2500;
            ((a.style.display = "inherit"), "string" == typeof c && (c = [c]));
            var f = c.reduce(function (c, a) {
                return c + "<p>" + a + "</p>";
            }, "");
            ((a.querySelector("div").innerHTML = f),
                a.classList.toggle("error", d),
                clearTimeout(b),
                (b = setTimeout(function () {
                    return (a.style.display = "none");
                }, e)));
        };
    }
    var text_to_feedback_pane = create_feedback_func();
    if (demo_mode) {
        var div = document.querySelector("#fs_demo_fb"),
            text_to_demo_pane = create_feedback_func(div);
        dragElement(div);
    }
    var show_temp_button = (function () {
            var a,
                b = document.querySelector("#fs_temp_button");
            return function (c, d, e) {
                var f =
                        !!(3 < arguments.length && arguments[3] !== void 0) &&
                        arguments[3],
                    g =
                        !!(4 < arguments.length && arguments[4] !== void 0) &&
                        arguments[4],
                    h =
                        !!(5 < arguments.length && arguments[5] !== void 0) &&
                        arguments[5];
                ((b.style.display = "inherit"),
                    "string" == typeof c && (c = [c]));
                var i = c.reduce(function (c, a) {
                    return c + "<p>" + a + "</p>";
                }, "");
                ((b.querySelector("div").innerHTML = i),
                    (b.querySelector("button#een").innerText = d),
                    (b.querySelector("button#een").onclick = function () {
                        (e(), (b.style.display = "none"));
                    }),
                    f
                        ? ((b.querySelector("button#twee").innerText = f),
                          (b.querySelector("button#twee").onclick =
                              function () {
                                  (g(), (b.style.display = "none"));
                              }))
                        : (b.querySelector("button#twee").style.display =
                              "none"),
                    clearTimeout(a),
                    h &&
                        (a = setTimeout(function () {
                            return (b.style.display = "none");
                        }, h)));
            };
        })(),
        text_to_help_pane = make_feedback_func(
            document.querySelector("#fs_help"),
        ); //var text_to_help_pane_slides = make_feedback_func(document.querySelector('#fs_help_slides'));
    //TODO0 naam aanpassen, zie ook create_feedback_func
    function make_feedback_func(a) {
        return function (b, c, d) {
            (c && a.classList.contains("collapsed") && toggle_field_set(a),
                "string" == typeof b && (b = [b]));
            var e = b.reduce(function (c, a) {
                return c + "<p>" + a + "</p>";
            }, "");
            if (((a.querySelector(".fs_toggle").innerHTML = e), d)) {
                var f = a.querySelector("legend");
                f &&
                    (f.classList.toggle("flash", !0),
                    setTimeout(function () {
                        return f.classList.toggle("flash", !1);
                    }, 750));
            }
        };
    }
    function check_for_range_when_p_form_action() {
        if (gui_cursor.has_selection()) {
            if (1 == gui_cursor.get_range().in_selection.length) {
                var a = gui_cursor.split_off_range();
                return (
                    set_current_element(a.parts[0]),
                    gui_cursor.clear_selection(),
                    a
                );
            }
            text_to_feedback_pane([
                "You cannot change the style of to chunks at the time. ",
                "Select one part at a time",
                "a chunk is a piece of text with a distinct style",
            ]);
        }
    }
    function check_for_range_and_add_border() {
        var a = check_for_range_when_p_form_action();
        a && set_current_element(add_own_style_to_text(a));
    }
    function add_own_style_to_text(a) {
        a.has_own_style = !0;
        var b = predef_styles.get_classes()[active_style.style_class]; // p.color = c.color;
        // p.fill =  c.fill;
        // p.stroke = c.stroke;
        // p.stroke_width = c.stroke_width;
        return a;
    }
    function toggle_slide_edit_menu(a) {
        var b =
                !!(1 < arguments.length && arguments[1] !== void 0) &&
                arguments[1],
            c =
                !!(2 < arguments.length && arguments[2] !== void 0) &&
                arguments[2],
            d = document.querySelector("#slides_menu"),
            e = document.querySelector("#edit_mode_menu");
        canvas_status.export_mode && drag_export_off();
        var f;
        ((f = b ? c : !slides_mode),
            f
                ? (d.classList.remove("menu_hidden"),
                  e.classList.add("menu_hidden"),
                  (slides_mode = !0),
                  slide_manager.setup_menu(),
                  slide_manager.update_all_slides())
                : (view.clear_shapes_to_render(),
                  drag_slides_off(),
                  d.classList.add("menu_hidden"),
                  e.classList.remove("menu_hidden"),
                  (slides_mode = !1),
                  canvas_status.slide_exclusion_mode &&
                      exit_slide_exclusion_mode(),
                  slide_manager.slide_show_on() &&
                      slide_manager.end_slide_show()));
    }
    function create_nesw_button(a, b, c, d) {
        function e(a, c, d, e, f, h, i, j) {
            var k = g
                .append("path")
                .attr(
                    "d",
                    "M "
                        .concat(b, " ")
                        .concat(b, "  L ")
                        .concat(a, " ")
                        .concat(c, " A ")
                        .concat(b, " ")
                        .concat(b, " 0 0 1 ")
                        .concat(d, " ")
                        .concat(e, " L ")
                        .concat(b, " ")
                        .concat(b),
                )
                .attr("class", f)
                .attr("dir", f.split(" ")[0])
                .on("click", function () {
                    change_path_side(h, i, j);
                })
                .style("pointer-events", "visible");
        }
        function f(a) {
            var c = g
                .append("rect")
                .attr("x", a)
                .attr("y", a)
                .attr("width", 2 * (b - a))
                .attr("height", 2 * (b - a))
                .style("stroke", "black")
                .style("stroke-width", 2)
                .style("fill", "rgba(0,0,0,0.05")
                .style("pointer-events", "none");
            [
                [b, a, b, a - 9],
                [2 * b - a, b, 2 * b - a + 9, b],
                [b, 2 * b - a, b, 2 * b - a + 9],
                [a, b, a - 9, b],
            ].forEach(function (a) {
                var b = _slicedToArray(a, 4),
                    c = b[0],
                    d = b[1],
                    e = b[2],
                    f = b[3];
                g.append("line")
                    .attr("x1", c)
                    .attr("x2", e)
                    .attr("y1", d)
                    .attr("y2", f)
                    .style("stroke", "black")
                    .style("stroke-width", 3)
                    .style("pointer-events", "none");
            });
        }
        var g = d3
            .select(a)
            .append("svg")
            .attr("width", 2 * b)
            .attr("height", 2 * b);
        g.node().onclick = function (b) {
            (d3
                .selectAll("." + a.classList[0])
                .selectAll("path")
                .classed("on", !1),
                update_path_direction_buttons());
        };
        var h = 180 / Math.PI,
            i = b - Math.sin(45 / h) * b,
            j = 2 * b - i;
        (e(i, i, j, i, "north keep-open path_from_to " + c, 0, "from" == c, d),
            e(
                j,
                i,
                j,
                j,
                "east keep-open path_from_to " + c,
                1,
                "from" == c,
                d,
            ),
            e(
                j,
                j,
                i,
                j,
                "south keep-open path_from_to " + c,
                2,
                "from" == c,
                d,
            ),
            e(
                i,
                j,
                i,
                i,
                "west keep-open path_from_to " + c,
                3,
                "from" == c,
                d,
            ),
            f(b * (1 - Math.sin((45 * Math.PI) / 180))));
    }
    (create_nesw_button(
        document.querySelector("#cm-path-directions-from"),
        16,
        "from",
        function (a, b) {
            return path.fix_path_side(a, b, -1);
        },
    ),
        create_nesw_button(
            document.querySelector("#cm-path-directions-to"),
            16,
            "to",
            function (a, b) {
                return path.fix_path_side(a, -1, b);
            },
        ),
        create_nesw_button(
            document.querySelector("#form-path-directions-from"),
            16,
            "from",
            function (a, b) {
                return path.fix_path_side(a, b, -1);
            },
        ),
        create_nesw_button(
            document.querySelector("#form-path-directions-to"),
            16,
            "to",
            function (a, b) {
                return path.fix_path_side(a, -1, b);
            },
        ),
        (function a() {
            var b = [
                    ["M 0 4 L 25 20", "straight"],
                    ["M 0 4 L 12 4 L12 20 L25 20", "manhattan"],
                    ["M 0 4 L 10 4 L 25 20", "hooked"],
                    ["M 0 4 L 16 16 L 25 16", "hooked_rev"],
                    ["M 0 4 C 12 4 10 20 25 20", "fluid"],
                    ["M 0 4 C 25 4 0 20 25 20", "manh_swirl"],
                    ["M 0 4   C   12 2   14 2    25 20", "arced"],
                    ["M 0 4 C 25 4 0 20 25 20", "super_swirl"],
                    ["M 0 4 L 25 20", "straight"],
                    ["M 0 4 L 12 4 L12 20 L25 20", "manhattan"],
                    ["M 0 4 L 10 4 L 25 20", "hooked"],
                    ["M 0 4 L 16 16 L 25 16", "hooked_rev"],
                    ["M 0 4 C 12 4 10 20 25 20", "fluid"],
                    ["M 0 4 C 25 4 0 20 25 20", "manh_swirl"],
                    ["M 0 4   C   12 2   14 2    25 20", "arced"],
                    ["M 0 4 C 25 4 0 20 25 20", "super_swirl"],
                ],
                c = d3
                    .selectAll("#form_path_style .buttonsvg")
                    .data(b)
                    .attr("flow", function (a) {
                        return a[1];
                    }); // d3.selectAll('.buttonsvg')
            //     .append('rect');
            (c.append("path").attr("d", function (a) {
                return a[0];
            }),
                $("#form_path_style .svg_holder").on("click", function (a) {
                    var b = a.currentTarget
                            .querySelector("svg")
                            .getAttribute("flow"),
                        c = manage_groups.get_group(currentElement, !0),
                        d = [];
                    ((c = new Set(c.concat(d))),
                        c.forEach(function (a) {
                            set_current_element(a);
                            var c = change_path_flow_and_style(!0, b);
                        }),
                        gui_buttons.frame_element(currentElement),
                        render());
                }));
        })());
    function add_end_figs_for_path_to_buttons() {
        for (
            var a = document.querySelectorAll(".form_path_end_fig .svg_holder"),
                c = 0;
            c < a.length;
            c++
        ) {
            var d = Object.keys(path_end_figs)[c % 3],
                e = a[c];
            ((function (a) {
                e.onclick = function () {
                    currentElement.has_arrow &&
                        set_current_element(currentElement.parentElement);
                    var b = "";
                    this.hasAttribute("side")
                        ? (b = this.getAttribute("side"))
                        : console.log("andere manier vinden hier");
                    var c = "head" == b ? 1 : 0;
                    path_end_fig = a;
                    var d;
                    if ("path_group" == currentElement.iama)
                        ((d =
                            !cpa["arrow_" + b] ||
                            (cpa["arrow_" + b] &&
                                cpa["arrow_" + b] != path_end_fig)),
                            change_path_end_fig(b, d));
                    else if (
                        "drawing" == currentElement.iama ||
                        "path_addon" == currentElement.iama
                    ) {
                        var e = currentElement;
                        ("path_addon" == currentElement.iama &&
                            ((e = find_path_by_id(currentElement.parent_id)),
                            !e &&
                                shape_storage.find_parent_of_drawing_add_on(
                                    currentElement,
                                )),
                            (d = !("add_ons" in e) || !(b in e.add_ons)),
                            d
                                ? add_arrow_test(e, b, path_end_fig)
                                : delete e.add_ons[b]);
                    }
                    (d
                        ? $(".if-arrow").css("display", "block")
                        : $(".if-arrow").css("display", "none"),
                        render());
                };
            })(d),
                (e = d3.select(e.querySelector("svg"))));
            var f = path_end_figs[d].func(10, 17, [2, 12]);
            "poly" == f.fig
                ? e.append("g").append("polyline").attr("points", f.points)
                : e.append("g").append("path").attr("d", f.d);
        }
    }
    function set_color_picker(a) {
        var b, c;
        return (
            (a = a || currentElement),
            (b = get_selectors_for_color(a)),
            (color_t = tinycolor(b)),
            colorpicker.spectrum("set", color_t),
            color_t
        );
    }
    function get_selectors_for_color(a) {
        var b =
            !!(1 < arguments.length && void 0 !== arguments[1]) && arguments[1]; //fill, border, text, stroke
        return ((b = b || active_style.fill_what), "fill" == b)
            ? a.fill
            : "border" == b
              ? a.stroke
              : "text" == b
                ? a.color
                : "stroke" == b
                  ? a.stroke
                  : void 0;
    }
    function make_font_selector(a) {
        a.classList.add("font_select_outer");
        var b = document.createElement("div");
        (b.classList.add("font_select_inner"),
            a.appendChild(b),
            (b.onclick = function () {
                (this.classList.toggle("open"),
                    this.parentElement.classList.toggle("open"));
            }),
            (b.onwheel = function (a) {
                a.stopPropagation();
            }));
        var c = document.createElement("i");
        ((c.style = "clear:both; float:right;"),
            c.classList.add("fa", "fa-caret-down", "fa-2x", "keep-open"),
            b.parentElement.parentElement.appendChild(c),
            (c.onclick = function () {
                (b.classList.toggle("open"),
                    b.parentElement.classList.toggle("open"));
            }),
            fonts.forEach(function (a, c) {
                var d = document.createElement("div");
                ((d.style.fontFamily = a),
                    (d.innerText = a),
                    d.classList.add("font_select_item"),
                    b.appendChild(d),
                    (d.onclick = function (a) {
                        (b.classList.remove("open"),
                            b.parentElement.classList.remove("open"),
                            (b.scrollTop = 26 * c),
                            change_font(a),
                            a.stopPropagation());
                    }));
            }));
    }
    function change_selected_in_font_list(a, b) {
        a.querySelector(".font_select_inner").scrollTop = 26 * fonts.indexOf(b);
    }
    var MIN_IN_VIEW = 250,
        SCROLL_DELTA = 18,
        menu_scroll_placer = (function (a) {
            function b(a) {
                var b = parseInt(c.style.top);
                (a && (b += a), (b = Math.min(0, b))); //niet meer 'beneden op scherm' dan onderkant ad_border
                var d = document
                        .querySelector("#form_slide_under")
                        .getBoundingClientRect(),
                    e = d.bottom - d.top;
                ((b = Math.max(b, -Math.max(0, e - MIN_IN_VIEW))),
                    (c.style.top = b + "px"));
            }
            var c = document.querySelector("#form_slide_under"),
                d = 0;
            return (
                (c.style.top = d + "px"),
                (document.querySelector("#fs_container").style.top = d + "px"),
                {
                    scroll: function c(a) {
                        var d = (Math.sign(a.deltaY) * -SCROLL_DELTA) / 2;
                        b(d);
                    },
                    up: function c(a) {
                        b(-50);
                    },
                    down: function c(a) {
                        b(50);
                    },
                }
            );
        })();
    ((document.querySelector("#form_slide_under").onwheel =
        menu_scroll_placer.scroll),
        (document.querySelector("#form_menu_down").onclick =
            menu_scroll_placer.up),
        (document.querySelector("#form_menu_up").onclick =
            menu_scroll_placer.down));
    var a = document.querySelector(".sp-palette-container"),
        b = document.querySelector("#form_fill_what");
    (a.appendChild(b),
        add_end_figs_for_path_to_buttons(),
        close_other_fieldsets()); //TODO9 na merge paragraphs door delete als einde + begin chunks met zelfde stijl samenvoegen
    //TODO filter paths, textsborders etc bij slideshow nog toe te voegen
    // Make the DIV element draggable:https://www.w3schools.com/howto/howto_js_draggable.asp
    function dragElement(a) {
        function b(a) {
            // get the mouse cursor position at startup:
            // call a function whenever the cursor moves:
            ((a = a || window.event),
                a.preventDefault(),
                (h = a.clientX),
                (i = a.clientY),
                (document.onmouseup = d),
                (document.onmousemove = c));
        }
        function c(b) {
            // calculate the new cursor position:
            // set the element's new position:
            ((b = b || window.event),
                b.preventDefault(),
                (f = h - b.clientX),
                (g = i - b.clientY),
                (h = b.clientX),
                (i = b.clientY),
                (a.style.top = a.offsetTop - g + "px"),
                (a.style.left = a.offsetLeft - f + "px"));
        }
        function d() {
            // stop moving when mouse button is released:
            ((document.onmouseup = null), (document.onmousemove = null));
        }
        var f = 0,
            g = 0,
            h = 0,
            i = 0;
        a.onmousedown = b;
    }
    document.body.onresize = function (a) {
        rescale_canvasses();
    };
    function view_mode_on() {
        var a =
            !!(0 < arguments.length && arguments[0] !== void 0) && arguments[0];
        ((canvas_status.view_mode = !0),
            toggle_side_bar(!1),
            (document.querySelector("#keyboard_button").style.display = "none"),
            a ||
                ((document.querySelector("#view_mode_button").style.display =
                    "block"),
                text_to_feedback_pane(
                    [
                        "View mode (no changes possible)",
                        "Click eye button to exit",
                    ],
                    !1,
                    4e3,
                )),
            to_canvas.set_canvas());
    }
    function view_mode_off() {
        ((canvas_status.view_mode = !1),
            (document.querySelector("#view_mode_button").style.display =
                "none"),
            canvas_status.mobile_mode &&
                (document.querySelector("#keyboard_button").style.display =
                    "inline"),
            text_to_feedback_pane("View mode is now off"));
    }
    function show_wait_spinner() {
        var a =
                0 < arguments.length && arguments[0] !== void 0
                    ? arguments[0]
                    : "",
            b =
                1 < arguments.length && arguments[1] !== void 0
                    ? arguments[1]
                    : "";
        ((document.querySelector("#be_patient").style.display = "block"),
            (document.querySelector("#be_patient h2").innerText = a),
            (document.querySelector("#be_patient p").innerText = b));
    }
    function hide_wait_spinner() {
        document.querySelector("#be_patient").style.display = "none";
    }
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function get_x_pos_for_alignment(a, b, c, d) {
        return "left" == a ? d : "right" == a ? d + b - c : d + (b - c) / 2;
    }
    function get_chunks_by_par(a) {
        var b =
                !!(1 < arguments.length && void 0 !== arguments[1]) &&
                arguments[1],
            c = get_text_with_border_id(a, b);
        return (
            (gs = _.groupBy(c, function (a) {
                return a.par_num;
            })),
            Object.keys(gs).forEach(function (a) {
                gs[a].sort(function (c, a) {
                    return c.chunk_num - a.chunk_num;
                });
            }),
            gs
        );
    }
    function get_chunks_in_par(a, b) {
        return get_text_with_border_id(a)
            .filter(function (a) {
                return a.par_num == b;
            })
            .sort(function (c, a) {
                return c.chunk_num - a.chunk_num;
            });
    }
    function even_out_paragraphs(a) {
        var b = get_bbox_of_figure(a),
            c = b.x1y1[1] - b.x0y0[1],
            d = a.padding;
        d && (c -= 2 * parseInt(d));
        var e = get_text_with_border_id(a.id),
            f = get_height_per_par(
                _.groupBy(e, function (a) {
                    return a.par_num;
                }),
            ),
            g = Object.keys(f).length;
        if (0 == g) return !1;
        var h = Object.values(f).reduce(function (a, b) {
            return a + b;
        }, 0);
        margin_between_pars = parseInt((c - h) / (g + 1));
        for (
            var j = get_chunks_by_par(a.id),
                k = function b(a) {
                    j[a].forEach(function (b) {
                        ((b.margin_top = margin_between_pars),
                            (b.y += (a + 1) * margin_between_pars),
                            b.parts.forEach(function (b) {
                                return (b.y += (a + 1) * margin_between_pars);
                            }));
                    });
                },
                l = 0;
            l < g;
            l++
        )
            k(l);
        render();
    }
    function position_texts(a) {
        var b = find_border_by_id(a),
            c = get_text_with_border_id(a);
        if (0 == c.length) return !1; //toegevoegd omdat via align shapes soms ook icon hier terecht kwam
        c.forEach(function (a) {
            return delete a.parts;
        });
        var d = _.groupBy(c, function (a) {
                return a.par_num;
            }),
            e = get_poly_config(b),
            f = b.stroke_width / 2 || 1,
            g = b.height,
            h = b.width,
            j = {};
        Object.keys(d).forEach(function (a) {
            d[a] = d[a].sort(function (c, a) {
                return c.chunk_num - a.chunk_num;
            });
            var c = d[a][0].margin_left || 0;
            j[a] = find_breaks_for_par(
                d[a],
                h * e.fo_width - c - 2 * b.padding,
            );
        });
        for (
            var k = b.y + f + g * e.fo_top_left[1] + b.padding, l = 0, m = 0;
            m < b.num_pars;
            m++
        )
            j[m] &&
                j[m].forEach(function (a, c) {
                    var f,
                        g = a.line_parts,
                        j = a.chunks_on_line,
                        n = a.text_width;
                    ((f =
                        "margin_left" in j[0]
                            ? b.padding +
                              j[0].margin_left +
                              b.x +
                              h * e.fo_top_left[0]
                            : b.padding +
                              get_x_pos_for_alignment(
                                  b.text_align,
                                  h * e.fo_width - 2 * b.padding,
                                  n,
                                  b.x + h * e.fo_top_left[0],
                              )),
                        0 == c && (k += d[m][0].margin_top || 0));
                    var o = Math.max.apply(
                        void 0,
                        j.map(function (a) {
                            return a.height;
                        }),
                    );
                    (_.zip(g, j).forEach(function (a, c) {
                        var d = _slicedToArray(a, 2),
                            g = d[0],
                            h = d[1];
                        "parts" in h || (h.parts = []);
                        var i = Math.max(
                                measure_text_width({
                                    font_style: h.font_style,
                                    text: g.text,
                                    font_family: h.font_family,
                                    font_size: h.font_size,
                                }),
                                MIN_PAR_WIDTH,
                            ),
                            m = {
                                text: g.text,
                                line_num: g.line_num,
                                x: f,
                                y: k,
                                baseline_offset: (7 * o) / 9,
                                width: i,
                                height: o,
                                border_id: h.border_id,
                                iama: "text",
                                num: l,
                                par_num: h.par_num,
                                parent: h,
                            }; //optie om als gekleurd, hoogte gekleurde part af te leiden van part height ipv max height
                        // let measured_part = {
                        // 	text: part.text,
                        // 	line_num: part.line_num,
                        // 	x: start_x,
                        // 	y: start_y +max_h*2/3 - chunk.height*2/3,
                        // 	baseline_offset: chunk.height * 2 / 3,
                        // 	width: w,
                        // 	height: chunk.height,
                        // 	border_id: chunk.border_id,
                        // 	iama: 'text',
                        // 	num: part_counter,
                        // 	par_num: chunk.par_num,
                        // 	parent: chunk,
                        // }
                        (j.length - 1 == c &&
                            h.cover_whole_line &&
                            ((m.text_border = {}),
                            (m.text_border.width =
                                e.fo_width * b.width - 2 * b.padding),
                            (m.text_border.x =
                                b.padding + b.x + b.width * e.fo_top_left[0])),
                            h.parts.push(m),
                            (f += i),
                            (l += 1));
                    }),
                        (k += o));
                });
        adjust_border_height(b, c, e, !0);
    }
    function find_breaks_for_par(b, c) {
        function d(a, b, c) {
            for (var d = [" ", "-", ",", ".", ":", "/"], e = a; e > b; e--)
                if (-1 != d.indexOf(c[e])) return e + 1;
            return a;
        }
        var e = function a() {
                return [
                    {
                        chunks_on_line: b,
                        line_parts: b.map(function (a) {
                            return { text: a.text, line_num: 0 };
                        }),
                        text_width: g || MIN_PAR_WIDTH,
                    },
                ];
            },
            f = b.map(function (a) {
                var b = measure_par_width_at_each_letter(a).slice(1);
                return b;
            }),
            g = f.reduce(function (a, b) {
                return a + b.slice(-1)[0];
            }, 0); //max width groter dan text width >> early return
        if (g <= c) return e();
        for (var h = [], j = 0, k = 0; k < b.length; k++)
            (h.push(
                f[k].map(function (a) {
                    return a + j;
                }),
            ),
                (j += f[k].slice(-1)[0]));
        var l = _.flatten(h),
            m = _.flatten(
                h.map(function (a, b) {
                    return Array(a.length).fill(b);
                }),
            ),
            n = _.flatten(
                b.map(function (a) {
                    return a.text.split("");
                }),
            ); //als de paragraaf geen text bevat:
        if (2 > l.length) return e(); //controle elke afstand kleiner dan max_wdith opdat geen oneindige loop
        for (var o = 1; o < l.length; o++) if (l[o] - l[o - 1] > c) return e(); //TODO8, indien hier exit, breedte aanpassen?
        for (var p, q = [0].concat(l), r = [], s = 1, t = 0; t < l.length; ) {
            ((p = _.findIndex(l, function (a) {
                return c < a - (p ? l[p - 1] : 0);
            })),
                (p = -1 == p ? l.length : d(p, t, n)));
            var u = Array.from(new Set(m.slice(t, p))).map(function (a) {
                return b[a];
            });
            if (
                (r.push({
                    chunks_on_line: u,
                    line_parts: break_to_line_part(m, n, t, p, s - 1),
                    text_width: q[p] - q[t] || MIN_PAR_WIDTH,
                }),
                (t = p),
                (s += 1),
                s > l.length + 1)
            )
                return !1;
        }
        return r;
    }
    function break_to_line_part(a, b, c, d, e) {
        var f = Array.from(new Set(a.slice(c, d))),
            g = [];
        return (
            f.forEach(function (f) {
                var h = a.map(function (a) {
                    return a == f;
                });
                ((text = _.zip(h.slice(c, d), b.slice(c, d)).reduce(function (
                    a,
                    b,
                ) {
                    return a + (b[0] ? b[1] : "");
                }, "")),
                    g.push({ text: text, line_num: e }));
            }),
            g
        );
    }
    function compare_styles_of_shapes_for_render(a, b) {
        return _.all(
            ["fill", "stroke", "stroke_width", "stroke_dasharray"].map(
                function (c) {
                    return a[c] == b[c];
                },
            ),
        );
    }
    function compare_styles_of_chunks_for_render(a, b) {
        return _.all(
            ["font_family", "font_size", "color", "font_style"].map(
                function (c) {
                    return a[c] == b[c];
                },
            ),
        );
    }
    function compare_styles_of_chunks(a, b) {
        return _.all(
            [
                "font_family",
                "font_size",
                "color",
                "fill",
                "stroke",
                "stroke_width",
                "style_class",
            ].map(function (c) {
                return a[c] == b[c];
            }),
        );
    }
    function merge_chunks(a, b) {
        ((a.text += b.text), shapes_storage.remove(b));
    }
    function check_par_for_chunk_style_equality(a, b) {
        var c = get_chunks_in_par(a, b);
        if (2 > c.length) return !1;
        for (var d = !1, e = 0; e < c.length - 1; e++)
            compare_styles_of_chunks(c[e], c[e + 1]) &&
                ((d = !0), merge_chunks(c[e], c[e + 1]));
        d && (reset_chunk_numbering(a, b), position_texts(a));
    }
    function reset_par_and_chunk_numbering(a) {
        //Alleen filteren als text length 0 is als er meerdere chunks zijn in een paragraaf.
        //Anders wordt nieuwe paragraaf (bv na enter) steeds verwijderd
        var b = {},
            c = get_chunks_by_par(a);
        (Object.keys(c).forEach(function (a) {
            b[a] = c[a].length;
        }),
            (shapes_storage.texts[a] = shapes_storage.texts[a].filter(
                function (a) {
                    return 0 != a.text.length || 1 == b[a.par_num];
                },
            )));
        var d = get_chunks_by_par(a, !0),
            e = Object.keys(d).sort(function (c, a) {
                return c - a;
            });
        (e.forEach(function (a, b) {
            d[a].forEach(function (a, c) {
                ((a.par_num = b), (a.chunk_num = c));
            });
        }),
            (shapes_storage.borders[a].num_pars = e.length));
    }
    function reset_chunk_numbering(a, b) {
        get_chunks_in_par(a, b).forEach(function (a, b) {
            return (a.chunk_num = b);
        });
    }
    function handle_par_drag(a, b, c) {
        (d3.event.sourceEvent.shiftKey && (b = 0),
            d3.event.sourceEvent.altKey && (c = 0),
            change_par_margin(a, b, c));
    }
    function split_off_paragraphs(a) {
        var b = manage_groups.get_group(a).forEach(function (a) {
            if (a.num_pars) {
                margin_to_prev = 12;
                for (var b, c = 0; c < a.num_pars; c++)
                    ((b = get_chunks_in_par(a.id, c)),
                        (last_pos = [
                            b[0].parts[0].x,
                            b[0].parts[0].y + c * margin_to_prev,
                        ]),
                        (target_for_par = add_shape_to_canvas(!1)),
                        (target_for_par.width = a.width),
                        move_chunks_to_other_shape(b, target_for_par.id, 0));
                delete_shape(a, !0);
            }
        });
    }
    function move_chunks_to_other_shape(a, b, c) {
        (a.forEach(function (a) {
            (shapes_storage.remove_text(a),
                delete a.margin_top,
                delete a.margin_left,
                (a.border_id = b),
                (a.par_num = c),
                shapes_storage.add_text(a));
        }),
            (target_for_par.num_pars += 1),
            position_texts(b));
    }
    function move_dragged_par_to_final_pos(a, b, c, d, e) {
        function f(a, b) {
            for (
                var c = get_chunks_by_par(a), d = 0;
                d < Object.keys(c).length && !(c[d][0].parts[0].y > b);
                d++
            );
            for (var e = d; e < Object.keys(c).length; e++)
                c[e].forEach(function (a) {
                    return (a.par_num += 1);
                });
            return d;
        }
        function g(b, c) {
            find_border_by_id(a.parent.border_id).num_pars -= 1;
            for (
                var d = get_chunks_by_par(b), e = c + 1;
                e < Object.keys(d).length;
                e++
            )
                d[e].forEach(function (a) {
                    return (a.par_num -= 1);
                });
        }
        var h = a.parent.border_id,
            i = get_chunks_in_par(a.parent.border_id, a.parent.par_num);
        g(h, a.parent.par_num);
        var j = d + b,
            k = e + c,
            l = shapes_storage.find_text_droppable_shape(j, k),
            m = 0;
        (l
            ? (m = f(l.id, k))
            : ((last_pos = [j, k]),
              (l = add_shape_to_canvas(!1)),
              (l.width = 200)),
            move_chunks_to_other_shape(i, l.id, m),
            position_texts(h),
            set_current_element(l));
    }
    function swap_line(a, b, c) {
        var d = get_chunks_by_par(a, !0),
            e = Object.keys(d).length - 1;
        return (
            !(0 > b || b > e) &&
            !(0 > c || c > e) &&
            void (d[b].forEach(function (a) {
                return (a.par_num = c);
            }),
            d[c].forEach(function (a) {
                return (a.par_num = b);
            }))
        );
    }
    function select_line_up(a, b, c) {
        //keys en indexofcurrent toegevoegd voo als flipside en niet alle pars aanwezig zijn in by_par_num
        //waardoor verkeerde par_nums kunnen worden opgevraagd bij gebruik -1
        var d = Object.keys(b).map(function (a) {
                return parseInt(a);
            }),
            e = d.indexOf(a.par_num);
        if (0 == a.line_num) {
            if (0 < e) {
                var f = _.groupBy(
                    _.flatten(
                        b[d[e - 1]].map(function (a) {
                            return a.parts;
                        }),
                    ),
                    function (a) {
                        return a.line_num;
                    },
                ); //if ( current_part.par_num-1 >= 0){
                //let by_line_num = _.groupBy(_.flatten(by_par_num[current_part.par_num-1].map(d=>d.parts)), d=>d.line_num);
                return f[Object.keys(f).length - 1][0];
            }
            return !1;
        }
        return c[a.line_num - 1][0];
    }
    function select_line_down(a, b, c) {
        var d = Object.keys(b).length,
            e = Object.keys(c).length,
            f = Object.keys(b).map(function (a) {
                return parseInt(a);
            }),
            g = f.indexOf(a.par_num);
        return a.line_num < e - 1
            ? c[a.line_num + 1][0]
            : !!(g + 1 < d) && b[f[g + 1]][0].parts[0];
    }
    function select_line_with_arrow(a, b) {
        var c =
                !(2 < arguments.length && arguments[2] !== void 0) ||
                arguments[2],
            d = get_chunks_by_par(a),
            e = _.groupBy(
                _.flatten(
                    d[b.par_num].map(function (a) {
                        return a.parts;
                    }),
                ),
                function (a) {
                    return a.line_num;
                },
            ),
            f = !1; // if ('flipped' in shapes_storage.borders[border_id]){
        // 	Object.keys(by_par_num).forEach((k,i)=>{
        // 		by_par_num[i] =
        // 	})
        // }
        ((f = c ? select_line_down(b, d, e) : select_line_up(b, d, e)),
            f &&
                (set_current_element(f),
                gui_buttons.frame_element(currentElement),
                gui_cursor.set_cursor_by_index(currentElement, 0)));
    }
    function make_shape_flippable(a) {
        (get_text_with_border_id(a.id).forEach(function (a) {
            return (a.flipped = !1);
        }),
            (a.flipped = !1));
    }
    function flip_shape(a) {
        var b = a.width,
            c = a.height;
        ((a.flipped = !a.flipped),
            !a.flipped && a.flipsize
                ? ((a.width = a.flipsize[0]), (a.height = a.flipsize[1]))
                : (a.flipsize = [b, c]),
            position_texts(a.id),
            gui_buttons.frame_element(a),
            canvas_status.view_mode
                ? (text_for_render.invalidate_sorted(), render_all())
                : (text_for_render.invalidate_sorted(),
                  set_current_element(a)));
    }
    $(".form_par_to_flip_side").on("click", function (a) {
        var b = part_to_chunk(currentElement);
        ("flipped" in b ||
            make_shape_flippable(shapes_storage.borders[b.border_id]),
            (b.flipped = !0),
            position_texts(b.border_id),
            set_current_element(shapes_storage.borders[b.border_id]));
    });
    function reset_par_numbering_all_borders() {
        ((ids = Object.values(shapes_storage.borders).map(function (a) {
            return [a.id, a.num_pars];
        })),
            ids.forEach(function (a) {
                _.range(a[1]).forEach(function (b) {
                    return reset_chunk_numbering(a[0], b);
                });
            }));
    } //TODO2 slides tutorial: filter via foto laten zien ipv via gif.
    //TODO pad met text block detach gaat niet goed.
    //TODO knot niet weggehaald als pad naar knot wordt verwijderd
    //TODO textwobble minder dik of meer doorzichtig maken
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    var undoer = (function () {
        //groep elementen die samen verwijderd worden (bv paden, gegroepeerde eleemnte)
        function a() {
            c.length > 10 && (c = c.splice(1));
        } //TODO3 ongebruikte functies
        function b(a) {
            var b = path.extract_elements_from_path_id(a.id),
                c = _slicedToArray(b, 2),
                d = c[0],
                e = c[1],
                f = shapes_storage.knots.map(function (a) {
                    return a.id;
                });
            return f.includes(d) && f.includes(e)
                ? [d, e]
                : f.includes(d)
                  ? [d]
                  : f.includes(e)
                    ? [e]
                    : [];
        }
        var c = [],
            d = [];
        return {
            start: function a() {
                d = [];
            },
            stop: function b() {
                (c.push(d), a());
            },
            remove: function c(a) {
                var e = this; //if (el.hasAttribute('table')) remove_cell_from_table(el)
                if ((d.push(a), "path_group" == a.iama)) {
                    var f = b(a);
                    f.map(function (a) {
                        return shapes_storage.knots.filter(function (b) {
                            return b.id == a;
                        })[0];
                    }).forEach(function (a) {
                        return e.remove(a);
                    }, this);
                }
                if ("border" == a.iama) {
                    var g = get_text_with_border_id(a.id);
                    (g.forEach(function (a) {
                        (d.push(a), shapes_storage.remove(a));
                    }),
                        a.id in shapes_storage.images &&
                            (d.push(shapes_storage.images[a.id]),
                            delete shapes_storage.images[a.id]));
                }
                if ("path_group" == a.iama) {
                    var h = Object.values(shapes_storage.borders_bound).filter(
                        function (b) {
                            return b.path_id == a.id;
                        },
                    );
                    h.forEach(function (a) {
                        return e.remove(a);
                    }, this);
                }
                (shapes_storage.remove(a),
                    "text" == a.iama &&
                        reset_par_and_chunk_numbering(a.border_id));
            },
            undo: function a() {
                return 0 == c.length
                    ? (text_to_feedback_pane("no more items stored"), !1)
                    : void ((to_add = c.pop()),
                      to_add.forEach(function (a) {
                          //var [c, p] = d
                          //p.appendChild(c);
                          //if (c.hasAttribute('table')) restore_table(c);
                          shapes_storage.add_existing_shape(a);
                      }),
                      set_current_element(to_add[0]));
            },
            show_stored: function a() {
                return c;
            },
        };
    })();
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function find_parts_with_border_id(a) {
        var b = get_text_with_border_id(a),
            c = [];
        return (
            b.forEach(function (a) {
                "parts" in a
                    ? a.parts.forEach(function (a) {
                          return c.push(a);
                      })
                    : c.push(b[0]);
            }),
            c
        );
    }
    function set_shape_width_to_max_line_width(a) {
        var b = find_border_by_id(a),
            c = get_text_with_border_id(a),
            d = _.flatten(
                c.map(function (a) {
                    return a.parts;
                }),
            ),
            e = _.groupBy(d, function (a) {
                return a.par_num + "_" + a.line_num;
            }),
            f = Math.max.apply(
                null,
                Object.values(e).map(function (a) {
                    return a.reduce(function (a, b) {
                        return a + b.width;
                    }, 0);
                }),
            ),
            g = get_poly_config(b),
            h = f / g.fo_width + 2 * b.padding;
        ((b.width = h + 2),
            (b.fixed_size = !0),
            b.rough && delete b.redraw_data,
            b.border_sides_arr && calc_border_dasharray(b, b.border_sides_arr));
    } //TODO1 goed nakijken hoe double klik resize werkt: lijkt niet goed te gaan
    function recalc_border_width(a) {
        var b =
                !!(1 < arguments.length && arguments[1] !== void 0) &&
                arguments[1],
            c =
                !(2 < arguments.length && arguments[2] !== void 0) ||
                arguments[2],
            d =
                !!(3 < arguments.length && arguments[3] !== void 0) &&
                arguments[3],
            e = find_border_by_id(a),
            f = e.width;
        if (!e.fixed_size || b) {
            var g = get_chunks_by_par(a),
                h = get_width_per_par(g),
                i = measure_max_text_width(h),
                j = get_poly_config(e),
                k = i / j.fo_width + 2 * e.padding; //+ 2 * (border.padding||0);
            if (d && k < f) return !1;
            ((e.width = k + 2),
                c &&
                    ((max_width =
                        d && f > max_border_width ? f : max_border_width),
                    (e.width = Math.min(
                        e.width,
                        infinity.get_standard_scaling(
                            max_width,
                            e.level || "L1",
                        ),
                    ))),
                e.width == max_border_width && (e.fixed_size = !0),
                e.rough && delete e.redraw_data,
                e.border_sides_arr &&
                    calc_border_dasharray(e, e.border_sides_arr));
        }
    }
    function recalc_border_height(a) {
        var b =
                !!(1 < arguments.length && arguments[1] !== void 0) &&
                arguments[1],
            c = find_border_by_id(a),
            d = get_poly_config(c),
            e = get_text_with_border_id(a);
        (adjust_border_height(c, e, d, b),
            c.rough && delete c.redraw_data,
            c.border_sides_arr && calc_border_dasharray(c, c.border_sides_arr));
    }
    function adjust_border_height(a, b, c) {
        function d(a, b) {
            (a.forEach(function (a) {
                return (a.y += b);
            }),
                a.forEach(function (a) {
                    return a.parts.forEach(function (a) {
                        return (a.y += b);
                    });
                }));
        }
        var e =
                !(3 < arguments.length && arguments[3] !== void 0) ||
                arguments[3],
            f = (function (a, b) {
                var c = get_chunks_by_par(a.id),
                    d = get_height_per_par(c),
                    e = measure_total_text_height(d) + 2 * a.padding;
                return round_to(e / b - a.height, 0);
            })(a, c.fo_height);
        if (0 > f && e) return !1;
        if (0 != f) {
            if (1 > c.fo_height) {
                var g = (a.height + f) * c.fo_height - a.height * c.fo_height;
                d(b, g);
            }
            resize_protocol(a, 0, f, !0);
        }
    }
    function add_par_and_position_cursor(a) {
        var b =
            1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : -1;
        -1 == b && (b = a.num_pars);
        var c = add_paragraph_to_shape(a, b).parent;
        (recalc_border_height(a.id, !0),
            position_texts(a.id),
            render(),
            gui_cursor.set_cursor_by_xpos(c.parts[0], last_pos[0] + 100),
            gui_cursor.start_cursor());
    }
    function add_icon_to_canvas(a, b) {
        var c = get_default_icon(a, b);
        shapes_storage.icons.push(c);
    }
    function add_shape_to_canvas() {
        var a =
                !!(0 < arguments.length && void 0 !== arguments[0]) &&
                arguments[0],
            c = get_default_border();
        return (
            roughen_all && (c.rough = !0),
            a
                ? ((c.font_size = infinity.get_font_size(
                      infinity.get_level(),
                      4,
                  )),
                  (shapes_storage.borders_bound[c.id] = c))
                : (shapes_storage.borders[c.id] = c),
            c
        );
    }
    function add_line_to_canvas() {
        var a = get_default_drawing(0, 0, "line");
        roughen_all && (a.rough = !0);
        var b = last_pos,
            c = _slicedToArray(b, 2),
            d = c[0],
            e = c[1],
            f = [],
            g = infinity.get_standard_scaling(100, a.level);
        ("line_hor" == active_style.shape
            ? (f = [
                  [
                      [d, e],
                      [d + g, e],
                  ],
              ])
            : "line_vert" == active_style.shape &&
              (f = [
                  [
                      [d, e],
                      [d, e + g],
                  ],
              ]),
            set_drawing_pos(a, f),
            shapes_storage.drawings.push(a),
            set_current_element(a));
    }
    function get_new_shape_with_text() {
        var a =
                0 < arguments.length && void 0 !== arguments[0]
                    ? arguments[0]
                    : "",
            c =
                !!(1 < arguments.length && void 0 !== arguments[1]) &&
                arguments[1],
            d = add_shape_to_canvas(c),
            b = add_paragraph_to_shape(d);
        return (a && add_text_to_paragraph(b, a), [d, b]);
    }
    function add_paragraph_to_shape(a) {
        var b =
                1 < arguments.length && void 0 !== arguments[1]
                    ? arguments[1]
                    : -1,
            c = 2 < arguments.length ? arguments[2] : void 0,
            d = get_default_text(a, c);
        ((d.par_num = a.num_pars),
            (a.num_pars += 1),
            shapes_storage.add_text(d));
        var e = get_default_textpart_for_par(d);
        return (
            d.parts.push(e),
            -1 != b && swap_line(a.id, d.par_num, b),
            set_current_element(e),
            e
        );
    }
    function add_text_to_paragraph(a, b) {
        ((a.parent.text = b),
            (a.text = b),
            measure_text(a.parent),
            recalc_border_width(a.parent.border_id),
            recalc_border_height(a.parent.border_id, !0),
            gui_cursor.set_cursor_by_xpos(a.parent.parts[0], last_pos[0] + 100),
            gui_cursor.start_cursor());
    }
    function get_poly_config(a) {
        if (a.shape in poly_config) {
            if ("points" in a) {
                var b = poly_config[a.shape].fo_dims(a.points),
                    c = _slicedToArray(b, 3),
                    d = c[0],
                    e = c[1],
                    f = c[2];
                return {
                    fo_top_left: d,
                    fo_width: e,
                    fo_height: f,
                    points: a.points,
                };
            }
            return poly_config[a.shape];
        }
        var g = get_pos_for_foreignObject(a);
        return ((g.points = a.points), g);
    }
    function el_under_dragged_shape() {
        var a =
            !!(0 < arguments.length && arguments[0] !== void 0) && arguments[0];
        el_under = !1;
        var b = d3.event.sourceEvent || d3.event,
            c = get_xy_inverted_from_event(b),
            d = _slicedToArray(c, 2),
            e = d[0],
            f = d[1];
        ((a = shapes_storage.find_connectable_shape(e, f)),
            cc.clear_canvas(hover_context),
            a &&
                ((el_under = a),
                render_hover_highlight(
                    a,
                    "rgba(13, 177, 255, 0.75)",
                    hover_context,
                    get_scaled_margin(),
                )));
    }
    function get_scaled_margin() {
        var a =
            0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : 5;
        return 0 == a ? 0 : Math.max(1, parseInt(a / transform.k));
    }
    var paths_on_canvas_done = {};
    function repos_shape(a, b, c) {
        var d = a.id || !1;
        if (
            ((a.x += b),
            (a.y += c),
            "add_ons" in a &&
                Object.keys(a.add_ons).forEach(function (d) {
                    ((a.add_ons[d].x += b),
                        (a.add_ons[d].y += c),
                        (a.add_ons[d].bbox.x += b),
                        (a.add_ons[d].bbox.y += c),
                        (a.add_ons[d].rotation[1] += b),
                        (a.add_ons[d].rotation[2] += c));
                }),
            !d)
        )
            return !1; //oa drawings hebben geen id.
        var e = get_text_with_border_id(d);
        (e.forEach(function (a) {
            ((a.x += b),
                (a.y += c),
                "parts" in a &&
                    a.parts.forEach(function (a) {
                        ((a.x += b),
                            (a.y += c),
                            "text_border" in a && (a.text_border.x += b));
                    }));
        }),
            d in shapes_storage.images &&
                ((shapes_storage.images[d].border_data.x += b),
                (shapes_storage.images[d].border_data.y += c)));
    } //TODO9: functionaliteit groep beter onderscheiden (2 functions_ van functionaliteit
    //stappen om shape te resizej
    function resize_protocol(a, b, c, d) {
        var e = d ? [a] : manage_groups.get_group(a, !0);
        ((e = e.filter(function (a) {
            return "path_group" != a.iama && "text" != a.iama;
        })),
            (no_feedback = !0),
            (no_table = !1),
            1 < e.length &&
                path.change_collision_detection.turn_off_temporary(),
            e.forEach(function (a) {
                if ("drawing" == a.iama) resize_drawing(a, b, c);
                else if (a.is_cell) resize_cell(a, b, c);
                else if ("path_addon" == a.iama) {
                    //wordt niet meer gerbuikt, kan eruit ??
                    var d = conv_angle(
                            conv_arrow_rotation_to_geo_rotation(a.rotation[0]),
                            b,
                            c,
                        ),
                        e = _slicedToArray(d, 2),
                        f = e[0],
                        g = e[1]; //let [dx1, dy1] = [dx, dy]
                    //let [dx1, dy1] = rotate_point((el.rotation[0]), dx, dy);
                    if (
                        ((a.width = Math.max(5, a.width - g)),
                        (a.height = Math.max(5, a.height - f)),
                        a.parent_id)
                    )
                        (path.set_path_attrs(find_path_by_id(a.parent_id)),
                            path.remake_path(!0),
                            set_current_element(
                                1 == a.end
                                    ? cpa.path_g.add_ons.head
                                    : cpa.path_g.add_ons.tail,
                            ));
                    else {
                        var h = shapes_storage.find_parent_of_drawing_add_on(a);
                        (add_arrow_test(h, a.side, a.figure, a.width, a.height),
                            set_current_element(
                                1 == a.end ? h.add_ons.head : h.add_ons.tail,
                            ));
                    }
                } else resize_shape(a, b, c);
            }),
            1 < e.length && path.change_collision_detection.restore(),
            (no_table = !0),
            (no_feedback = !1));
    }
    function resize_shape(a, b, c) {
        ((a.width = round_to(b + a.width, 0)),
            (a.height = round_to(c + a.height, 0)));
        var d = !1,
            e = !1;
        if (
            (5 >= a.width &&
                ((d = !0),
                (a.width = 5),
                text_to_feedback_pane("min width must be 5")),
            5 >= a.height &&
                ((e = !0),
                (a.height = 5),
                text_to_feedback_pane("min height must be 5")),
            (d && e) || (d && 0 == c) || (e && 0 == b))
        )
            return !1;
        (path.recalc_connections(a.id), position_texts(a.id));
        return (
            a.id in shapes_storage.images &&
                !shapes_storage.images[a.id].border_data.has_fixed_size &&
                calc_image_size(a, shapes_storage.images[a.id]),
            "border_sides_arr" in a &&
                calc_border_dasharray(a, a.border_sides_arr),
            a.rough && delete a.redraw_data,
            !0
        );
    }
    function find_sticky_and_reposition(a, b, c) {
        reposition_protocol(a, b, c);
    } //TODO9: functionaliteit groep beter onderscheiden (2 functions_ van functionaliteit
    //stappen om shape te verzetten
    //force_Fixed niet gebruikt ?
    function reposition_protocol(a, b, c) {
        function e(a, b, c) {
            (a.is_cell ? repos_cell(a, b, c) : repos_shape(a, b, c),
                path.recalc_connections(a.id, !1, !0));
        }
        no_feedback = !0;
        var f = manage_groups.get_group(a); //TODO0 : verwijderen elk child dat al een parent heeft in els;
        (1 < f.length &&
            ((f = f.filter(function (a) {
                return "path_group" != a.iama && "text" != a.iama;
            })),
            (f = clear_children_from_group(f)),
            path.change_collision_detection.turn_off_temporary()),
            (no_table = !1),
            f.forEach(function (a) {
                e(a, b, c);
            }),
            f.forEach(function (a) {
                merged.is_parent(a) &&
                    merged.get_children(a).forEach(function (a) {
                        return e(a, b, c);
                    });
            }),
            (no_table = !0),
            1 < f.length && path.change_collision_detection.restore());
    }
    function clear_children_from_group(a) {
        var b = a.slice();
        return (
            a.forEach(function (c) {
                merged.is_child(c) &&
                    -1 != a.indexOf(merged.get_parent(c)) &&
                    (b = b.filter(function (a) {
                        return a != c;
                    }));
            }),
            b
        );
    }
    function arrow_position_element(a) {
        var b =
                !!(1 < arguments.length && arguments[1] !== void 0) &&
                arguments[1],
            c =
                !!(2 < arguments.length && arguments[2] !== void 0) &&
                arguments[2],
            d = get_deltaxy_from_key_press(a),
            e = fine_move || c ? 1 : mdd;
        (find_sticky_and_reposition(currentElement, d[0] * e, d[1] * e, b),
            gui_buttons.frame_element(currentElement),
            render());
    }
    function arrow_resize_element(a) {
        var b =
                !!(1 < arguments.length && arguments[1] !== void 0) &&
                arguments[1],
            c =
                !!(2 < arguments.length && arguments[2] !== void 0) &&
                arguments[2],
            d = get_deltaxy_from_key_press(a),
            e = fine_size || c ? 1 : mdd;
        (resize_protocol(currentElement, d[0] * e, d[1] * e, b),
            gui_buttons.frame_element(currentElement),
            render());
    }
    function repos_text_block(a, b) {
        var c =
                2 < arguments.length && arguments[2] !== void 0
                    ? arguments[2]
                    : 0,
            d = get_bbox_of_figure(b, !0),
            e = _slicedToArray(d, 4),
            f = e[0],
            g = e[1],
            h = e[2],
            i = e[3],
            j = { x: f, y: g, width: h, height: i },
            k = j.x + j.width * a.pos_perc + c;
        ((a.pos_perc = (k - j.x) / j.width),
            isNaN(m) && (m = 0.5),
            isNaN(a.pos_perc) && (a.pos_perc = 0.5));
        var l = path.create_svg_path_for_measurement(b.d),
            m = l.getPointAtLength(l.getTotalLength() * a.pos_perc),
            n = m.x - a.width / 2,
            o = m.y - a.height / 2;
        c = n - a.x;
        var p = o - a.y;
        ((a.x = n),
            (a.y = o),
            get_text_with_border_id(a.id).forEach(function (a) {
                ((a.x += c), (a.y += p));
            }),
            position_texts(a.id));
    } // function path_id_to_el_ids(path_id, without_selector){
    // 	if (without_selector){
    // 		return [path_id.slice(4,9), path_id.slice(12,17)];
    // 	}else{
    // 		return ['#'+ path_id.slice(4,9), '#'+path_id.slice(12,17)];
    // 	}
    // }
    function calc_polygon_points(a) {
        var b = poly_config[a.shape].points,
            c = a.width,
            d = a.height;
        return b.map(function (a) {
            var b = _slicedToArray(a, 2),
                e = b[0],
                f = b[1];
            return [c * e, d * f];
        });
    } //TODO9 implementeren voor ellipse
    function calc_border_dasharray(b) {
        for (
            var c,
                e =
                    !!(1 < arguments.length && arguments[1] !== void 0) &&
                    arguments[1],
                f = calc_polygon_points(b),
                g = [],
                h = f.length,
                j = 0;
            j < f.length;
            j++
        )
            ((c = pyth_dist(f[j], f[(j + 1) % h])), g.push(Math.sqrt(c)));
        var k = g.reduce(function (c, a) {
                return c + a;
            }),
            l = b.shape,
            m = poly_config[l].borders,
            a = Array(h).fill(!1);
        ((sides_to_draw = []),
            e.forEach(function (a, b) {
                a && sides_to_draw.push(m[b]);
            }),
            (sides_to_draw = _.flatten(sides_to_draw)),
            sides_to_draw.forEach(function (b) {
                return (a[b] = !0);
            }),
            (vals = []),
            a[0] || vals.push(0),
            vals.push(g[0]));
        for (var j = 1; j < h; j++)
            a[j - 1] == a[j]
                ? (vals[vals.length - 1] += g[j])
                : vals.push(g[j]);
        b.stroke_dasharray = vals;
    } //Polygon.prototype.calc_shape_and_pos= function(abs_points){
    function calc_custom_poly_points(a) {
        var b = (function (a) {
                for (
                    var b, c = 1 / 0, d = 1 / 0, e = 0, f = 0, g = 0;
                    g < a.length;
                    g++
                )
                    ((b = a[g]),
                        (c = Math.min(c, b[0])),
                        (e = Math.max(e, b[0])),
                        (d = Math.min(d, b[1])),
                        (f = Math.max(f, b[1])));
                return [c, e, d, f];
            })(a),
            c = _slicedToArray(b, 4),
            e = c[0],
            f = c[1],
            g = c[2],
            h = c[3],
            i = Math.max(f - e, 1),
            j = Math.max(h - g, 1),
            d = a.map(function (a) {
                var b = _slicedToArray(a, 2),
                    c = b[0],
                    d = b[1];
                return [round_to((c - e) / i, 4), round_to((d - g) / j, 4)];
            });
        return {
            points: d,
            dims: { width: i, height: j },
            mid: [e + (f - e) / 2, g + (h - g) / 2],
            topleft: [e, g],
        };
    }
    function delete_shape(a) {
        var b =
            !!(1 < arguments.length && arguments[1] !== void 0) && arguments[1];
        cc.clear_canvas(gui_context); //var parent = find_g(shape_to_delete.parentElement);
        var c = b ? [a] : manage_groups.get_group(a, !0);
        (c.forEach(function (a) {
            var b = !("hg" in a) && "text" != a.iama; //gaat anders fout bij verwijderen en weer toevoegen pad. Dan wordt childelement aan
            //pad niet weer gemerkt als hg.
            (merged.is_parent(a) && merged.remove_group(a),
                merged.is_child(a) && merged.remove_child(a),
                b && undoer.start()); //ook als undo_on false wel via undoer.remove items verwijderd, maar deze worden dan niet opgeslagen in undoer.
            var d = path.find_connections(a.id);
            (d.forEach(function (a) {
                (manage_groups.remove_element_if_present(a), undoer.remove(a));
            }),
                undoer.remove(a),
                b
                    ? (undoer.stop(),
                      text_to_feedback_pane(
                          "Deleted items: press control Q to undo",
                      ))
                    : text_to_feedback_pane("Element removed (not undoable)"),
                "text" == a.iama &&
                    check_par_for_chunk_style_equality(a.border_id, a.par_num),
                manage_groups.remove_element_if_present(a));
        }),
            1 < c.length && manage_groups.reset(),
            render_all(),
            to_canvas.set_canvas());
    }
    function make_poly_points(a) {
        var b = get_default_border();
        return (
            (b.shape = "custom"),
            roughen_all && (b.rough = !0),
            update_poly_points(b, a),
            (shapes_storage.borders[b.id] = b),
            b
        );
    }
    function update_poly_points(a, b) {
        var c = calc_custom_poly_points(b),
            d = c.points,
            e = c.dims,
            f = c.mid,
            g = c.topleft;
        ((a.points = d),
            (a.width = e.width),
            (a.height = e.height),
            (a.x = g[0]),
            (a.y = g[1]));
    }
    function calc_dims_for_snapshot(a, b, c, d) {
        var e = 1;
        e = a / b > c / d ? a / c : b / d;
        var f = parseInt(a / e),
            g = parseInt(b / e),
            h = 0,
            i = 0;
        return (
            f < c && (h = parseInt((c - f) / 2)),
            g < d && (i = parseInt((d - g) / 2)),
            { x: h, y: i, w: f, h: g, scale: e }
        );
    }
    function make_snapshot(a, b, c, d, e, f, g) {
        var h =
            !!(7 < arguments.length && void 0 !== arguments[7]) && arguments[7];
        h || (h = document.createElement("canvas"));
        var i = calc_dims_for_snapshot(c, d, e, f),
            j = h.getContext("2d"); // console.log([parseInt(transform.applyX(sx)*PIXEL_RATIO), parseInt(transform.applyY(sy)*PIXEL_RATIO), parseInt((sw*transform.k)*PIXEL_RATIO), parseInt((sh*transform.k)*PIXEL_RATIO)],
        // 	[dims.x ,dims.y, dims.w, dims.h]);
        return (
            scale_canvas(h, j, e, f),
            j.drawImage(
                g,
                parseInt(transform.applyX(a) * PIXEL_RATIO),
                parseInt(transform.applyY(b) * PIXEL_RATIO),
                parseInt(c * transform.k * PIXEL_RATIO),
                parseInt(d * transform.k * PIXEL_RATIO),
                i.x,
                i.y,
                i.w,
                i.h,
            ),
            h
        );
    } // void ctx.drawImage(image, dx, dy);
    // void ctx.drawImage(image, dx, dy, dWidth, dHeight);
    // void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
    //s=source, d=destination
    function get_xy_inverted_from_event(a) {
        var b = get_x_y_from_event(a),
            c = _slicedToArray(b, 2),
            d = c[0],
            e = c[1],
            f = transform.invert([d - canvas_offset_x, e - canvas_offset_y]),
            g = _slicedToArray(f, 2);
        return ((d = g[0]), (e = g[1]), [d, e]);
    }
    function get_x_y_from_event(a) {
        return "touch" == a.type.slice(0, 5)
            ? "touchend" == a.type
                ? [a.changedTouches[0].clientX, a.changedTouches[0].clientY]
                : [a.touches[0].clientX, a.touches[0].clientY]
            : [a.clientX, a.clientY];
    }
    function insert_point_in_polygon(a, b) {
        a = a.map(function (a) {
            return Math.floor(a / mdd) * mdd;
        });
        var c = b.length,
            d =
                b
                    .map(function (a, d) {
                        return [a, b[(d + 1) % c]];
                    })
                    .map(function (b) {
                        return inbetween2(b[0], b[1], a, 25);
                    })
                    .indexOf(!0) + 1;
        if (!d)
            return (
                text_to_feedback_pane([
                    "cannot find position for new point",
                    "click in between to points, for both x and y",
                ]),
                [!1, !1, !1]
            );
        var e = b.splice(d);
        return (b.push(a), (b = b.concat(e)), b);
    }
    function poly_points_to_absolute_points(a) {
        return a.points.map(function (b) {
            return [b[0] * a.width + a.x, b[1] * a.height + a.y];
        });
    }
    function add_point_to_polygon(a, b) {
        var c = poly_points_to_absolute_points(a),
            d = insert_point_in_polygon(b, c);
        (update_poly_points(currentElement, d),
            gui_buttons.reset_path_control_points(),
            show_poly_points(a),
            render());
    }
    function reshape_polygon(a, b, c) {
        var d = poly_config[a.shape].shape;
        if ("points" in a) var e = a.points.slice();
        else
            var f = get_poly_config(a),
                e = f.points.map(function (a) {
                    return a.slice();
                });
        var g = e.map(function (b) {
                return [b[0] * a.width, b[1] * a.height];
            }),
            h = d(g, b, c),
            i = get_minxy_maxxy_of_array(h),
            j = _slicedToArray(i, 4),
            k = j[0],
            l = j[1],
            m = j[2],
            n = j[3];
        ((a.x += k),
            (a.y += l),
            (a.width = m - k),
            (a.height = n - l),
            (a.points = h.map(function (b) {
                return [
                    round_to((b[0] - k) / a.width, 4),
                    round_to((b[1] - l) / a.height, 4),
                ];
            })),
            a.rough && delete a.redraw_data,
            "border_sides_arr" in a &&
                calc_border_dasharray(a, a.border_sides_arr));
    }
    function handle_gui_resize_double_click() {
        (manage_groups.get_group(currentElement, !0).forEach(function (a) {
            d3.event.ctrlKey
                ? set_shape_width_to_max_line_width(a.id)
                : (!d3.event.shiftKey && recalc_border_width(a.id, !0, !0),
                  position_texts(a.id),
                  recalc_border_height(a.id));
        }),
            gui_buttons.frame_element(currentElement),
            set_current_element(currentElement));
    } //TODO double click resize: gaat niet goed als text align center is.
    //Moet aan staan voor drag en draw met touch
    // Touch Events API
    // Force Touch Events API feature detection to always be enabled or disabled, or to be enabled when a touchscreen is detected on startup (Automatic).
    //TODO staat aan: wat effect als uit is voor breakdown notes
    //Overscroll history navigation
    //History navigation in response to horizontal overscroll
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function resize_drawing(a, b, c, e) {
        var f,
            g,
            i = a.d
                .split("M")
                .slice(1)
                .map(function (a) {
                    return "M" + a;
                })
                .map(path_to_array),
            j = get_path_points_min_max(_.flatten(i)),
            k = _slicedToArray(j, 4),
            l = k[0],
            m = k[1],
            n = k[2],
            o = k[3],
            q = m - l,
            r = o - n;
        e ? ((f = b), (g = c)) : ((f = q + b), (g = r + c));
        var h = !1,
            p = i.map(function (a) {
                if (0 == f && 0 == g)
                    return (
                        text_to_feedback_pane("smaller not possible"),
                        (h = !0),
                        !1
                    );
                if (2 == a.length && (0 == q || 0 == r))
                    ((c = a),
                        0 == q && (f = 0),
                        0 == r && (g = 0),
                        (c[a.length - 1].x = f),
                        (c[a.length - 1].y = g));
                else {
                    (5 > f) | (5 > g) &&
                        ((f = Math.max(5, f)),
                        (g = Math.max(5, g)),
                        text_to_feedback_pane("no smaller possible"));
                    var b = a.map(function (a) {
                            return { x: a.x / q, y: a.y / r };
                        }),
                        c = b.map(function (a) {
                            return { x: a.x * f, y: a.y * g };
                        });
                }
                return c;
            });
        if (h) return !1;
        var s = "";
        ((s =
            "lineto" == a.flow
                ? p.map(array_to_line).join(" ")
                : p.map(array_to_path).join(" ")),
            (a.d = s),
            (a.width = f),
            (a.height = g),
            "drawing" == a.iama &&
                "add_ons" in a &&
                Object.keys(a.add_ons).forEach(function (b) {
                    return add_arrow_test(
                        a,
                        b,
                        a.add_ons[b].figure,
                        a.add_ons[b].width,
                        a.add_ons[b].height,
                    );
                }),
            a.rough && delete a.redraw_data);
    } //TODO0. ALS op text alignment wordt gedrukt, of margin resetten, of waarschuwing dat paragraaf custom margin heeft
    function start_new_draw_group(a, b) {
        ((current_draw_group = current_draw_group.filter(function (a) {
            return "" != a.d;
        })),
            set_current_element(get_default_drawing(a, b)),
            current_draw_group.push(currentElement));
    }
    function make_line_drawing(a) {
        var b = Math.min.apply(
                null,
                a.map(function (a) {
                    return a[0];
                }),
            ),
            c = Math.min.apply(
                null,
                a.map(function (a) {
                    return a[1];
                }),
            ),
            d = get_default_drawing(b, c, "line");
        ((d.d = array_to_line(
            a.map(function (a) {
                var b = _slicedToArray(a, 2),
                    c = b[0],
                    d = b[1];
                return { x: c, y: d };
            }),
        )),
            (d.flow = "lineto"),
            cc.clear_canvas(gui_context),
            roughen_all && (d.rough = !0),
            set_drawing_pos(d, [a]),
            shapes_storage.drawings.push(d));
    }
    function set_drawing_pos(a, b) {
        var c = 1 / 0,
            d = 1 / 0,
            e = -Infinity,
            f = -Infinity,
            g = _.flatten(b, !0),
            h = g.map(function (a) {
                return a[0];
            }),
            i = g.map(function (a) {
                return a[1];
            });
        ((c = Math.min(c, Math.min.apply(void 0, h))),
            (e = Math.max(e, Math.max.apply(void 0, h))),
            (d = Math.min(d, Math.min.apply(void 0, i))),
            (f = Math.max(f, Math.max.apply(void 0, i))),
            (a.x = c),
            (a.y = d),
            (a.width = Math.max(4, e - c)),
            (a.height = Math.max(4, f - d)));
        var j = b.map(function (a) {
            return a.map(function (a) {
                var b = _slicedToArray(a, 2),
                    e = b[0],
                    f = b[1];
                return { x: e - c, y: f - d };
            });
        });
        ((a.d = j.map(array_to_line).join(" ")),
            "lineto" != a.flow && (a.d = drawn_line_to_bezier(a.d)));
    }
    function handle_line_drag(a, b, c, d) {
        var e = path_to_array(a.d),
            f = { x: 0, y: 0 };
        if (0 == b) {
            var g = e.slice(0, 1)[0];
            ((f.x = g.x + c), (f.y = g.y + d));
        } else {
            var g = e.slice(-1)[0];
            ((f.x = g.x + c), (f.y = g.y + d));
        }
        (cc.clear_canvas(gui_context),
            render_poly_line(
                [
                    [g.x + a.x, g.y + a.y],
                    [f.x + a.x, f.y + a.y],
                ],
                gui_context,
                !1,
            ));
    }
    function handle_line_end_drag(a, b, c, d) {
        var e = path_to_array(a.d),
            f = { x: 0, y: 0 };
        if (0 == b) {
            var g = e.slice(0, 1)[0];
            ((f.x = g.x + c), (f.y = g.y + d), (e = [f].concat(e)));
        } else {
            var h = e.slice(-1)[0];
            ((f.x = h.x + c), (f.y = h.y + d), e.push(f));
        }
        var i = [
            e.map(function (b) {
                var c = b.x,
                    d = b.y;
                return [c + a.x, d + a.y];
            }),
        ]; //set_drawing_pos moet abs poitns hebben,
        (set_drawing_pos(a, i),
            a.rough && delete a.redraw_data,
            gui_buttons.frame_element(a),
            set_current_element(a),
            "drawing" == a.iama &&
                "add_ons" in a &&
                Object.keys(a.add_ons).forEach(function (b) {
                    return add_arrow_test(
                        a,
                        b,
                        a.add_ons[b].figure,
                        a.add_ons[b].width,
                        a.add_ons[b].height,
                    );
                }));
    }
    function handle_poly_point_add_button_end_drag(a, b) {
        var c = d3.event.subject;
        ((c.x += a), (c.y += b), get_);
        var d = gui_buttons.get_path_control_points_as_ref().map(function (a) {
            return [a.x, a.y];
        });
        update_poly_points(currentElement, d);
    } //TODO1 remove point from custom poly points
    ($(".form_pencil_size button").on("click", function () {
        ($(".form_pencil_size").find("button").toggleClass("onoff-on", !1),
            $(
                '.form_pencil_size button[value="'.concat(this.value, '"]'),
            ).toggleClass("onoff-on", !0),
            (active_style.pencil_size = this.value),
            canvas_status.draw_mode &&
                (start_new_draw_group(),
                render_current_draw_group(context_single)),
            canvas_status.draw_mode || drag_draw_on());
    }),
        _.forEach(
            [
                document.querySelector("#form_toggle_draw"),
                document.querySelector("#cm_toggle_draw"),
            ],
            function (a) {
                a.onclick = function () {
                    cmm.off(); //eerst uitdoen, anders repostion van canvas mogelijk niet goed
                    // bij uitzetten doordat in reposition protocol wordt gecontroleerd of uit staat
                    var a = this.querySelector(
                        ".toggle-button",
                    ).classList.contains("toggle-button-selected");
                    a ? drag_draw_off() : drag_draw_on();
                };
            },
        ));
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var f = 0, g = Array(c); f < c; f++) g[f] = b[f];
        return g;
    }
    function _iterableToArrayLimit(b, c) {
        var g =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != g) {
            var h,
                j,
                k,
                l,
                m = [],
                a = !0,
                p = !1;
            try {
                if (((k = (g = g.call(b)).next), 0 === c)) {
                    if (Object(g) !== g) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (h = k.call(g)).done) &&
                        (m.push(h.value), m.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((p = !0), (j = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != g["return"] &&
                        ((l = g["return"]()), Object(l) !== l)
                    )
                        return;
                } finally {
                    if (p) throw j;
                }
            }
            return m;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function table_to_cols(a) {
        var b = tables[a],
            c = _.range(b[0].length).map(function () {
                return [];
            });
        return (
            b.forEach(function (a) {
                a.forEach(function (a, b) {
                    return c[b].push(a);
                });
            }),
            c
        );
    }
    ((document.querySelector("#cm_align_equal_height_each_row").onclick =
        equal_height_per_row),
        (document.querySelector("#cm_align_equal_width_each_col").onclick =
            equal_width_per_col),
        (document.querySelector("#cm_align_equal_height_current_row").onclick =
            equal_height_current_row),
        (document.querySelector("#cm_align_equal_width_current_col").onclick =
            equal_width_current_col),
        plus_minus_generator(
            document.querySelector("#cm_align_x_delta"),
            function (a) {
                alter_min_x_margin_for_table(parseInt(a.value));
            },
            1,
            0,
        ),
        plus_minus_generator(
            document.querySelector("#cm_align_y_delta"),
            function (a) {
                alter_min_y_margin_for_table(parseInt(a.value));
            },
            1,
            0,
        ));
    function equal_height_current_row() {
        var a = parseInt(currentElement.vt.split("_")[0]);
        resize_heights(tables.temp01[a]);
    }
    function equal_width_current_col() {
        var a = parseInt(currentElement.vt.split("_")[1]),
            b = table_to_cols("temp01");
        resize_widths(b[a]);
    }
    function resize_widths(a) {
        if (
            ((a = a.filter(function (a) {
                return "dummy_cell" != a.me;
            })),
            2 > a.length)
        )
            return !1;
        var b = a.map(function (a) {
                return a.width;
            }),
            c = Math.max.apply(null, b),
            e = b.indexOf(c);
        resize_elements(a[e], a, "width");
    }
    function resize_heights(a) {
        if (
            ((a = a.filter(function (a) {
                return "dummy_cell" != a.me;
            })),
            2 > a.length)
        )
            return !1;
        var b = a.map(function (a) {
                return a.height;
            }),
            c = Math.max.apply(null, b),
            e = b.indexOf(c);
        resize_elements(a[e], a, "height");
    }
    function equal_width_per_col() {
        var a = table_to_cols("temp01");
        (a.forEach(resize_widths),
            set_current_element(tables.temp01[0][0], !0));
    }
    function equal_height_per_row() {
        (tables.temp01.forEach(resize_heights),
            set_current_element(tables.temp01[0][0], !0));
    } // function get_r_c_id_from_cell(cell){
    //     var [r,c] = cell['vt'].split('_').map(d=>parseInt(d));
    //     var table_id = cell['table']
    //     return [parseInt(r), parseInt(c), table_id]
    // }
    // function get_table_row(cell){
    //     var [r,c, table] = get_r_c_id_from_cell(cell);
    //     return tables[table][r]
    // }
    // function get_table_col(cell){
    //     var [r,c, table] = get_r_c_id_from_cell(cell);
    //     return tables[table].map(d=>d[c])
    // }
    function alter_min_x_margin_for_table(a) {
        //kolommen verder uit elkaar of dichterbij
        for (
            var b = table_to_cols("temp01"),
                c = function c() {
                    var f = b[e].filter(function (a) {
                        return "dummy_cell" != a.me;
                    });
                    if (0 == f.length) return 1; // continue
                    var g = Math.max.apply(
                        null,
                        f.map(function (a) {
                            return a.x + a.width;
                        }),
                    );
                    b[e + 1].forEach(function (b) {
                        "dummy_cell" != b.me && repos_shape(b, g - b.x + a, 0);
                    });
                },
                e = 0;
            e < b.length - 1;
            e++
        )
            c();
        set_current_element(tables.temp01[0][0], !0);
    }
    function alter_min_y_margin_for_table(a) {
        for (
            var b = tables.temp01,
                c = function c() {
                    var f = b[e].filter(function (a) {
                        return "dummy_cell" != a.me;
                    });
                    if (0 == f.length) return 1; // continue
                    var g = Math.max.apply(
                        null,
                        f.map(function (a) {
                            return a.y + a.height;
                        }),
                    );
                    b[e + 1].forEach(function (b) {
                        "dummy_cell" != b.me && repos_shape(b, 0, g - b.y + a);
                    });
                },
                e = 0;
            e < b.length - 1;
            e++
        )
            c();
        set_current_element(tables.temp01[0][0], !0);
    }
    for (
        var t = document.querySelectorAll("#form_resize button"), i = 0;
        i < t.length;
        i++
    )
        ((d = t[i]),
            (d.onclick = function () {
                var a = currentElement.iama;
                if (
                    !a ||
                    "path_group" == a ||
                    "knot" == a ||
                    "text_basic" == a ||
                    "icon_basic" == a
                )
                    return (
                        text_to_feedback_pane(
                            "not a valid element for alignment",
                        ),
                        !1
                    );
                if (canvas_status.align_on) var b = _.flatten(tables.temp01);
                else var b = manage_groups.get_group(currentElement, !0);
                (resize_elements(currentElement, b, this.value),
                    manage_groups
                        .get_group(currentElement, !0)
                        .forEach(function (a) {
                            return delete a.redraw_data;
                        }),
                    render());
            })); //gebruikt bij alignment
    function resize_elements(a, b, c) {
        var e = parseFloat(a.width),
            f = parseFloat(a.height);
        b.forEach(function (a, b) {
            var g = "height" == c ? a.width : e,
                i = "width" == c ? a.height : f;
            "fa_icon" != a.iama &&
                ((a.width = g),
                (a.height = i),
                position_texts(a.id),
                path.recalc_connections(a.id));
        });
    }
    function find_boundaries(a) {
        for (
            var b,
                c =
                    !(1 < arguments.length && arguments[1] !== void 0) ||
                    arguments[1],
                e =
                    !(2 < arguments.length && arguments[2] !== void 0) ||
                    arguments[2],
                f = 1 / 0,
                g = 0,
                h = 1 / 0,
                j = 0,
                k = 0;
            k < a.length;
            k++
        ) {
            var l = a[k],
                m = [posit2.get_top_left(a[k]), posit2.get_bottom_right(a[k])],
                n = c ? 0 : 1,
                o = e ? 1 : 0;
            ((f = Math.min(f, m[n][0])),
                (h = Math.min(h, m[n][1])),
                (g = Math.max(g, m[o][0])),
                (j = Math.max(j, m[o][1])));
        }
        return [f, h, g, j];
    }
    function find_dim_for_alignment(a) {
        var b = find_boundaries(a, !0, !1),
            c = _slicedToArray(b, 4);
        return (
            (minX = c[0]),
            (minY = c[1]),
            (maxX = c[2]),
            (maxY = c[3]),
            maxY - minY > maxX - minX ? "vert" : "hor"
        );
    }
    function find_start_end_position(a, b) {
        var c = find_boundaries(a, !0, !0),
            e = _slicedToArray(c, 4);
        ((minX = e[0]), (minY = e[1]), (maxX = e[2]), (maxY = e[3]));
        var f = posit2.get_top_left(a[0]),
            g = posit2.get_bottom_right(a[0]);
        return (
            "hor" == b
                ? ((minY = f[1]), (maxY = g[1]))
                : "vert" == b && ((minX = f[0]), (maxX = g[0])),
            [minX, maxX, minY, maxY]
        );
    }
    function sort_els(b, c) {
        var e = b.filter(function (a) {
            return "path_group" != a.iama;
        });
        return (
            (e = e.sort(function (a, b) {
                return posit2.get_top_left(a)[c] - posit2.get_top_left(b)[c];
            })),
            e
        );
    }
    function align_figs(a, b, c, f) {
        function g(a, b, c) {
            var e = get_custom_bbox(a),
                f = get_custom_bbox(b);
            if (0 == c) return e.top - e.bottom;
            return 1 == c
                ? f.left - e.right
                : 2 == c
                  ? f.top - e.bottom
                  : 3 == c
                    ? e.left - f.right
                    : void 0;
        }
        function h() {
            var a = get_custom_bbox(j),
                b = get_custom_bbox(m);
            return "hor" == o ? b.right + y - a.left : b.bottom + y - a.top;
        } //dim_to_align = hor, vert, both
        var j, k, e, l, m;
        b = b.filter(function (b) {
            return b != a;
        });
        var n = [a].concat(b);
        if (2 > n.length) return !1;
        var o = find_dim_for_alignment(n),
            p = find_start_end_position([a]),
            q = _slicedToArray(p, 4),
            r = q[0],
            s = q[1],
            t = q[2],
            u = q[3],
            v = "hor" == o ? 0 : 1,
            w = 0 == v ? 1 : 2;
        n = sort_els(n, v);
        var x = n.indexOf(a);
        if (x == n.length - 1) var y = g(n[0], n[1], w);
        else var y = g(n[x], n[x + 1], w);
        for (var z = "both" == c || c == o, x = 0; x < n.length; x++)
            ((j = n[x]),
                (me = j.iama),
                me &&
                    (0 < x && (m = n[x - 1]),
                    "hor" == o
                        ? ((e = 0 < x ? h() : 0),
                          (l = t - posit2.get_top_left(j)[1]))
                        : ((l = 0 < x ? h() : 0),
                          (e = r - posit2.get_top_left(j)[0])),
                    "hor" == c && (e = 0),
                    "vert" == c && (l = 0),
                    (j.x += e),
                    (j.y += l))); //zodat paden ook weer worden herberekend:
        f || resize_protocol(parent, 0, 0);
    }
    ((group_aligner = (function () {
        //horizontal = zelfde y waarde, op een rijtje
        //vertical align = zelfde x waarde, netjes onder elkaar
        function a(a, b) {
            var c =
                    !(2 < arguments.length && arguments[2] !== void 0) ||
                    arguments[2],
                e = bbox_to_xywh(to_bbox(a)),
                f = bbox_to_xywh(to_bbox(b)),
                g = c ? [e.x, e.x + e.width] : [e.y, e.y + e.height],
                h = c ? [f.x, f.x + f.width] : [f.y, f.y + f.height],
                i = g[1] < h[0] || g[0] > h[1];
            return !i;
        }
        function b(a, b) {
            //one to the left of other
            return (
                !(a.x > b.x + b.width || b.x > a.x + a.width) &&
                !(a.y > b.y + b.height || b.y > a.y + a.height)
            ); //one above the other
        }
        function c(a, b, c) {
            var e = function b(a) {
                    return [a.x, a.y];
                },
                f = function b(a) {
                    return [a.x + a.width, a.y];
                },
                g = function b(a) {
                    return [a.x, a.y + a.height];
                };
            if ("left" == c) return pyth_dist(e(a), f(b));
            return "right" == c
                ? pyth_dist(f(a), e(b))
                : "top" == c
                  ? pyth_dist(e(a), g(b))
                  : "bottom" == c
                    ? pyth_dist(g(a), e(b))
                    : void 0;
        }
        function e(a, b, c) {
            return c ? Math.abs(a.y - b.y) : Math.abs(a.x - b.x);
        }
        function f(a) {
            var b = { left: i, right: j, up: k, down: l };
            Object.entries(b).forEach(function (b) {
                var c = _slicedToArray(b, 2),
                    e = c[0],
                    f = c[1],
                    g = f(a.me);
                a[e] = g ? C[g.id] : void 0;
            });
            var c = [
                ["left", "up"],
                ["left", "down"],
                ["right", "up"],
                ["right", "down"],
            ];
            c.forEach(function (b) {
                var c = _slicedToArray(b, 2),
                    e = c[0],
                    f = c[1];
                return g(a, e, f);
            });
        }
        function g(a, b, c) {
            function f(a, b, c, e) {
                //key1 = left or right, key2 = up or down
                return a < b ? c : e;
            }
            if (a[b] && a[b] == a[c]) {
                var g = e(a.me, a[b].me, !0),
                    h = e(a.me, a[c].me, !1);
                a[f(h, g, b, c)] = void 0;
            }
        }
        function h(a) {
            var b = a; //.map(d=>d[0]+d[1])
            return _.indexOf(b, Math.min.apply(void 0, b));
        }
        function i(b) {
            var e = B.filter(function (c) {
                    return a(b, c, !1);
                }).filter(function (a) {
                    return a.x < b.x;
                }),
                f = e.map(function (a) {
                    return c(b, a, "left");
                });
            return e[h(f)];
        }
        function j(b) {
            var e = B.filter(function (c) {
                    return a(b, c, !1);
                }).filter(function (a) {
                    return a.x > b.x;
                }),
                f = e.map(function (a) {
                    return c(b, a, "right");
                });
            return e[h(f)];
        }
        function k(b) {
            var e = B.filter(function (c) {
                    return a(b, c, !0);
                }).filter(function (a) {
                    return a.y < b.y;
                }),
                f = e.map(function (a) {
                    return c(b, a, "top");
                });
            return e[h(f)];
        }
        function l(b) {
            var e = B.filter(function (c) {
                    return a(b, c, !0);
                }).filter(function (a) {
                    return a.y > b.y;
                }),
                f = e.map(function (a) {
                    return c(b, a, "bottom");
                });
            return e[h(f)];
        }
        function m(a, b) {
            function c(a, b) {
                //let wel col_pos kunnen overlap hebben, of er kan ruimte tussen zitten
                for (
                    var c = 0;
                    c < b.length &&
                    (a.x > b[c][1] || (a.x >= b[c][0] && a.x < b[c][1]));
                    c++
                );
                return c - 1;
            }
            var e = b.map(function (a) {
                    return a.reduce(
                        function (a, b) {
                            return [
                                Math.min(a[0], b.x),
                                Math.min(a[1], b.x + b.width),
                            ];
                        },
                        [1 / 0, 1 / 0],
                    );
                }),
                f = a.map(function (a) {
                    return a.map(function (a) {
                        return c(a, e);
                    });
                });
            f.forEach(function (b, c) {
                _.range(e.length).forEach(function (e) {
                    -1 == b.indexOf(e) &&
                        a[c].splice(
                            e,
                            0,
                            make_table_dummy_node(c, e, "temp01"),
                        );
                });
            });
            var g = a.map(function (a) {
                return a.length;
            });
            return _.all(
                g.map(function (a) {
                    return a == g[0];
                }),
            )
                ? (a.forEach(function (a) {
                      return a.forEach(function (a) {
                          return (a.is_cell = !0);
                      });
                  }),
                  a.forEach(function (a, b) {
                      return a.forEach(function (a, e) {
                          return (a.vt =
                              "dummy_cell" == a.me
                                  ? a.vt
                                  : "".concat(b, "_").concat(e));
                      });
                  }),
                  a.forEach(function (a) {
                      return a.forEach(function (a) {
                          return (a.table = "temp01");
                      });
                  }),
                  a.forEach(function (a, b) {
                      return a.forEach(function (a, e) {
                          return a.vt == "".concat(b, "_").concat(e);
                      });
                  }),
                  !_.all(
                      a
                          .map(function (a, b) {
                              return a.map(function (a, e) {
                                  return a.vt == "".concat(b, "_").concat(e);
                              });
                          })
                          .map(function (a) {
                              return _.all(a);
                          }),
                  ))
                    ? (n(),
                      text_to_feedback_pane(
                          "Sorry, failed at aligning group. Try using less shapes...",
                          !0,
                          3500,
                      ),
                      !1)
                    : ((tables.temp01 = a), !0)
                : (text_to_feedback_pane(
                      "Sorry, failed at aligning group. Try using less shapes...",
                      !0,
                      3500,
                  ),
                  !1);
        }
        function n() {
            (B.forEach(function (a) {
                (delete a.vt, delete a.table, delete a.is_cell);
            }),
                delete tables.temp01);
        }
        function o(a) {
            function c(a, b) {
                return a.x + a.width - b.x + 10;
            }
            for (var e, f = 0; f < a.length - 1; f++)
                if (((e = a[f]), "dummy_cell" != e.me)) {
                    var g = C[e.id].right; //row[i+1];
                    if (g) {
                        var h = g.me;
                        if (h && b(e, h)) {
                            var i = c(e, h);
                            repos_cell(h, i, 0, !0);
                        }
                    }
                }
        }
        function p(a) {
            function c(a, b) {
                return a.y + a.height - b.y + 10;
            }
            for (var e, f = 0; f < a.length - 1; f++)
                if (((e = a[f]), "dummy_cell" != e.me)) {
                    var g = C[e.id].down; //row[i+1];
                    if (g) {
                        var h = g.me;
                        if (b(e, h)) {
                            var i = c(e, h);
                            repos_cell(h, 0, i, !0);
                        }
                    }
                }
        }
        function q(a) {
            return s(a, w);
        }
        function r(a) {
            return s(a, x);
        }
        function s(a, b) {
            ((rows = []),
                Object.values(a).forEach(function (a) {
                    rows.push(b(a));
                }));
            var c = new Set();
            return rows.filter(function (a) {
                return (
                    (a = a.sort(function (c, a) {
                        return c.id < a.id ? -1 : 1;
                    })),
                    !c.has(a[0].id) && (c.add(a[0].id), !0)
                );
            });
        }
        function t(a) {
            var b = Math.min.apply(
                void 0,
                a.map(function (a) {
                    return a.y;
                }),
            );
            a.forEach(function (a) {
                repos_shape(a, 0, b - a.y);
            });
        }
        function u(a) {
            var b = Math.min.apply(
                void 0,
                a.map(function (a) {
                    return a.x;
                }),
            );
            a.forEach(function (a) {
                repos_shape(a, b - a.x, 0);
            });
        }
        function v(a, b) {
            for (var c = []; a[b]; ) (c.push(a[b].me), (a = a[b]));
            return c;
        }
        function w(a) {
            var b = [a.me];
            return (
                (b = b.concat(v(a, "left"))),
                (b = b.concat(v(a, "right"))),
                b
            );
        }
        function x(a) {
            var b = [a.me];
            return (
                (b = b.concat(v(a, "up"))),
                (b = b.concat(v(a, "down"))),
                b
            );
        }
        function y(a) {
            var b = {};
            Object.values(a).forEach(function (a) {
                [
                    ["up", "down"],
                    ["down", "up"],
                    ["left", "right"],
                    ["right", "left"],
                ].forEach(function (b) {
                    var c = _slicedToArray(b, 2),
                        e = c[0],
                        f = c[1],
                        g = a[e];
                    if (g) {
                        var h = g[f] && g[f].me == a.me;
                        h || (g[f] ? (a[e] = !1) : (a[e] = !1));
                    }
                });
            });
        }
        function z(a) {
            return { me: a, left: !1, right: !1, up: !1, down: !1 };
        }
        function A(a) {
            function b(a, b) {
                a.forEach(function (c) {
                    var e = _slicedToArray(b[c.id], 4),
                        f = e[0],
                        g = e[1],
                        i = e[2],
                        j = e[3];
                    (repos_shape(c, f - c.x, g - c.y),
                        resize_shape(c, i - c.width, j - c.height),
                        position_texts(c.id),
                        a.forEach(function (a) {
                            return path.recalc_connections(a.id, !0, !0);
                        }),
                        to_canvas.set_canvas());
                });
            }
            var c = {};
            if (
                ((B = a.filter(function (a) {
                    return (
                        "text" != a.iama &&
                        "path_group" != a.iama &&
                        !a.bound &&
                        "drawing" != a.iama
                    );
                })),
                0 == B.length)
            )
                return (
                    text_to_feedback_pane([
                        "Could not find shapes to align in group",
                        "(you cannot align texts or paths).",
                    ]),
                    !1
                );
            (B.forEach(function (a) {
                return (c[a.id] = [a.x, a.y, a.width, a.height]);
            }),
                (C = {}),
                B.forEach(function (a) {
                    var b = z(a);
                    C[b.me.id] = b;
                }),
                B.forEach(function (a) {
                    f(C[a.id]);
                }),
                y(C));
            var e = q(C)
                    .sort(function (c, a) {
                        return c[0].y - a[0].y;
                    })
                    .map(function (a) {
                        return a.sort(function (c, a) {
                            return c.x - a.x;
                        });
                    }),
                g = r(C)
                    .sort(function (c, a) {
                        return c[0].x - a[0].x;
                    })
                    .map(function (a) {
                        return a.sort(function (c, a) {
                            return c.y - a.y;
                        });
                    });
            if ((manage_groups.reset(!1), e.forEach(t), g.forEach(u), !m(e, g)))
                return (b(B, c), !1);
            ((canvas_status.align_on = !0),
                e.forEach(o),
                g.forEach(p),
                Object.values(C).forEach(function (a) {
                    return position_texts(a.me.id);
                }),
                text_for_render.invalidate_sorted(),
                render_all(!1, !1, !0));
            var h = function a() {
                ((canvas_status.align_on = !1),
                    n(B),
                    b(B, c),
                    render_all(!1, !1, !0),
                    manage_groups.toggle_elements(B));
            };
            return (
                align_update_messager.add_message(h, function () {
                    ((canvas_status.align_on = !1),
                        n(B),
                        manage_groups.toggle_elements(B));
                }),
                B.forEach(function (a) {
                    return path.recalc_connections(a.id, !0, !0);
                }),
                to_canvas.set_canvas(),
                !0
            );
        }
        var B, C;
        return { has_overlap: a, rects_overlap: b, align: A };
    })()),
        (document.querySelector("#form_align_group").onclick = function (a) {
            return 0 == align_update_messager.message_count()
                ? void group_aligner.align(manage_groups.get_current_group())
                : (text_to_feedback_pane(
                      [
                          "can only align one group at a time.",
                          "Reset or keep current alignment first",
                      ],
                      !0,
                      4e3,
                  ),
                  !1);
        }));
    ("use strict");
    function _toConsumableArray(a) {
        return (
            _arrayWithoutHoles(a) ||
            _iterableToArray(a) ||
            _unsupportedIterableToArray(a) ||
            _nonIterableSpread()
        );
    }
    function _nonIterableSpread() {
        throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _iterableToArray(a) {
        if (
            ("undefined" != typeof Symbol && null != a[Symbol.iterator]) ||
            null != a["@@iterator"]
        )
            return Array.from(a);
    }
    function _arrayWithoutHoles(a) {
        if (Array.isArray(a)) return _arrayLikeToArray(a);
    }
    function _slicedToArray(a, c) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, c) ||
            _unsupportedIterableToArray(a, c) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(c, e) {
        if (c) {
            if ("string" == typeof c) return _arrayLikeToArray(c, e);
            var a = {}.toString.call(c).slice(8, -1);
            return (
                "Object" === a && c.constructor && (a = c.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(c)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(c, e)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(c, f) {
        (null == f || f > c.length) && (f = c.length);
        for (var g = 0, h = Array(f); g < f; g++) h[g] = c[g];
        return h;
    }
    function _iterableToArrayLimit(c, g) {
        var h =
            null == c
                ? null
                : ("undefined" != typeof Symbol && c[Symbol.iterator]) ||
                  c["@@iterator"];
        if (null != h) {
            var j,
                k,
                l,
                m,
                p = [],
                a = !0,
                q = !1;
            try {
                if (((l = (h = h.call(c)).next), 0 === g)) {
                    if (Object(h) !== h) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (j = l.call(h)).done) &&
                        (p.push(j.value), p.length !== g);
                        a = !0
                    );
            } catch (a) {
                ((q = !0), (k = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != h["return"] &&
                        ((m = h["return"]()), Object(m) !== m)
                    )
                        return;
                } finally {
                    if (q) throw k;
                }
            }
            return p;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function show_typed(a) {
        var c = "";
        return (
            a.ctrlKey && (c += "control "),
            a.shiftKey && (c += "shift "),
            a.altKey && (c += "alt "),
            a.shiftKey &&
                a.ctrlKey &&
                "Shift" == a.key &&
                text_to_demo_pane("control + shift", !1, 1400),
            a.shiftKey &&
                a.ctrlKey &&
                "Control" == a.key &&
                text_to_demo_pane("shift + control", !1, 1400),
            "Shift" != a.key &&
                "Control" != a.key &&
                void ((c += a.key), text_to_demo_pane(c, !1, 1400))
        );
    }
    var key_pressed = [];
    function handle_keyboard(a) {
        function c() {
            return key_pressed[38]
                ? 0
                : key_pressed[40]
                  ? 2
                  : key_pressed[37]
                    ? 3
                    : key_pressed[39]
                      ? 1
                      : void 0;
        }
        function e() {
            var e = find_border_by_id(
                    "text" == currentElement.iama
                        ? currentElement.border_id
                        : currentElement.id,
                ),
                f = posit2.get_top_left(e, !0),
                g = posit2.get_w_h(e),
                i = _slicedToArray(g, 2),
                j = i[0],
                k = i[1],
                h = _slicedToArray(f, 2),
                l = h[0],
                m = h[1],
                n = _.any(key_pressed.slice(37, 41)) ? c() : 2,
                o = infinity.get_standard_scaling(6);
            (0 == n && (last_pos = [l, m - 4 * o]),
                1 == n && (last_pos = [l + j + o, m]),
                2 == n && (last_pos = [l, m + k + o]),
                3 == n && (last_pos = [l - 4 * o, m]),
                (last_pos = to_discrete_position(last_pos)),
                to_canvas.set_canvas(),
                gui_cursor.stop_cursor(),
                gui_buttons.add_location_circle(),
                a.preventDefault());
        }
        if (
            "INPUT" == document.activeElement.tagName ||
            "SELECT" == document.activeElement.tagName ||
            "TEXTAREA" == document.activeElement.tagName
        )
            return !0;
        if (canvas_status.draw_mode)
            return (handle_key_down_for_draw_mode(a), !1);
        var f = "keydown" == a.type;
        if (((key_pressed[a.keyCode] = f), "Dead" == a.key)) return !1; //if (e.keyCode ==9 && e.target.id =='flash_card_val_to_check' ) return true
        //Escape: abort//abort copy element, morph element, drag_select, etc
        if (27 == a.keyCode && f) return keyboard_cancel();
        if (slide_manager.slide_show_on())
            return (handle_slide_show_key_events(a), !1);
        if ("canvas" == currentElement.iama && arrow_key_pressed())
            return (handle_key_down_canvas_transform(a), !1);
        if (canvas_status.view_mode)
            return (handle_view_mode_key_events(a), !1);
        if (key_pressed[18]) {
            //alt alt+1 tm alt+5 gebrukt als sneltoets voor wijzigen font size via predefined sizes
            //49 =1
            var g = -1;
            if (
                (key_pressed[49]
                    ? (g = 0)
                    : key_pressed[50]
                      ? (g = 1)
                      : key_pressed[51]
                        ? (g = 2)
                        : key_pressed[52]
                          ? (g = 3)
                          : key_pressed[53] && (g = 4),
                -1 != g &&
                    (gui_cursor.clear_cursor(),
                    a.shiftKey
                        ? 4 != g &&
                          (infinity.change_shape_level(currentElement, "L" + g),
                          set_current_element(currentElement, !0),
                          text_to_feedback_pane("changed to L" + g))
                        : "border" == currentElement.iama ||
                            "text" == currentElement.iama
                          ? (change_font_class(g),
                            text_to_feedback_pane(
                                "changed to font " +
                                    ["XL", "L", "R", "S", "XS"][g],
                            ),
                            set_current_element(currentElement, !0))
                          : text_to_feedback_pane(
                                "select shape with text first",
                            )),
                !arrow_key_pressed())
            )
                return !1; //if (!e.ctrlKey) return false //alt control mogeljk gebruikt voor arrow_position of arrow_resize
        }
        if (f && (gui_cursor.cursor_on() || gui_cursor.has_selection())) {
            var h = handle_key_down_for_cursor(a);
            if (
                (demo_mode &&
                    h &&
                    ("Enter" == a.key
                        ? text_to_demo_pane("Enter", !1, 1300)
                        : "Backspace" == a.key ||
                            "Delete" == a.key ||
                            arrow_key_pressed()
                          ? show_typed(a)
                          : "x" == a.key && a.ctrlKey
                            ? text_to_demo_pane("control x", !1, 1500)
                            : text_to_demo_pane("typing....", !1, 400)),
                h)
            )
                return !1;
        }
        if (
            (demo_mode && f && show_typed(a),
            f && key_pressed[16] && 17 == a.keyCode)
        )
            return (drag_draw_on(), !1); //handle poly point, shift up, control up
        if (!f && poly_draw && (17 == a.keyCode || 16 == a.keyCode)) {
            if (17 != a.keyCode)
                16 == a.keyCode &&
                    1 < points_for_poly.length &&
                    (make_line_drawing(points_for_poly),
                    set_current_element(b));
            else if (2 < points_for_poly.length) {
                var i = make_poly_points(points_for_poly);
                (gui_buttons.clear(), set_current_element(i));
            }
            ((points_for_poly = []), (poly_draw = !1));
        }
        if ("Enter" == a.key && "keydown" == a.type)
            return (add_par_and_position_cursor(currentElement), !1); //control \ voor groeperen shape
        //control >  vervanger van tab
        if (
            (key_pressed[17] &&
                key_pressed[220] &&
                (currentElement || "mainsvg" != currentElement.id) &&
                manage_groups.toggle_element(currentElement),
            key_pressed[17] &&
                key_pressed[190] &&
                "text" == currentElement.iama)
        )
            return (
                (currentElement.text =
                    "&nbsp;&nbsp;&nbsp;&nbsp" + currentElement.text),
                !1
            ); // contextmeny via control ` (control backslash)
        // if (key_pressed[17] && key_pressed[192]){
        // 	var bbox = currentElement.getBoundingClientRect()
        // 	var event = new MouseEvent('contextmenu', {
        // 		view: window,
        // 		bubbles: true,
        // 		cancelable: true,
        // 		target : currentElement,
        // 		clientX: bbox.left + bbox.width/2,
        // 		clientY: bbox.top + bbox.height/2
        // 	  })
        // 	//cmm.display_fs_for_current_element([150, 150], event);
        // 	currentElement.dispatchEvent(event);
        // }
        if ("keydown" == a.type) {
            if ((key_pressed[17] && key_pressed[70]) || key_pressed[114])
                return (show_search_form(), a.preventDefault(), !1); //F2 = save
            if (113 == a.keyCode && !more_than_n_key_pressed(1))
                return (
                    setTimeout(
                        function () {
                            (local_store.quick_save(), (key_pressed = []));
                        }.bind(this),
                        50,
                    ),
                    !1
                ); //F6 toggle advanced options menu
            if (117 == a.keyCode && !more_than_n_key_pressed(1))
                return (
                    toggle_advanced_options(),
                    (key_pressed = []),
                    a.preventDefault(),
                    !1
                ); //F7 = toggle fine resize
            if (118 == a.keyCode && !more_than_n_key_pressed(1)) {
                var j = toggle_size_fine();
                return (
                    text_to_feedback_pane(
                        "fine resize is " + (j ? "on" : "off"),
                    ),
                    (key_pressed = []),
                    !1
                );
            } //F8 = toggle fine position
            if (119 == a.keyCode && !more_than_n_key_pressed(1)) {
                var k = toggle_move_fine();
                return (
                    text_to_feedback_pane(
                        "fine position is " + (k ? "on" : "off"),
                    ),
                    (key_pressed = []),
                    !1
                );
            } //F9 = toggle Slide / edit menu
            if (120 == a.keyCode && !more_than_n_key_pressed(1))
                return (toggle_slide_edit_menu(), (key_pressed = []), !1); //F10 = side_bar_toggle
            if (121 == a.keyCode && !more_than_n_key_pressed(1))
                return (
                    toggle_side_bar(),
                    a.preventDefault(),
                    (key_pressed = []),
                    !1
                ); //F12 = toggle view mode
            if (123 == a.keyCode && !more_than_n_key_pressed(1))
                return (
                    canvas_status.view_mode ? view_mode_off() : view_mode_on(),
                    a.preventDefault(),
                    (key_pressed = []),
                    !1
                ); //control + q undoer.undo
            if (key_pressed[17] && key_pressed[81]) return (undoer.undo(), !1); // control + f
            if (key_pressed[17] && key_pressed[70])
                //anders blijven keys hangen na zoeken
                return ((key_pressed = []), !1); //CONTROL + SHIFT  >> drag select of draw mode
            if (
                key_pressed[16] &&
                key_pressed[17] &&
                !more_than_n_key_pressed(2)
            ) {
                // && !currentElement.hasAttribute('table') ){
                if (16 != a.keyCode) drag_draw_on();
                else if (slides_mode) drag_slides_on();
                else {
                    if (canvas_status.align_on)
                        return (
                            text_to_feedback_pane(
                                "Cannot group now: reset or keep current group alignment first",
                            ),
                            !1
                        );
                    drag_select_on();
                }
                return !1;
            } //tab > selecteer mainsvg
            if (key_pressed[9] && !more_than_n_key_pressed(1)) {
                //&& _.any(key_pressed.slice(37,41) )    ) {
                if ("canvas" == currentElement.iama) {
                    var l = find_closest_neighbour(
                        {
                            x: last_pos[0],
                            y: last_pos[1],
                            width: 25,
                            height: 25,
                        },
                        2,
                    );
                    l
                        ? (set_current_element(find_border_by_id(l)),
                          gui_buttons.frame_element(currentElement))
                        : (to_canvas.set_reverse(),
                          gui_buttons.frame_element(currentElement));
                } else e();
                return !1;
            }
            if (key_pressed[9] && _.any(key_pressed.slice(37, 41)))
                return (e(), !1); //tab + shift  => selecteer parent van paragraaf en andersom
            if (9 == a.keyCode && key_pressed[16]) {
                if ("text" == currentElement.iama)
                    (set_current_element(
                        find_border_by_id(currentElement.border_id),
                    ),
                        gui_cursor.clear(),
                        gui_buttons.frame_element(currentElement));
                else if ("border" == currentElement.iama) {
                    var m = get_chunks_by_par(currentElement.id);
                    (set_current_element(m[0][0].parts[0]),
                        gui_buttons.frame_element(currentElement));
                } else return !1;
                return (a.preventDefault(), !1);
            }
            if (
                key_pressed[17] &&
                key_pressed[67] &&
                _.any(key_pressed.slice(37, 41))
            ) {
                //control + c + arrow
                if ("border" != currentElement.iama)
                    return (
                        text_to_feedback_pane(
                            "cannot copy this shape with connection. Use control x + arrowkey instead",
                            !0,
                        ),
                        !1
                    );
                var n = get_pos_from_direction(currentElement, a.keyCode),
                    o = currentElement,
                    p = copy_prepped_shape_to_canvas(currentElement, n);
                return (
                    p &&
                        path.make_new_connection(
                            o,
                            p,
                            document.querySelector("#form_always_add_arrow")
                                .checked,
                        ),
                    set_current_element(p),
                    gui_buttons.frame_element(currentElement),
                    render(),
                    (canvas_status.copy_on = !1),
                    (el_to_copy = !1),
                    !1
                );
            }
            if (
                key_pressed[17] &&
                key_pressed[88] &&
                _.any(key_pressed.slice(37, 41))
            ) {
                //control + x + arrow
                var n = get_pos_from_direction(currentElement, a.keyCode),
                    p = copy_prepped_shape_to_canvas(currentElement, n);
                return (
                    set_current_element(p),
                    gui_buttons.frame_element(currentElement),
                    render(),
                    !1
                );
            }
            if (key_pressed[17] && key_pressed[66])
                return (make_ready_for_cross_window_copy(), !1);
            if (key_pressed[17] && key_pressed[67])
                return (make_ready_for_copy(!1), a.preventDefault(), !1);
            if (key_pressed[17] && key_pressed[83])
                return (
                    a.preventDefault(),
                    style_copier.setup_style_copy(),
                    text_to_feedback_pane(
                        "click another ".concat(A, " to copy style to it"),
                    ),
                    (key_pressed = []),
                    !1
                );
            if (key_pressed[17] && key_pressed[86])
                //control V >> moet via andere handlers opgepikt worden
                return !0; //add new shape
            if (
                !key_pressed[17] &&
                ((47 < a.keyCode && 91 > a.keyCode) ||
                    (96 <= a.keyCode && 111 >= a.keyCode) ||
                    (186 <= a.keyCode && 192 >= a.keyCode) ||
                    (219 <= a.keyCode && 222 >= a.keyCode) ||
                    220 == a.keyCode) &&
                last_pos
            ) {
                if ("border" == currentElement.iama)
                    add_text_to_shape(currentElement, a.key);
                else if ("path_group" == currentElement.iama) {
                    var q = currentElement.id,
                        r = get_new_shape_with_text(a.key, !0),
                        s = _slicedToArray(r, 2),
                        u = s[0],
                        v = s[1];
                    ((u.path_id = q),
                        (u.pos_perc = 0.5),
                        (u.bound = !0),
                        set_current_element(u));
                } else {
                    var w = get_new_shape_with_text(a.key),
                        x = _slicedToArray(w, 2),
                        y = x[0],
                        z = x[1];
                    set_current_element(z);
                }
                return !1;
            }
            var A = currentElement.iama; //delete backspace
            if (key_pressed[46] || key_pressed[8])
                //exit omdat anders paragraaf / text wordt verwijderd
                return key_pressed[16] || "text" != A
                    ? (delete_shape(currentElement),
                      a.stopPropagation(),
                      a.preventDefault(),
                      to_canvas.set_canvas(),
                      !1)
                    : (text_to_feedback_pane(
                          [
                              "press shift delete or shift backspace to remove this item",
                              "(to avoid accidental deletes when typing)",
                          ],
                          !1,
                          !0,
                      ),
                      !1);
            if (
                key_pressed[17] &&
                !key_pressed[16] &&
                _.any(key_pressed.slice(37, 41))
            )
                //render();
                return (
                    path.change_collision_detection.turn_off_temporary(),
                    arrow_resize_element(
                        a.keyCode,
                        a.getModifierState("CapsLock"),
                        a.altKey,
                    ),
                    path.change_collision_detection.restore(),
                    !1
                );
            if (
                key_pressed[16] &&
                !key_pressed[17] &&
                _.any(key_pressed.slice(37, 41)) &&
                "P" != currentElement.tagName
            ) {
                d = c();
                var B = find_closest_neighbour(currentElement, d);
                return (
                    B &&
                        (set_current_element(
                            shapes_storage.search_shapes_with_id(B),
                        ),
                        display_fs_for_shape(currentElement),
                        update_open_fs(currentElement),
                        cc.clear_canvas(gui_context),
                        gui_buttons.frame_element(currentElement)),
                    !1
                );
            }
            if (A && "path_group" != A && _.any(key_pressed.slice(37, 41)))
                //render();
                return (
                    path.change_collision_detection.turn_off_temporary(),
                    arrow_position_element(
                        a.keyCode,
                        a.getModifierState("CapsLock"),
                        a.altKey,
                    ),
                    path.change_collision_detection.restore(),
                    !1
                );
        }
    }
    function add_text_to_shape(a, c, e) {
        var f = add_paragraph_to_shape(a, void 0, e);
        return (
            add_text_to_paragraph(f, c),
            position_texts(f.parent.border_id),
            gui_buttons.clear(),
            set_current_element(f),
            f
        );
    }
    function keyboard_cancel() {
        return cmm.status()
            ? (cmm.off(), !1)
            : (canvas_status.slide_exclusion_mode
                  ? exit_slide_exclusion_mode()
                  : slide_manager.slide_show_on()
                    ? slide_manager.end_slide_show()
                    : canvas_status.draw_mode
                      ? drag_draw_off()
                      : canvas_status.copy_on
                        ? ((canvas_status.copy_on = !1),
                          text_to_feedback_pane("aborting copy"))
                        : canvas_status.drag_select
                          ? drag_select_off()
                          : style_copier.is_on()
                            ? text_to_feedback_pane("aborting style copy")
                            : canvas_status.search_form
                              ? hide_search_form()
                              : canvas_status.slide_mode
                                ? drag_slides_off()
                                : canvas_status.export_mode
                                  ? drag_export_off()
                                  : 0 <
                                        manage_groups.get_current_group()
                                            .length && manage_groups.reset(),
              style_copier.cancel(),
              (key_pressed = []),
              !1);
    }
    function more_than_n_key_pressed(a) {
        for (var c = 0, e = 0; e < key_pressed.length; e++)
            if ((key_pressed[e] && (c += 1), c > a)) return !0;
        return !1;
    }
    function F_key() {
        //true als een of meerdere F1 tm F12 zijn ingedrukt, anders false
        //f1=112 tm  f12 =123
        for (var a = 112; 124 > a; a++) if (key_pressed[a]) return !0;
        return !1;
    }
    var marge_for_copy = parseInt(40 / mdd) * mdd;
    function get_pos_from_direction(a, c) {
        var e = posit2.get_top_left(a, !0),
            f = _slicedToArray(e, 2),
            g = f[0],
            i = f[1],
            j = posit2.get_w_h(a),
            k = _slicedToArray(j, 2),
            l = k[0],
            m = k[1],
            h = 0,
            n = 0;
        return (
            37 == c && (h = round_to_mdd_with_minimum(-l - marge_for_copy)),
            38 == c && (n = round_to_mdd_with_minimum(-m - marge_for_copy)),
            39 == c && (h = round_to_mdd_with_minimum(l + marge_for_copy)),
            40 == c && (n = round_to_mdd_with_minimum(m + marge_for_copy)),
            [g + h, i + n]
        );
    }
    function round_to_mdd_with_minimum(a) {
        return a / mdd == parseInt(a / mdd)
            ? parseInt(a / mdd) * mdd
            : (parseInt(a / mdd) + 1 * Math.sign(a)) * mdd;
    }
    function get_deltaxy_from_key_press(a) {
        var c = 0,
            e = 0; //rechts
        return (
            38 == a && (e = -1),
            40 == a && (e = 1),
            37 == a && (c = -1),
            39 == a && (c = 1),
            [c, e]
        );
    }
    function handle_key_down_for_cursor(a) {
        function c(a) {
            var c = currentElement.parent;
            (swap_line(c.border_id, c.par_num, c.par_num + a),
                position_texts(c.border_id),
                render(),
                gui_cursor.set_cursor_by_index(c.parts[0], 0),
                gui_buttons.frame_element(c.parts[0]));
        } //return true als key geconsumeerd, anders false
        // 112 tm 123 f1 tm f12
        // 37TM 40 arrows
        // 96 tm 105: numpad 0 tm numpad 9;
        // backspace	8
        // tab	9
        // enter	13
        // shift	16
        // ctrl	17
        // alt	18
        // pause/break	19
        // caps lock	20
        // escape	27
        // page up	33
        // page down	34
        // end	35
        // home	36
        // insert	45
        // delete	46
        //te tekenen
        // 48 tm 90: 0 tm z
        // multiply	106
        // add	107
        // subtract	109
        // decimal point	110
        // divide	111
        // semi-colon	186
        // equal sign	187
        // comma	188
        // dash	189
        // period	190
        // forward slash	191
        // grave accent	192
        // open bracket	219
        // back slash	220
        // close braket	221
        // single quote	222
        //shift select
        // control c, control v;
        //control arrow, volgende word boundary
        if (key_pressed[17]) {
            //control
            if (key_pressed[67] && gui_cursor.has_selection())
                return (gui_cursor.handle_text_copy(), !0);
            if (key_pressed[88] && gui_cursor.has_selection())
                return (gui_cursor.handle_text_cut(), !0);
            if (key_pressed[86])
                //v
                return (
                    !!gui_cursor.has_range_to_paste() &&
                    (gui_cursor.handle_text_paste(), !0)
                );
            if (key_pressed[65])
                return (gui_cursor.select_all_text_in_par_from_cursor(), !0);
            if (arrow_key_pressed())
                return (
                    change_par_margin.apply(
                        void 0,
                        [currentElement].concat(
                            _toConsumableArray(
                                get_deltaxy_from_key_press(a.keyCode),
                            ),
                        ),
                    ),
                    !0
                );
            if (key_pressed[66]) return (add_styling_to_par("bold"), !0);
            if (key_pressed[73]) return (add_styling_to_par("italic"), !0);
            if (key_pressed[83])
                //s
                return !1;
        }
        if (key_pressed[16] && (key_pressed[46] || key_pressed[8])) {
            // delete paragraph
            var e = gui_cursor.get_cursor().chunk;
            return (
                delete_shape(e),
                position_texts(e.border_id),
                gui_cursor.clear(),
                set_current_element(find_border_by_id(e.border_id)),
                !0
            );
        } //wat is 108
        if (
            (48 <= a.keyCode && 90 >= a.keyCode) ||
            (96 <= a.keyCode && 111 >= a.keyCode) ||
            (186 <= a.keyCode && 192 >= a.keyCode) ||
            (219 <= a.keyCode && 222 >= a.keyCode) ||
            32 == a.keyCode
        )
            return (
                cc.status().gui_canvas || gui_buttons.clear(),
                gui_cursor.insert_text(a.key),
                render(),
                !0
            );
        if ("Enter" == a.key) return (gui_cursor.handle_new_line(), !0);
        if (37 == a.keyCode) {
            //arrowleft
            if (a.shiftKey) gui_cursor.range_backward();
            else if (gui_cursor.cursor_on()) gui_cursor.move_cursor_backward();
            else {
                var f = gui_cursor.get_range(),
                    g = f.before.chunk.parts.slice(-1)[0],
                    h = f.before.before_index;
                (gui_cursor.clear(),
                    gui_cursor.set_cursor_by_index(g, h),
                    gui_cursor.start_cursor());
            }
            return !0;
        }
        if (39 == a.keyCode) {
            //arrow right
            if (a.shiftKey) gui_cursor.range_forward();
            else if (gui_cursor.cursor_on()) gui_cursor.move_cursor_forward();
            else {
                var i = gui_cursor.get_range(),
                    j = i.after.chunk.parts[0],
                    k = i.after.after_index;
                (gui_cursor.clear(),
                    gui_cursor.set_cursor_by_index(j, k),
                    gui_cursor.start_cursor());
            }
            return !0;
        }
        return 40 == a.keyCode
            ? (a.shiftKey
                  ? c(1)
                  : select_line_with_arrow(
                        currentElement.border_id,
                        gui_cursor.get_part_from_cursor(),
                        !0,
                    ),
              !0)
            : 38 == a.keyCode
              ? (a.shiftKey
                    ? c(-1)
                    : select_line_with_arrow(
                          currentElement.border_id,
                          gui_cursor.get_part_from_cursor(),
                          !1,
                      ),
                !0)
              : 35 == a.keyCode
                ? (key_pressed[16]
                      ? gui_cursor.range_to_end()
                      : gui_cursor.move_cursor_to_end(),
                  !0)
                : 36 == a.keyCode
                  ? (key_pressed[16]
                        ? gui_cursor.range_to_start()
                        : gui_cursor.move_cursor_to_start(),
                    !0)
                  : 8 == a.keyCode
                    ? (gui_cursor.backspace(), render(), !0)
                    : 46 == a.keyCode && (gui_cursor["delete"](), render(), !0);
    }
    function arrow_key_pressed() {
        return _.any(key_pressed.slice(37, 41));
    }
    function handle_key_down_for_draw_mode(a) {
        a.shiftKey
            ? (start_new_draw_group(),
              render_current_draw_group(context_single),
              text_to_feedback_pane("ready new drawing"))
            : 27 == a.keyCode && "keydown" == a.type && keyboard_cancel();
    }
    function handle_key_down_canvas_transform(a) {
        var c = 1.06,
            e = get_deltaxy_from_key_press(a.keyCode),
            f = _slicedToArray(e, 2),
            g = f[0],
            h = f[1];
        if (a.shiftKey) {
            //https://stackoverflow.com/questions/2916081/zoom-in-on-a-point-using-scale-and-translate/30410948#30410948
            var i = 1 == g + h ? transform.k * c : transform.k / c;
            delta_k = i - transform.k;
            var j = last_pos[0] * delta_k,
                k = last_pos[1] * delta_k;
            set_zoom_and_trans(transform.x - j, transform.y - k, i);
        } else if (a.ctrlKey) {
            var l = 0.04 * (g * canvas_width),
                m = 0.04 * (h * canvas_height);
            ((last_pos[0] += l / transform.k),
                (last_pos[1] += m / transform.k),
                gui_buttons.add_location_circle());
        } else {
            var n = 0.04 * (g * canvas_width),
                o = 0.04 * (h * canvas_height),
                p = transform.x - n,
                q = transform.y - o;
            (set_zoom_and_trans(p, q, transform.k),
                (last_pos[0] += n / transform.k),
                (last_pos[1] += o / transform.k),
                gui_buttons.add_location_circle());
        }
    }
    ((window.onblur = function () {
        key_pressed = [];
    }),
        (window.onfocus = function () {
            key_pressed = [];
        }));
    function handle_view_mode_key_events(a) {
        return 123 != a.keyCode ||
            "keydown" != a.type ||
            more_than_n_key_pressed(1)
            ? (key_pressed[17] && key_pressed[70]) || key_pressed[114]
                ? (show_search_form(), a.preventDefault(), !1)
                : void 0
            : (canvas_status.view_mode ? view_mode_off() : view_mode_on(),
              a.preventDefault(),
              (key_pressed = []),
              !1);
    } //TODO1 alt drag in firefox toggled menu bar.... gebeurt niet bij alt font size aanpassingen
    //lijkt opgelost, nog een keer controleren
    //TODO firefox controleren of context wijziging bij rendering vertragend werkt
    //TODO geen paste bn als canvas niet actieve shape is...
    //wordt nu soms gekopieerd in een paragraaf als json
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    var gui_cursor = (function (a) {
        //is geen range maar gewoon een text string die zonder style wordt geplakt
        function b() {
            var b = X.chunk.font_size,
                c = X.pos[0],
                d = X.pos[1]; //+  cursor.part.baseline_offset - font_size;
            if (canvas_status.mobile_mode)
                return display_cursor_mobile_mode(b, c, d);
            (a.save(),
                a.beginPath(),
                a.translate(transform.x, transform.y),
                a.scale(transform.k, transform.k));
            var e =
                1 < transform.k
                    ? Math.max(0.4, round_to(3 / transform.k, 1))
                    : 3;
            (a.rect(c, d, e, b),
                a.fill(),
                a.restore(),
                (V = !0),
                cc.set_has_ink(a));
        }
        function c() {
            (a.save(),
                a.translate(transform.x, transform.y),
                a.scale(transform.k, transform.k));
            var b = X.pos[0],
                c = X.pos[1] + X.part.baseline_offset - X.chunk.font_size;
            (a.clearRect(b - 2, c - 2, 7, X.chunk.font_size + 4), a.restore());
        }
        function d(a) {
            (($ = !1),
                Y || (Y = a),
                c(),
                a - Y > 500 && ((Z = !Z), (Y = a)),
                Z && b(),
                (W = requestAnimationFrame(d)));
        }
        function e() {
            ($ && (window.clearTimeout($), ($ = !1)),
                V &&
                    (window.cancelAnimationFrame(W),
                    (W = !1),
                    (V = !1),
                    cc.clear_canvas(cursor_context)));
        }
        function f(a, b) {
            var d = a.indexOf(b);
            return d + 1 < a.length ? d + 1 : -1;
        }
        function g(a, b) {
            var d = a.indexOf(b);
            return 0 <= d - 1 ? d - 1 : -1;
        }
        function h(a) {
            var b = get_chunks_in_par(X.chunk.border_id, X.chunk.par_num);
            if (1 == b.length)
                a = Math.max(Math.min(a, X.chunk.text.length), 0);
            else if (a > X.chunk.text.length) {
                var c = f(b, X.chunk);
                -1 == c
                    ? (a = Math.max(Math.min(a, X.chunk.text.length), 0))
                    : ((a = 1), (X.chunk = b[c]));
            } else if (0 > a) {
                var d = g(b, X.chunk);
                -1 == d
                    ? (a = Math.max(Math.min(a, X.chunk.text.length), 0))
                    : ((a = b[d].text.length - 1), (X.chunk = b[d]));
            }
            var e = t(X.chunk, a),
                h = _slicedToArray(e, 2),
                i = h[0],
                j = h[1],
                k = measure_par_width_at_each_letter(i).map(function (a) {
                    return a + i.x;
                });
            ((X.pos = [k[j], i.y]), (X.part = i), (X.index = u(i, j)));
        }
        function j(a, b) {
            var c = measure_par_width_at_each_letter(a).map(function (b) {
                    return b + a.x;
                }),
                d = c[b];
            ((X.pos = [d, a.y]),
                (X.chunk = a.parent),
                (X.part = a),
                (X.index = u(a, b)));
        }
        function k(a, b, c) {
            var d = s(a, b, c),
                e = _slicedToArray(d, 2),
                f = e[0],
                g = e[1];
            f
                ? (set_current_element(f), j(f, g), G())
                : (P(), cc.clear_canvas(gui_context), to_canvas.set_canvas());
        }
        function l(a, b) {
            for (
                var c = 0;
                c < a.length - 1 && !(a[c] + (a[c + 1] - a[c]) / 4 > b);
                c++
            );
            return [a[c], c];
        } //after = before -1
        function m() {
            ((aa = !1), cc.clear_canvas(a));
        }
        function n(a) {
            var b =
                    !!(1 < arguments.length && arguments[1] !== void 0) &&
                    arguments[1],
                c = get_chunks_by_par(X.chunk.border_id),
                d = 1 == c[a.par_num].length; //const is_only_chunk = Object.keys(chunks).length ==1 && chunks[0].length==1
            if (d)
                ((X.chunk.text = ""),
                    position_texts(X.chunk.border_id),
                    j(X.chunk.parts[0], 0));
            else {
                var e = r();
                (shapes_storage.remove(a),
                    check_par_for_chunk_style_equality(a.border_id, a.par_num),
                    reset_chunk_numbering(a.border_id, a.par_num),
                    P(),
                    cc.clear_canvas(gui_context),
                    k(e, a.border_id, a.par_num));
            }
        } //TODO9 merge pars voor delete nog toevoegen
        function o() {
            if (1 == X.chunk.text.length) n(X.chunk);
            else {
                ((X.chunk.text =
                    X.chunk.text.slice(0, X.index) +
                    X.chunk.text.slice(X.index + 1)),
                    position_texts(X.chunk.border_id));
                var a = t(X.chunk, X.index),
                    b = _slicedToArray(a, 2),
                    c = b[0],
                    d = b[1];
                j(c, d);
            }
        }
        function p() {
            if (1 == X.chunk.text.length && 0 != X.index)
                return (n(X.chunk, !0), !1);
            if (0 == X.chunk.text.length) return !1;
            if ((c(), 0 < X.index)) {
                ((X.chunk.text =
                    X.chunk.text.slice(0, X.index - 1) +
                    X.chunk.text.slice(X.index)),
                    position_texts(X.chunk.border_id));
                var a = t(X.chunk, X.index - 1),
                    b = _slicedToArray(a, 2),
                    d = b[0],
                    e = b[1];
                j(d, e);
            } else {
                var f = get_chunks_in_par(X.chunk.border_id, X.chunk.par_num),
                    h = g(f, X.chunk);
                if (-1 != h)
                    (j(f[h].parts.slice(-1)[0], f[h].text.length), p());
                else if (0 < X.chunk.par_num) {
                    var i = X.chunk.par_num,
                        l = get_chunks_in_par(X.chunk.border_id, i - 1).slice(
                            -1,
                        )[0].text.length;
                    (q(X.chunk.border_id, i - 1, X.chunk.par_num),
                        k(l, X.chunk.border_id, i - 1));
                }
            }
        }
        function q(a, b, c) {
            var d = find_border_by_id(a),
                e = get_chunks_by_par(a);
            d.num_pars -= 1;
            var f = e[b].slice(-1)[0].chunk_num;
            (e[c].forEach(function (a, c) {
                ((a.chunk_num = c + 1 + f), (a.par_num = b));
            }),
                reset_par_and_chunk_numbering(a),
                check_par_for_chunk_style_equality(a, b),
                position_texts(a));
        }
        function r() {
            for (
                var a = get_chunks_by_par(X.chunk.border_id)[X.chunk.par_num],
                    b = 0,
                    c = 0;
                c < X.chunk.chunk_num;
                c++
            )
                b += a[c].text.length;
            return ((b += X.index), b);
        }
        function s(a, b, c) {
            var d = get_chunks_by_par(b)[c];
            if (!d) return [!1, !1];
            if (
                ((total_length = d.reduce(function (a, b) {
                    return a + b.text.length;
                }, 0)),
                a > total_length - 1)
            )
                return [!1, !1];
            for (
                var e = 0, f = 0;
                f < d.length && ((e += d[f].text.length), !(e > a));
                f++
            );
            var g = d[f],
                h = a - e + g.text.length;
            e = 0;
            for (
                var f = 0;
                f < g.parts.length && ((e += g.parts[f].text.length), !(e > h));
                f++
            );
            var j = g.parts[f],
                k = h - e + j.text.length;
            return [j, k];
        }
        function t(a, b) {
            part_lengths = a.parts.map(function (a) {
                return a.text.length;
            });
            var e = 0;
            part_lengths = part_lengths.map(function (a) {
                return ((e += a), e);
            });
            var d = _.findIndex(part_lengths, function (a) {
                return a > b;
            });
            return (
                -1 == d && (d = a.parts.length - 1),
                [a.parts[d], b - [0].concat(part_lengths)[d]]
            );
        }
        function u(a, b) {
            for (
                var c = a.parent, d = c.parts.indexOf(a), e = 0, f = 0;
                f < d;
                f++
            )
                e += c.parts[f].text.length;
            return b + e;
        }
        function v() {
            var a = aa.in_selection[0],
                b = aa.in_selection.slice(-1)[0],
                c = t(a.chunk, a.after_index),
                d = _slicedToArray(c, 2),
                e = d[0],
                f = d[1],
                g = t(b.chunk, b.before_index),
                h = _slicedToArray(g, 2),
                i = h[0],
                j = h[1],
                k = measure_par_width_at_each_letter(e).map(function (a) {
                    return a + e.x;
                })[f],
                l = measure_par_width_at_each_letter(i).map(function (a) {
                    return a + i.x;
                })[j];
            ((aa.start_x = k),
                (aa.end_x = l),
                A(k, l, e, i, { fill: "rgba(0,0,360,0.10)" }));
        } //select_range
        function w(a, b, c, d, e, f) {
            //text in range: vanaf after tot before
            var g = [];
            if (a == b)
                g.push({
                    text: a.text.slice(c + 1, d),
                    chunk: a,
                    after_index: c + 1,
                    before_index: d,
                });
            else {
                var h = a.chunk_num,
                    i = b.chunk_num,
                    j = get_text_with_border_id(a.border_id).filter(
                        function (a) {
                            return a.chunk_num > h && a.chunk_num < i;
                        },
                    );
                (g.push({
                    text: a.text.slice(c + 1),
                    chunk: a,
                    after_index: c + 1,
                    before_index: -1,
                }),
                    j.forEach(function (a) {
                        g.push({
                            text: a.text,
                            chunk: a,
                            after_index: 0,
                            before_index: -1,
                        });
                    }),
                    g.push({
                        text: b.text.slice(0, d),
                        chunk: b,
                        after_index: 0,
                        before_index: d,
                    }));
            }
            aa = {
                before: {
                    chunk: a,
                    text: a.text.slice(0, c + 1),
                    after_index: 0,
                    before_index: c + 1,
                },
                after: {
                    chunk: b,
                    text: b.text.slice(d),
                    after_index: d,
                    before_index: -1,
                },
                in_selection: g,
                startx: e,
                endx: f,
            };
        }
        function x(a, b) {
            return (
                !!aa &&
                !!aa.bboxes &&
                _.any(
                    aa.bboxes.map(function (c) {
                        var d = _slicedToArray(c, 4),
                            e = d[0],
                            f = d[1],
                            g = d[2],
                            h = d[3];
                        return is_inside(
                            a,
                            b,
                            xywh_to_bbox({ x: e, y: f, width: g, height: h }),
                        );
                    }),
                )
            );
        }
        function A(a, b, c, d, e) {
            (cc.clear_canvas(cursor_context),
                cursor_context.save(),
                cursor_context.translate(transform.x, transform.y),
                cursor_context.scale(transform.k, transform.k));
            var f = render_text_selection(a, b, c, d, e, cursor_context);
            (cursor_context.restore(), T(f), cc.set_has_ink(cursor_context));
        }
        function B(a, b) {
            for (var c, d = /\s/g, e = []; null !== (c = d.exec(a)); )
                e.push(c.index);
            for (var f = 0; f < e.length && !(e[f] > b); f++);
            return 0 == e.length
                ? [0, a.length]
                : 1 == e.length
                  ? 0 == f
                      ? [0, e[0]]
                      : [e[0] + 1, a.length]
                  : 0 == f
                    ? [0, e[f]]
                    : f == e.length
                      ? [e[f - 1] + 1, a.length]
                      : [e[f - 1] + 1, e[f]]; //+1 omdat anders spatie voor woord ook in selectie komt
        }
        function C(a) {
            var b = gui_cursor.get_range();
            (b.before.chunk.border_id != currentElement.border_id &&
                set_current_element(
                    find_border_by_id(b.before.chunk.border_id),
                ),
                b.before.chunk == b.after.chunk
                    ? (b.before.chunk.text = b.before.text + a + b.after.text)
                    : (compare_styles_of_chunks(b.before.chunk, b.after.chunk)
                          ? ((b.before.chunk.text =
                                b.before.text + a + b.after.text),
                            b.in_selection.forEach(function (a) {
                                a.chunk != b.before.chunk &&
                                    shapes_storage.remove(a.chunk);
                            }))
                          : ((b.before.chunk.text = b.before.text + a),
                            (b.after.chunk.text = b.after.text),
                            b.in_selection.forEach(function (a) {
                                a.chunk != b.before.chunk &&
                                    a.chunk != b.after.chunk &&
                                    shapes_storage.remove(a.chunk);
                            })),
                      reset_par_and_chunk_numbering(b.before.chunk.border_id)),
                m(),
                measure_text(b.before.chunk),
                recalc_border_width(b.before.chunk.border_id),
                position_texts(b.before.chunk.border_id),
                j(b.before.chunk.parts[0], b.before.text.length + 1),
                G());
        }
        function D(a) {
            var c = X.chunk.text,
                d = c.slice(0, X.index),
                e = c.slice(X.index); // if (find_border_by_id(cursor.chunk.border_id).syntax_highlighted){
            //     syntax_highlight_paragraph(find_border_by_id(cursor.chunk.border_id), cursor.chunk.par_num, find_border_by_id(cursor.chunk.border_id).syntax_highlighted)
            // }
            ((X.chunk.text = d + a + e),
                measure_text(X.chunk),
                recalc_border_width(X.chunk.border_id, !1, !0, !0),
                position_texts(X.chunk.border_id),
                h(X.index + 1),
                cc.clear_canvas(cursor_context),
                b());
        }
        function E() {
            (W && window.cancelAnimationFrame(W),
                $ && window.clearTimeout($),
                ($ = setTimeout(d, 300)));
        }
        function F() {
            var a = gui_cursor.get_range(); //verwijderen van chunk waarin range zich bevindt:
            shapes_storage.remove(a.before.chunk);
            var b = get_chunks_in_par(
                a.before.chunk.border_id,
                a.before.chunk.par_num,
            ).filter(function (b) {
                return b.chunk_num > a.after.chunk.chunk_num;
            });
            delete a.before.chunk.parts;
            var c = JSON.parse(JSON.stringify(a.before.chunk));
            ((c.text = a.before.text),
                "" != c.text &&
                    ((c.x = a.before.chunk.x),
                    measure_text(c),
                    (c.chunk_num = a.before.chunk.chunk_num),
                    shapes_storage.add_text(c)));
            var d = JSON.parse(JSON.stringify(a.before.chunk));
            ((d.text = a.after.text),
                "" != d.text &&
                    (measure_text(d),
                    (d.chunk_num = a.before.chunk.chunk_num + 2),
                    shapes_storage.add_text(d)));
            var e = JSON.parse(JSON.stringify(a.before.chunk));
            return (
                (e.text = a.in_selection[0].text),
                measure_text(e),
                (e.chunk_num = a.before.chunk.chunk_num + 1),
                shapes_storage.add_text(e),
                b.forEach(function (a) {
                    return (a.chunk_num += 3);
                }),
                position_texts(a.before.chunk.border_id),
                reset_chunk_numbering(
                    a.before.chunk.border_d,
                    a.before.chunk.par_num,
                ),
                e
            );
        }
        function G() {
            (e(), canvas_status.mobile_mode ? b() : d(), (V = !0));
        }
        function H() {
            function a() {
                if ("" == aa.after.text) {
                    var a = get_chunks_in_par(
                        aa.before.chunk.border_id,
                        aa.before.chunk.par_num,
                    );
                    return (
                        !!(a.length > aa.after.chunk.chunk_num) &&
                        a[aa.after.chunk.chunk_num + 1]
                    );
                }
                return aa.after.chunk;
            }
            var b = aa.in_selection.slice(-1)[0],
                c = a();
            if (!c) return !1;
            if (c == aa.after.chunk)
                ((b.text += aa.after.text[0]),
                    (aa.after.text = aa.after.text.slice(1)),
                    (b.before_index += 1),
                    (aa.after.after_index += 1));
            else {
                var d = {
                    chunk: c,
                    text: c.text[0],
                    after_index: -1,
                    before_index: 1,
                };
                ((aa.after = {
                    chunk: c,
                    text: c.text.slice(1),
                    after_index: 1,
                    before_index: c.text.length,
                }),
                    aa.in_selection.push(d));
            }
            v();
        }
        function I() {
            var a = aa.in_selection.slice(-1)[0];
            if ("" == a.text) {
                if (1 == aa.in_selection.length)
                    //leeg, cursor instellen
                    return !1;
                ((aa.after = {
                    text: a.chunk.text,
                    chunk: a.chunk,
                    before_index: a.chunk.text.length,
                    after_index: 0,
                }),
                    aa.in_selection.pop(),
                    (a = aa.in_selection.slice(-1)[0]),
                    (a.before_index = a.chunk.text.length - 1));
            } else ((a.before_index -= 1), (aa.after.after_index -= 1));
            ((aa.after.text = a.text.slice(-1)[0] + aa.after.text),
                (a.text = a.text.slice(0, -1)),
                v());
        }
        function J() {
            var a = aa.in_selection.slice(-1)[0];
            ((a.text += aa.before.text.slice(-1)[0]),
                (a.after_index -= 1),
                (aa.before.text = aa.before.text.slice(0, -1)),
                (aa.before.before_index -= 1),
                v());
        }
        function K() {
            var a = aa.in_selection.slice(-1)[0];
            ((aa.before.text += a.text[0]),
                (a.text = a.text.slice(1)),
                (a.after_index += 1),
                (aa.before.before_index += 1),
                v());
        }
        function L() {
            w(X.chunk, X.chunk, X.index - 1, X.index);
        }
        function M() {
            var a = get_chunks_in_par(
                    aa.before.chunk.border_id,
                    aa.before.chunk.par_num,
                ),
                b = aa.in_selection[0].chunk,
                c = a.slice(-1)[0],
                d = aa.in_selection[0].after_index,
                e = c.text.length;
            w(b, c, d, e);
        }
        function N() {
            var a = get_chunks_in_par(
                    aa.before.chunk.border_id,
                    aa.before.chunk.par_num,
                ),
                b = a[0],
                c = aa.in_selection.slice(-1)[0].chunk,
                d = 0,
                e = aa.in_selection.slice(-1)[0].before_index;
            w(b, c, d, e);
        }
        function O() {
            var a = aa.in_selection[0].chunk,
                b = get_chunks_in_par(a.border_id, a.par_num);
            return (
                aa.in_selection.reduce(function (c, a) {
                    return c + a.text;
                }, "") ==
                b.reduce(function (c, a) {
                    return c + a.text;
                }, "")
            );
        }
        function P() {
            (e(), (X.pos = [0, 0]), (X.chunk = !1), (X.index = 0));
        }
        function Q() {
            //cursor opschuiven
            (D(ba),
                (ba = !1),
                position_texts(currentElement.border_id),
                render());
        }
        function R() {
            ((ba = S()), copy_or_cut_from_canvas(ba, "copy"));
        }
        function S() {
            return (
                (ba = aa.in_selection
                    .map(function (a) {
                        return a.text;
                    })
                    .join("")),
                ba
            );
        }
        function T(a) {
            aa.bboxes = a;
        }
        function U(a) {
            (c(), E(), h(a), b());
        }
        var V = !1,
            W = !1,
            X = { pos: [0, 0], index: 0 },
            Y = null,
            Z = !0,
            $ = !1; //context.font = '28px Arial';
        //context.textBaseline = 'top';
        a.save();
        var aa = !1,
            ba = !1;
        return {
            handle_text_paste: Q,
            handle_text_copy: R,
            handle_text_cut: function a() {
                ((ba = S()),
                    copy_or_cut_from_canvas(ba, "copy"),
                    C(""),
                    render());
            },
            handle_new_line: function a() {
                e();
                var b = 0,
                    c = Object.assign({}, X.chunk),
                    d = Object.assign({}, X.chunk);
                (shapes_storage.remove_text(X.chunk),
                    shapes_storage.add_text(d),
                    shapes_storage.add_text(c),
                    (c.text = X.chunk.text.slice(0, X.index)),
                    (d.text = X.chunk.text.slice(X.index)),
                    measure_text(c),
                    measure_text(d),
                    0 == d.text.length && (d.has_own_style = !1)); //let new_par_num = border.num_pars;
                for (
                    var f = get_chunks_in_par(
                            X.chunk.border_id,
                            X.chunk.par_num,
                        ),
                        g = f.filter(function (a) {
                            return a.chunk_num > X.chunk.chunk_num;
                        }),
                        h = find_border_by_id(X.chunk.border_id),
                        k = X.chunk.par_num,
                        l = get_chunks_by_par(X.chunk.border_id, !0),
                        m = k + 1;
                    m < h.num_pars;
                    m++
                )
                    l[m].forEach(function (a) {
                        return (a.par_num += 1);
                    });
                (g.forEach(function (a, b) {
                    ((a.par_num = k + 1), (a.chunk_num = b + 1));
                }),
                    (d.par_num = k + 1),
                    (d.chunk_num = 0),
                    (h.num_pars += 1),
                    position_texts(h.id),
                    reset_par_and_chunk_numbering(h.id),
                    d.parts
                        ? j(d.parts[0], 0)
                        : j(
                              g.sort(function (c, a) {
                                  return c.chunk_num - a.chunk_num;
                              })[0].parts[0],
                              0,
                          ),
                    G(),
                    render());
            },
            handle_double_click: function d(a, b, c) {
                e();
                var f = measure_par_width_at_each_letter(c).map(function (a) {
                        return a + c.x;
                    }),
                    g = l(f, a),
                    h = _slicedToArray(g, 2),
                    i = h[0],
                    j = h[1],
                    k = B(c.text, j),
                    m = _slicedToArray(k, 2),
                    n = m[0],
                    j = m[1],
                    o = f[n],
                    p = f[j];
                (1 < c.parent.parts.length && ((n = u(c, n)), (j = u(c, j))),
                    w(c.parent, c.parent, n - 1, j, o, p),
                    A(o, p, c, c, { fill: "rgba(0,0,360,0.10)" }));
            },
            select_all_text_in_par_from_cursor: function a() {
                var b = X.chunk,
                    c = get_chunks_in_par(b.border_id, b.par_num);
                (w(c[0], c.slice(-1)[0], -1, c.slice(-1)[0].text.length),
                    P(),
                    v());
            },
            select_all_text_in_par_from_range: function a() {
                var b = get_chunks_in_par(
                        aa.before.chunk.border_id,
                        aa.before.chunk.par_num,
                    ),
                    c = b[0],
                    d = b.slice(-1)[0];
                (w(c, d, -1, d.text.length), v());
            },
            range_contains_all_text_in_par: O,
            get_range_to_paste: function a() {
                return ba;
            },
            has_range_to_paste: function a() {
                return !!ba;
            },
            move_cursor_to_end: function a() {
                var b = X.chunk.text.length;
                (E(), h(b));
            },
            move_cursor_to_start: function a() {
                (E(), h(0));
            },
            move_cursor_backward: function a() {
                U(X.index - 1);
            },
            move_cursor_forward: function a() {
                U(X.index + 1);
            },
            range_forward: function a() {
                (V && (L(), e()), aa.cursor_at_back ? K() : H());
            },
            range_backward: function a() {
                V
                    ? (L(), e(), (aa.cursor_at_back = !0))
                    : aa.cursor_at_back
                      ? J()
                      : I();
            },
            range_to_end: function a() {
                (X && (L(), e()), aa && M(), v());
            },
            range_to_start: function a() {
                (X && (L(), e()), aa && N(), v());
            },
            xy_is_in_range: x,
            set_cursor_by_xpos: function c(a, b) {
                var d = measure_par_width_at_each_letter(a).map(function (b) {
                        return b + a.x;
                    }),
                    e = l(d, b),
                    f = _slicedToArray(e, 2),
                    g = f[0],
                    h = f[1];
                ((X.pos = [g, a.y]),
                    (X.chunk = a.parent),
                    (X.part = a),
                    (X.index = u(a, h)));
            },
            set_cursor_by_index: j,
            stop_cursor: e,
            clear_cursor: P,
            start_cursor: G,
            select_text: function h(b, c, d, f, g) {
                (e(), cc.clear_canvas(a));
                var i = measure_par_width_at_each_letter(g).map(function (a) {
                        return a + g.x;
                    }),
                    j = l(i, b),
                    k = _slicedToArray(j, 2),
                    m = k[0],
                    n = k[1],
                    o = shapes_storage.find_shape(d, f);
                ((o && "border" != o.iama) || (o = g),
                    o &&
                        o != g &&
                        "text" == o.iama &&
                        (i = measure_par_width_at_each_letter(o).map(
                            function (a) {
                                return a + o.x;
                            },
                        )));
                var q = l(i, d),
                    r = _slicedToArray(q, 2),
                    s = r[0],
                    t = r[1];
                if (g.num > o.num || (g.num == o.num && m > s)) {
                    //selectie omdraaien als van rechts naar links/ onder naar boven gesleept is
                    var x = [o, g];
                    ((g = x[0]), (o = x[1]));
                    var y = [s, m];
                    ((m = y[0]), (s = y[1]));
                    var z = [t, n];
                    ((n = z[0]), (t = z[1]));
                }
                ((g.parent.par_num != o.parent.par_num ||
                    g.parent.border_id != o.parent.border_id) &&
                    ((o = get_chunks_in_par(
                        g.parent.border_id,
                        g.parent.par_num,
                    )
                        .slice(-1)[0]
                        .parts.slice(-1)[0]),
                    (t = o.text.length)),
                    w(g.parent, o.parent, u(g, n - 1), u(o, t), m, s),
                    v());
            },
            clear_selection: m,
            has_selection: function a() {
                return !1 != aa;
            },
            clear: function a() {
                (m(), this.clear_cursor());
            },
            cursor_on: function a() {
                return V;
            },
            get_range: function a() {
                return aa;
            },
            insert_text: function b(a) {
                (E(), aa ? C(a) : D(a));
            },
            get_cursor: function a() {
                return X;
            },
            split_off_range: F,
            delete: function a() {
                V ? o() : aa && C("");
            },
            backspace: function a() {
                V ? p() : aa && C("");
            },
            get_part_from_cursor: function a() {
                if (!V) return !1;
                var b = t(X.chunk, X.index),
                    c = _slicedToArray(b, 2),
                    d = c[0],
                    e = c[1];
                return d;
            },
            cursor_index_to_par_index: r,
            par_index_to_part_and_index_of_part: s,
        };
    })(cursor_context);
    ("use strict");
    function _toConsumableArray(a) {
        return (
            _arrayWithoutHoles(a) ||
            _iterableToArray(a) ||
            _unsupportedIterableToArray(a) ||
            _nonIterableSpread()
        );
    }
    function _nonIterableSpread() {
        throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _iterableToArray(a) {
        if (
            ("undefined" != typeof Symbol && null != a[Symbol.iterator]) ||
            null != a["@@iterator"]
        )
            return Array.from(a);
    }
    function _arrayWithoutHoles(a) {
        if (Array.isArray(a)) return _arrayLikeToArray(a);
    }
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, d) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, d);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, d)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, d) {
        (null == d || d > b.length) && (d = b.length);
        for (var f = 0, g = Array(d); f < d; f++) g[f] = b[f];
        return g;
    }
    function _iterableToArrayLimit(b, d) {
        var g =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != g) {
            var h,
                j,
                k,
                l,
                m = [],
                a = !0,
                p = !1;
            try {
                if (((k = (g = g.call(b)).next), 0 === d)) {
                    if (Object(g) !== g) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (h = k.call(g)).done) &&
                        (m.push(h.value), m.length !== d);
                        a = !0
                    );
            } catch (a) {
                ((p = !0), (j = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != g["return"] &&
                        ((l = g["return"]()), Object(l) !== l)
                    )
                        return;
                } finally {
                    if (p) throw j;
                }
            }
            return m;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    var gui_buttons = (function () {
        function a(a, b) {
            return b
                .map(function (b) {
                    return b / a;
                })
                .map(function (a) {
                    return Math.max(1, round_to(a, 0));
                });
        }
        function b(b) {
            if (!b) return !1;
            (gui_context.save(),
                gui_context.translate(transform.x, transform.y),
                gui_context.scale(transform.k, transform.k),
                gui_context.beginPath(),
                (gui_context.strokeStyle = "red"),
                (gui_context.lineWidth = Math.min(
                    3,
                    round_to(0.7 / transform.k, 1),
                )),
                gui_context.setLineDash(a(transform.k, [5, 10])));
            var e = -transform.x / transform.k,
                f = -transform.y / transform.k,
                g = canvas_width / transform.k,
                h = canvas_height / transform.k; //top horizontaal
            //bottom horizontaal
            //left verticaal
            //right verticaal
            ("path_addon" == b.iama && (b = b.bbox),
                d(e, b.y, e + g, b.y),
                d(e, b.y + b.height, e + g, b.y + b.height),
                d(b.x, f, b.x, f + h),
                d(b.x + b.width, f, b.x + b.width, f + h),
                gui_context.stroke(),
                gui_context.restore(),
                cc.set_has_ink(gui_context));
        }
        function d(a, b, d, e) {
            (gui_context.moveTo(a, b), gui_context.lineTo(d, e));
        }
        function e(a) {
            var b = path_to_array(a.d),
                d = b[0],
                e = {
                    font_size: 20,
                    x: d.x,
                    y: d.y,
                    width: 20 / transform.k,
                    height: 20 / transform.k,
                    iama: "path_indicator_tail",
                    stroke: "black",
                    fill: "#734b6d",
                    icon: fa_handler.get_icons_per_cat()["Audio & Video"][4],
                },
                f = b.slice(-1)[0],
                g = {
                    font_size: 20,
                    x: f.x,
                    y: f.y,
                    width: 20 / transform.k,
                    height: 20 / transform.k,
                    iama: "path_indicator_tail",
                    stroke: "black",
                    fill: "#734b6d",
                    icon: fa_handler.get_icons_per_cat().Arrows[7],
                };
            (j(e), j(g), position_path_direction_buttons(a));
        }
        function f(a) {
            if ((a && "canvas" == a.iama) || !a) return !1;
            if ("text" == a.iama && !("parent" in a)) return !1;
            if (
                (y(),
                gui_context.save(),
                gui_context.translate(transform.x, transform.y),
                gui_context.scale(transform.k, transform.k),
                gui_cursor.clear(),
                "text" == a.iama)
            )
                (gui_cursor.set_cursor_by_xpos(a, last_pos[0]),
                    gui_cursor.start_cursor(),
                    m(a));
            else if ("path_group" == a.iama) e(a);
            else if ("fa_icon" == a.iama);
            else if ("knot" == a.iama);
            else {
                //niets..??
                if ("gui_resize" == a.iama || "gui_connect" == a.iama)
                    return !1;
                (-1 == ["knot", "path_addon", "math_shape"].indexOf(a.iama) &&
                    s(a),
                    -1 !=
                        ["knot", "drawing", "path_addon", "math_shape"].indexOf(
                            a.iama,
                        ) ||
                        a.bound ||
                        t(a),
                    i(a) && p(a),
                    "drawing" == a.iama && "line" == a.type && n(a),
                    "rect" == a.shape && "flipped" in a && q(a));
            }
            (gui_context.restore(), b(a), 0 < E.length && v());
        }
        function g() {
            var a = C,
                b = posit2.get_w_h(currentElement),
                e = _slicedToArray(b, 2),
                f = e[0],
                g = e[1],
                h = posit2.get_top_left(currentElement, !0),
                i = [h[0] + f / 2, h[1] + g / 2],
                j = [a.x, a.y],
                k = "M" + i + "L " + j;
            return k;
        }
        function h(a, b) {
            ((C.x += a),
                (C.y += b),
                gui_context.save(),
                cc.clear_canvas(gui_context),
                gui_context.translate(transform.x, transform.y),
                gui_context.scale(transform.k, transform.k));
            var e = g();
            (drawPath({ d: e, outer_width: 3, stroke: "black" }, gui_context),
                j(C),
                gui_context.restore());
        }
        function i(a) {
            return (
                "border" == a.iama &&
                -1 !=
                    [
                        "arrow_right",
                        "arrow_left",
                        "arrow_up",
                        "arrow_down",
                        "chevron_right",
                        "chevron_left",
                        "chevron_up",
                        "chevron_down",
                        "house_up",
                        "house_down",
                        "house_left",
                        "house_right",
                        "parallello_hor",
                        "parallello_hor_mirrored",
                        "parallello_vert",
                        "parallello_vert_mirrored",
                    ].indexOf(a.shape)
            );
        }
        function j(a) {
            ((a.zoom_scale = 1 / transform.k),
                "icon" in a
                    ? draw_fa_icon(a, gui_context)
                    : draw_gui_path(a, gui_context));
        } //TODO2 fatsoenijke naam, functies samenvoegen of duidelijker onderscheidend
        function k(a, b) {
            var d = a[0].parts[0].y,
                e = a.slice(-1)[0].parts.slice(-1)[0],
                f = e.y + e.height,
                g = [
                    [b + 5, d],
                    [b, d],
                    [b, f],
                    [b + 5, f],
                ];
            l(g, gui_context);
        }
        function l(a, b) {
            (b.save(), (b.strokeStyle = "yellowgreen"));
            var d =
                1 < transform.k
                    ? Math.max(0.4, round_to(4 / transform.k, 1))
                    : 4;
            ((b.lineWidth = d),
                b.beginPath(),
                a.forEach(function (a) {
                    var d = _slicedToArray(a, 2),
                        e = d[0],
                        f = d[1];
                    return b.lineTo(r(e), r(f));
                }),
                b.stroke(),
                b.restore(),
                cc.set_has_ink(b));
        }
        function m(a) {
            var b = get_chunks_in_par(a.parent.border_id, a.parent.par_num),
                d = b[0].parts[0],
                e = shapes_storage.search_shapes_with_id(
                    currentElement.border_id,
                ).x;
            ((I = {
                font_size: 20,
                x: e - 22 / transform.k,
                y: d.y,
                width: 20 / transform.k,
                height: 20 / transform.k,
                iama: "gui_par_handle",
                stroke: "black",
                fill: "yellowgreen",
            }),
                (I.icon = fa_handler.get_icons_per_cat().Arrows[34]),
                j(I),
                k(b, e));
        }
        function n(a) {
            var b = path_to_array("M" + a.d.split("M")[1]).map(function (b) {
                var d = b.x,
                    e = b.y;
                return { x: d + a.x, y: e + a.y };
            });
            ((F = []), o(b[0]), o(b.slice(-1)[0]), F.forEach(j));
        }
        function o(a) {
            var b = {
                font_size: 20,
                x: a.x,
                y: a.y,
                width: 20 / transform.k,
                height: 20 / transform.k,
                iama: "gui_line_end",
                stroke: "black",
                stroke_width: 0.5,
                fill: "yellowgreen",
                index: F.length,
            };
            ((b.icon = fa_handler.get_icons_per_cat().Arrows[0]), F.push(b));
        }
        function p(a) {
            D = {
                font_size: 20,
                x: a.x + a.width,
                y: a.y + a.height / 2 - 10,
                width: 20 / transform.k,
                height: 20 / transform.k,
                iama: "gui_morph",
                stroke: "black",
                stroke_width: 0.5,
                fill: "#734b6d",
            };
            var b =
                "reshape_icon" in poly_config[a.shape]
                    ? poly_config[a.shape].reshape_icon
                    : 24;
            ((D.icon = fa_handler.get_icons_per_cat().Arrows[b]), j(D));
        }
        function q(a) {
            ((B = {
                font_size: 20,
                x: a.x + a.width,
                y: a.y + a.height / 2 - 10,
                width: 20 / transform.k,
                height: 20 / transform.k,
                iama: "gui_flip",
                stroke: "black",
                stroke_width: 0.5,
                fill: "#734b6d",
            }),
                (B.icon = fa_handler.get_icons_per_cat().Arrows[102]),
                j(B));
        }
        function s(a) {
            var b, d; //opdat niet op dezelfde plek als line_end_buttons
            //resize_button['d'] = "m 239.38452,254.4043 c 1.79252,-1.09292 4.15334,-3.45373 5.24626,-5.24626 1.95083,-3.19962 1.98719,-5.25922 1.99086,-112.77474 0.004,-123.968514 0.65982,-114.277381 -8.03214,-118.734393 -3.76919,-1.932742 -5.94554,-2.25 -15.43473,-2.25 l -11.04684,0 -21.48255,21.5 -21.48256,21.5 17.24128,0 17.24128,0 0,77.499993 0,77.5 -78,0 -78.000004,0 -0.0526,-17.25 -0.0526,-17.25 -21.5236,22 -21.5235996,22 0.32619,12 c 0.28995,10.66683 0.58492,12.36274 2.65503,15.26509 4.7425096,6.64911 -3.11872,6.23529 118.3715036,6.23117 108.29789,-0.004 110.35881,-0.0398 113.5588,-1.99086 z m -96.64421,-86.36109 c 7.32949,-2.66779 12.63313,-7.66499 16.08622,-15.15677 2.29833,-4.98642 2.29882,-4.99786 2.19188,-51.0106 -0.11886,-51.142016 0.19311,-48.68236 -7.06061,-55.667395 -2.10783,-2.029754 -5.09921,-4.167254 -6.64752,-4.75 -3.92524,-1.477368 -12.12104,-1.321973 -16.01155,0.303584 -3.68094,1.537996 -11.47509,9.886055 -12.18742,13.053546 -0.25769,1.145833 -0.80994,10.633332 -1.22722,21.083332 l -0.75871,19 L 70.352006,48.468769 23.578656,2.0386321 19.546216,5.9687696 c -2.21784,2.1615755 -5.46983,6.8456754 -7.22664,10.4091104 -2.9149496,5.912549 -3.1941996,7.311346 -3.1941996,16 0,15.695838 -0.26602,15.328649 41.8536796,57.771027 l 35.97438,36.249993 -15.91403,0.006 c -26.11517,0.01 -31.77462,1.85207 -36.92861,12.02298 -4.18235,8.25348 -2.88173,17.78399 3.31763,24.31051 6.02993,6.34814 4.21988,6.13857 55.19694,6.39076 36.405694,0.1801 47.284754,-0.0556 50.114944,-1.08573 z"
            ((b = a.x + a.width),
                (d = a.y + a.height),
                (A = {
                    font_size: 20,
                    x: b,
                    y: d,
                    width: 20 / transform.k,
                    height: 20 / transform.k,
                    iama: "gui_resize",
                    stroke: "black",
                    stroke_width: 0.5,
                    fill: "yellowgreen",
                }),
                "drawing" == a.iama && (A.x += 20 / transform.k),
                (A.icon = fa_handler.get_icons_per_cat().Arrows[24]),
                j(A));
        }
        function t(a) {
            //connect_button['icon'] = fa_handler.get_icons_per_cat()['Arrows'][3];
            ((C = {
                font_size: 20,
                x: a.x - 20 / transform.k,
                y: a.y + a.height,
                width: 20 / transform.k,
                height: 20 / transform.k,
                iama: "gui_connect",
                stroke: "black",
                stroke_width: 0.4,
                fill: "yellowgreen",
            }),
                (C.d = "M 0 4 C 25 4 0 20 25 20 L25 22  C 0 24 22 7 0 6"),
                j(C));
        }
        function u(a, b, d) {
            return is_inside(b, d, to_bbox(a));
        }
        function v() {
            var a =
                !!(0 < arguments.length && arguments[0] !== void 0) &&
                arguments[0];
            (gui_context.save(),
                a || cc.clear_canvas(gui_context),
                gui_context.translate(transform.x, transform.y),
                gui_context.scale(transform.k, transform.k),
                E.forEach(function (a) {
                    ((a.width = 10 / transform.k),
                        (a.height = 10 / transform.k));
                }),
                E.forEach(function (a) {
                    return drawEllipse(a, gui_context);
                }),
                gui_context.restore(),
                cc.set_has_ink(gui_context));
        }
        function w(a) {
            var b =
                !!(1 < arguments.length && arguments[1] !== void 0) &&
                arguments[1]; //if (el == has_highlight) return false;
            (cc.clear_canvas(hover_context),
                "path_addon" == a.iama
                    ? render_hover_highlight(
                          a.bbox,
                          "rgba(154,0,50,0.5)",
                          hover_context,
                          get_scaled_margin(),
                      )
                    : a.is_cell
                      ? render_hover_highlight(
                            a,
                            "#f9f951a6",
                            hover_context,
                            get_scaled_margin(),
                        )
                      : canvas_status.view_mode && "flipped" in a
                        ? render_hover_highlight(
                              a,
                              "rgba(154,205,50,0.5)",
                              hover_context,
                              get_scaled_margin(),
                          )
                        : x(manage_groups.get_group(a), b),
                (J = a));
        }
        function x(a) {
            var b =
                !!(1 < arguments.length && arguments[1] !== void 0) &&
                arguments[1];
            a.forEach(function (a) {
                "parts" in a
                    ? a.parts.forEach(function (a) {
                          return render_hover_highlight(
                              a,
                              b || "pink",
                              hover_context,
                              get_scaled_margin() / 3,
                          );
                      })
                    : render_hover_highlight(
                          a,
                          b || "rgba(154,205,50,0.5)",
                          hover_context,
                          get_scaled_margin(),
                      );
            });
        }
        function y() {
            (cc.clear_canvas(gui_context),
                cc.clear_canvas(hover_context),
                (A = {}),
                (C = {}),
                (F = []),
                (D = {}),
                (I = {}),
                (plumb_pos = !1),
                (J = !1));
        }
        function z() {
            return 0 < E.length;
        }
        var A = {},
            B = {},
            C = {},
            D = {},
            E = [],
            F = [],
            G = [],
            H = !1,
            I = {},
            J = !1; //TODO9 path control points herbenoemen naar control points
        return {
            render_hover_highlight_for_group: x,
            has_control_points: z,
            add_location_circle: function a() {
                var b;
                function d() {
                    var a = infinity.get_level();
                    if ("L0" == a) return "rgba(255,0,0,0.8)";
                    return "L1" == a
                        ? "yellowgreen"
                        : "L2" == a
                          ? "pink"
                          : "L3" == a
                            ? "rgba(0,0,255,0.5)"
                            : void 0;
                }
                (cc.clear_canvas(gui_context),
                    gui_context.save(),
                    gui_context.translate(transform.x, transform.y),
                    gui_context.scale(transform.k, transform.k),
                    (gui_context.fillStyle = d()),
                    gui_context.beginPath());
                var e = Math.min(8, 4 / transform.k); //gui_context.stroke();
                ((b = gui_context).ellipse.apply(
                    b,
                    _toConsumableArray(last_pos).concat([
                        e,
                        e,
                        0,
                        0,
                        2 * Math.PI,
                    ]),
                ),
                    gui_context.closePath(),
                    gui_context.fill(),
                    gui_context.restore(),
                    cc.set_has_ink(gui_context));
            },
            add_hover_highlight: w,
            frame_element: f,
            draw_plumbs_only: function d(a) {
                (cc.clear_canvas(gui_context),
                    cc.clear_canvas(hover_context),
                    b(a));
            },
            is_resize_button: function d(a, b) {
                if (u(A, a, b)) return A;
            },
            is_flip_button: function d(a, b) {
                if (u(B, a, b)) return B;
            },
            is_connect_button: function d(a, b) {
                if (u(C, a, b)) return C;
            },
            is_morph_button: function d(a, b) {
                if (u(D, a, b)) return D;
            },
            is_par_handle: function d(a, b) {
                if (u(I, a, b)) return I;
            },
            is_path_control_point: function d(a, b) {
                for (var e = 0; e < E.length; e++)
                    if (u(E[e], a, b)) return E[e];
            },
            is_line_end_button: function d(a, b) {
                for (var e = 0; e < F.length; e++)
                    if (u(F[e], a, b)) return F[e];
            }, //TODO8 generieke loop voor islineend. ispolypoint is pathcp
            // is_poly_point_add_button:function(x,y){
            //     for (let i=0;i< poly_point_add_buttons.length; i++){
            //         if (is_button(poly_point_add_buttons[i], x,y)) return poly_point_add_buttons[i]
            //     }
            // },
            dummy_connect: g,
            move_resize_button: function d(a, b) {
                ((A.x += a), (A.y += b));
            },
            move_connect_button: h,
            end_drag_gui_connect: function b(a) {
                if (a && a != currentElement)
                    (path.make_new_connection(
                        currentElement,
                        a,
                        document.querySelector("#form_always_add_arrow")
                            .checked,
                    ),
                        set_current_element(cpa.path_g));
                else {
                    var d = get_xy_inverted_from_event(d3.event.sourceEvent);
                    path_to_nothing(
                        d,
                        currentElement,
                        document.querySelector("#form_always_add_arrow")
                            .checked,
                    );
                }
                y();
            },
            add_marker_to_example_style: function b(a) {
                function d(a, b) {
                    var d = d3.select(b).select("rect." + a);
                    if (!d.empty()) {
                        var e = d.attr("x"),
                            f = d.attr("y");
                        d3.select(b)
                            .append("circle")
                            .attr("cx", parseInt(e) + 13)
                            .attr("cy", parseInt(f) + 9)
                            .attr("r", 2)
                            .attr("class", "style_marker")
                            .style("stroke", "#504545")
                            .style("stroke-width", "1px")
                            .style("fill", "white")
                            .style("pointer-events", "none");
                    }
                }
                (d3.selectAll(".style_marker").remove(),
                    (c = a),
                    c && (d(c, "#colors_svg"), d(c, "#cm_colors_svg")));
            },
            get_path_control_points_as_ref: function a() {
                return E;
            },
            render_path_control_points: v,
            add_path_control_point: function b(a) {
                return E.push(a);
            },
            set_el_with_cps: function b(a) {
                return (H = a);
            },
            get_el_with_cps: function a() {
                return H;
            },
            reset_path_control_points: function a() {
                ((E = []), (H = !1));
            },
            remove_hover_highlight: function a() {
                (cc.clear_canvas(hover_context), (J = !1));
            },
            clear: y,
        };
    })(); //TODO8 bij toevoegen cell basic (maar mogelijk ook andere shapes via dubbel klik op canvas) die doorzichtig is en geen border heeft,
    //waarschuwing geven of shape andere border kleur.
    //TODO2 browser compat weer terugzetten?
    //TODO1 morph shape zou eigenlijk minimum moeten hebben odpat er altijd plek is voor tekst, bv voor chevron
    ("use strict");
    function _toConsumableArray(a) {
        return (
            _arrayWithoutHoles(a) ||
            _iterableToArray(a) ||
            _unsupportedIterableToArray(a) ||
            _nonIterableSpread()
        );
    }
    function _nonIterableSpread() {
        throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _iterableToArray(a) {
        if (
            ("undefined" != typeof Symbol && null != a[Symbol.iterator]) ||
            null != a["@@iterator"]
        )
            return Array.from(a);
    }
    function _arrayWithoutHoles(a) {
        if (Array.isArray(a)) return _arrayLikeToArray(a);
    }
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function add_canvas_drag_default() {
        (canvas
            .call(
                d3
                    .drag()
                    .subject(shapes_storage.find_draggable_shape)
                    .on("start", drag_start)
                    .on("drag", dragged)
                    .on("end", drag_end),
            )
            .call(zoom_behavior),
            canvas.on("dblclick.zoom", null));
    }
    function add_canvas_drag_select() {
        var a, b;
        canvas.call(
            d3
                .drag()
                .on("start", function () {
                    //start_pos_select = [transform.invertX(d3.event.sourceEvent.x), transform.invertY(d3.event.sourceEvent.y)];
                    ((a = get_xy_inverted_from_event(d3.event.sourceEvent)),
                        draw_rect_select([a[0] - 5, a[1] - 5], a));
                })
                .on("drag", function () {
                    (demo_mode && text_to_demo_pane("dragging the canvas"),
                        (b = get_xy_inverted_from_event(d3.event.sourceEvent)),
                        draw_rect_select(a, b));
                })
                .on("end", function () {
                    (handle_drag_select(a, b), drag_select_off());
                }),
        );
    }
    function add_canvas_drag_draw() {
        canvas.call(drag_draw);
    }
    function find_drag_selector_subject(a) {
        a = a || d3.event.sourceEvent || d3.event;
        var b = get_xy_inverted_from_event(a),
            c = _slicedToArray(b, 2),
            d = c[0],
            f = c[1],
            g = gui_buttons.is_path_control_point(d, f);
        return g
            ? g
            : is_inside(d, f, to_bbox(slider, 1))
              ? slider
              : to_canvas.get_canvas();
    }
    function add_canvas_drag_selector() {
        var a, b;
        canvas.call(
            d3
                .drag()
                .subject(find_drag_selector_subject)
                .on("start", function () {
                    slider ||
                        ((a = get_xy_inverted_from_event(d3.event.sourceEvent)),
                        draw_rect_select([a[0] - 5, a[1] - 5], a));
                })
                .on("drag", function () {
                    var c = cumulator_pos.add(d3.event.dx, d3.event.dy),
                        d = _slicedToArray(c, 2),
                        e = d[0],
                        f = d[1];
                    (demo_mode && text_to_demo_pane("dragging the canvas"),
                        "path_cp" == d3.event.subject.iama
                            ? (set_current_element(slider),
                              drag_selector_resize(e, f),
                              draw_slider(slider))
                            : d3.event.subject == slider
                              ? ((slider.x += e),
                                (slider.y += f),
                                draw_slider(slider))
                              : ((b = get_xy_inverted_from_event(
                                    d3.event.sourceEvent,
                                )),
                                draw_rect_select(a, b)));
                })
                .on("end", function () {
                    if ("canvas" == d3.event.subject.iama) {
                        var c = b[1] - a[1],
                            d = b[0] - a[0];
                        slider = {
                            width: d,
                            height: c,
                            x: a[0],
                            y: a[1],
                            iama: "slider",
                        };
                    }
                    (draw_slider_resize_points(),
                        cumulator_pos.reset(),
                        set_buttons_for_slide(),
                        add_canvas_drag_default());
                }),
        );
    }
    function drag_end() {
        var a = d3.event.subject.iama;
        if ("gui_connect" == a) drag_knot_end();
        else if ("knot" == a) drag_knot_end();
        else if ("gui_morph" == a)
            (position_texts(currentElement.id), render());
        else if ("path_cp" == a)
            ("drag_func" in d3.event.subject &&
                "dragend" in d3.event.subject.drag_func &&
                d3.event.subject.drag_func.dragend(),
                "path_group" == currentElement.iama &&
                    path.remake_path(!0, !0));
        else if ("gui_resize" == a) d3.event.subject.fixed_size = !0;
        else if ("gui_par_handle" == d3.event.subject.iama)
            d3.event.sourceEvent &&
                d3.event.sourceEvent.ctrlKey &&
                (gui_cursor.clear_cursor(),
                move_dragged_par_to_final_pos.apply(
                    void 0,
                    [currentElement].concat(
                        _toConsumableArray(cumulator_pos.dist_from_start()),
                        _toConsumableArray(cumulator_pos.get_origin()),
                    ),
                ));
        else if ("gui_line_end" == d3.event.subject.iama)
            handle_line_end_drag.apply(
                void 0,
                [currentElement, d3.event.subject.index].concat(
                    _toConsumableArray(cumulator_pos.dist_from_start()),
                ),
            );
        else if ("gui_line_end" == d3.event.subject.iama)
            handle_poly_point_add_button_end_drag();
        else if ("slider" == d3.event.subject.iama || "slider_cp" == a)
            (canvas_status.slide_mode ||
                (canvas_status.export_mode && !printer.is_fixed_A_ratio())) &&
                (draw_slider_resize_points(),
                printer.change_goal_w_h(slider.width, slider.height));
        else {
            if (canvas_has_been_dragged) {
                var b = d3.event.subject.iama;
                canvas_status.export_mode ||
                    "gui_resize" == b ||
                    "gui_connect" == b ||
                    "text" == b ||
                    (set_current_element(d3.event.subject),
                    gui_buttons.frame_element(d3.event.subject),
                    d3.event.subject.on_slide &&
                        slide_manager.handle_object_of_slide_has_moved(
                            d3.event.subject,
                        ));
            }
            gui_buttons.has_control_points() &&
                (move_all_control_points.apply(
                    void 0,
                    _toConsumableArray(cumulator_pos.dist_from_start()),
                ),
                gui_buttons.render_path_control_points());
        }
        (cumulator_pos.reset(), (canvas_has_been_dragged = !1));
    }
    function drag_start() {
        var a;
        (cc.clear_canvas(cursor_context),
            cc.clear_canvas(hover_context),
            cc.clear_canvas(gui_context),
            (a = cumulator_pos).set_origin.apply(
                a,
                _toConsumableArray(
                    get_xy_inverted_from_event(d3.event.sourceEvent),
                ),
            ),
            cumulator_pos.set_fixed_int(
                d3.event.sourceEvent && d3.event.sourceEvent.shiftKey
                    ? 1
                    : void 0,
            ),
            gui_cursor.cursor_on() && gui_cursor.clear_cursor(),
            canvas_status.export_mode ||
                -1 ==
                    [
                        "border",
                        "drawing",
                        "fa_icon",
                        "knot",
                        "math_shape",
                    ].indexOf(d3.event.subject.iama) ||
                set_current_element(d3.event.subject));
    } //TODO9 betere naam.: gaat erom of drag niet 0,0 is
    canvas_has_been_dragged = !1;
    function dragged() {
        var a = cumulator_pos.add(d3.event.dx, d3.event.dy);
        if (0 != a[0] || 0 != a[1])
            if (
                (demo_mode &&
                    (d3.event.sourceEvent.shiftKey
                        ? text_to_demo_pane("shift pressed + dragging", !1, 1e3)
                        : text_to_demo_pane("dragging", !1, 300)),
                (canvas_has_been_dragged = !0),
                canvas_status.slide_mode || canvas_status.export_mode)
            )
                "path_cp" == d3.event.subject.iama ||
                "slider_cp" == d3.event.subject.iama
                    ? (set_current_element(slider),
                      drag_selector_resize.apply(void 0, _toConsumableArray(a)),
                      draw_slider(slider))
                    : "slider" == d3.event.subject.iama &&
                      (reposition_protocol.apply(
                          void 0,
                          [d3.event.subject].concat(_toConsumableArray(a)),
                      ),
                      draw_slider(slider));
            else {
                if ("gui_resize" == d3.event.subject.iama)
                    (resize_protocol(currentElement, a[0], a[1]),
                        gui_buttons.frame_element(currentElement),
                        (currentElement.fixed_size = !0));
                else if ("knot" == d3.event.subject.iama)
                    (reposition_protocol(d3.event.subject, a[0], a[1]),
                        gui_buttons.frame_element(d3.event.subject),
                        el_under_dragged_shape(this.parentElement));
                else {
                    if ("gui_connect" == d3.event.subject.iama)
                        return (
                            drag_knot.apply(void 0, _toConsumableArray(a)),
                            !1
                        );
                    if ("gui_morph" == d3.event.subject.iama)
                        reshape_polygon.apply(
                            void 0,
                            [currentElement].concat(_toConsumableArray(a)),
                        );
                    else {
                        if ("gui_par_handle" == d3.event.subject.iama)
                            return (
                                d3.event.sourceEvent &&
                                d3.event.sourceEvent.ctrlKey
                                    ? console.log("drag par to canvas")
                                    : handle_par_drag.apply(
                                          void 0,
                                          [currentElement].concat(
                                              _toConsumableArray(a),
                                          ),
                                      ),
                                !1
                            );
                        if ("gui_line_end" == d3.event.subject.iama)
                            handle_line_drag.apply(
                                void 0,
                                [currentElement, d3.event.subject.index].concat(
                                    _toConsumableArray(
                                        cumulator_pos.dist_from_start(),
                                    ),
                                ),
                            );
                        else if ("path_cp" == d3.event.subject.iama) {
                            var b;
                            (b = d3.event.subject.drag_func).drag.apply(
                                b,
                                _toConsumableArray(a),
                            );
                        } else {
                            if ("text" == d3.event.subject.iama) {
                                var c;
                                return (
                                    (c = gui_cursor).select_text.apply(
                                        c,
                                        _toConsumableArray(
                                            cumulator_pos.get_origin(),
                                        ).concat(
                                            _toConsumableArray(
                                                cumulator_pos.get_current(),
                                            ),
                                            [d3.event.subject],
                                        ),
                                    ),
                                    !1
                                );
                            }
                            ("path_id" in d3.event.subject
                                ? repos_text_block(
                                      d3.event.subject,
                                      shapes_storage.paths.filter(function (a) {
                                          return (
                                              a.id == d3.event.subject.path_id
                                          );
                                      })[0],
                                      a[0],
                                  )
                                : reposition_protocol(
                                      d3.event.subject,
                                      a[0],
                                      a[1],
                                  ),
                                canvas_status.plumbs_on &&
                                    gui_buttons.draw_plumbs_only(
                                        d3.event.subject,
                                    ));
                        }
                    }
                }
                requestAnimationFrame(render);
            }
    }
    function drag_discrete() {
        function a(a) {
            return Math.round(1e5 * a) / 1e5;
        }
        function b(a) {
            return 0 > a ? Math.ceil(a) : Math.floor(a);
        }
        var c =
                0 < arguments.length && arguments[0] !== void 0
                    ? arguments[0]
                    : void 0,
            d = 0,
            e = 0,
            f = 0,
            g = 0,
            h = [];
        return {
            add: function (h, i) {
                ((d = a(h / zoom_factor + d)),
                    (e = a(e + i / zoom_factor)),
                    (c =
                        d3.event.sourceEvent && d3.event.sourceEvent.altKey
                            ? 1
                            : mdd));
                var j = b(d / (c || mdd)) * (c || mdd),
                    k = b(e / (c || mdd)) * (c || mdd);
                return (
                    (d %= c || mdd),
                    (e %= c || mdd),
                    (f += j),
                    (g += k),
                    [j, k]
                );
            },
            reset: function () {
                var a = 0 != f && 0 != g;
                return ((d = 0), (e = 0), (f = 0), (g = 0), a);
            },
            status: function () {
                return [d, e];
            },
            dist_from_start: function () {
                return [f, g];
            },
            set_origin: function (a, b) {
                h = [a, b];
            },
            get_origin: function () {
                return h;
            },
            get_current: function () {
                return [h[0] + f, h[1] + g];
            },
            set_fixed_int: function (a) {
                return (c = a);
            },
        };
    }
    var el_under;
    function drag_knot(a, b) {
        (gui_buttons.move_connect_button(a, b),
            el_under_dragged_shape(this.parentElement));
    }
    function drag_knot_end() {
        return (
            "gui_connect" == d3.event.subject.iama
                ? gui_buttons.end_drag_gui_connect(el_under)
                : el_under &&
                  (path.attach_path(el_under, d3.event.subject), render()),
            (el_under = !1),
            cc.clear_canvas(gui_context),
            !1
        );
    }
    function drag_draw_on() {
        (canvas.on(".drag", null),
            canvas.on(".zoom", null),
            (canvas_status.draw_mode = !0),
            add_canvas_drag_draw(),
            (canvas.node().style.cursor = null),
            canvas.node().classList.add("drag_draw"),
            toggle_button_to_status(
                document.querySelector("#form_toggle_draw"),
                !0,
            ),
            toggle_button_to_status(
                document.querySelector("#cm_toggle_draw"),
                !0,
            ));
    }
    function drag_draw_off() {
        (current_draw_group
            .filter(function (a) {
                return "" != a.d;
            })
            .forEach(function (a) {
                (set_drawing_pos(a, a.points), delete a.points);
            }),
            current_draw_group.forEach(function (a) {
                return shapes_storage.drawings.push(a);
            }),
            (current_draw_group = []),
            canvas.on(".drag", null),
            (canvas_status.draw_mode = !1),
            add_canvas_drag_default(),
            cc.clear_canvas(context_single),
            (canvas.node().style.cursor = "inherit"),
            canvas.node().classList.remove("drag_draw"),
            toggle_button_to_status(
                document.querySelector("#form_toggle_draw"),
                !1,
            ),
            toggle_button_to_status(
                document.querySelector("#cm_toggle_draw"),
                !1,
            ),
            to_canvas.set_canvas());
    }
    function drag_select_on() {
        (0 == manage_groups.get_current_group().length
            ? text_to_feedback_pane("drag canvas to group shapes")
            : text_to_feedback_pane(
                  "drag canvas to add to or remove from group",
              ),
            canvas.on(".drag", null),
            canvas.on(".zoom", null),
            (canvas_status.drag_select = !0),
            add_canvas_drag_select(),
            (canvas.node().style.cursor = "cell"));
    }
    function drag_select_off() {
        (canvas.on(".drag", null),
            (canvas_status.drag_select = !1),
            add_canvas_drag_default(),
            cc.clear_canvas(gui_context),
            (canvas.node().style.cursor = "inherit"),
            update_quick_grouping_forms());
    }
    function drag_slides_on() {
        (text_to_feedback_pane("drag the canvas to add a slide"),
            canvas.on(".drag", null),
            canvas.on(".zoom", null),
            (canvas_status.slide_mode = !0),
            add_canvas_drag_selector(),
            (canvas.node().style.cursor = "cell"));
    }
    function drag_slides_off() {
        (canvas.on(".drag", null),
            (canvas_status.slide_mode = !1),
            gui_buttons.reset_path_control_points(),
            (slider = !1),
            set_buttons_for_slide(),
            add_canvas_drag_default(),
            cc.clear_canvas(context_single),
            (canvas.node().style.cursor = "inherit"));
    }
    function drag_export_on() {
        //canvas.on('.drag', null);
        //canvas.on('.zoom', null);
        ((canvas_status.export_mode = !0),
            to_canvas.set_canvas(),
            (document.querySelector("#form_remove_print_region").style.display =
                "block"),
            (document.querySelector("#form_print_buttons").style.display =
                "block"),
            (document.querySelector(
                "#form_print_add_print_region",
            ).style.display = "none"),
            set_form_print_ratio_choice());
    }
    function drag_export_off() {
        //document.querySelector('#form_print_region_if_active').style.display='none';
        //$('.form_print_output_size_A_scale').css('display', "none");
        //document.querySelector('#form_print_output_size_custom').style.display = "none"
        (canvas.on(".drag", null),
            (canvas_status.export_mode = !1),
            (slider = !1),
            add_canvas_drag_default(),
            cc.clear_canvas(gui_context),
            cc.clear_canvas(context_single),
            (canvas.node().style.cursor = "inherit"),
            (document.querySelector("#form_print_buttons").style.display =
                "none"),
            (document.querySelector(
                "#form_print_add_print_region",
            ).style.display = "block"),
            (document.querySelector("#form_remove_print_region").style.display =
                "none"));
    }
    function handle_drag_select(a, b) {
        var c = { top: a[1], left: a[0], bottom: b[1], right: b[0] },
            d = shapes_storage.find_shapes_in_bbox(c);
        manage_groups.toggle_elements(d);
    }
    var current_draw_group = [],
        free_draw = !0,
        drag_draw = d3
            .drag()
            .on("start", function () {
                if (
                    "mousedown" == d3.event.sourceEvent.type &&
                    0 != d3.event.sourceEvent.button
                )
                    return !1;
                var a = get_xy_inverted_from_event(d3.event.sourceEvent),
                    b = _slicedToArray(a, 2),
                    c = b[0],
                    d = b[1];
                0 == current_draw_group.length
                    ? start_new_draw_group(c, d)
                    : ((currentElement.d +=
                          "M" +
                          [c, d].map(function (a) {
                              return round_to(a, 2);
                          })),
                      !("points" in currentElement) &&
                          (currentElement.points = []),
                      currentElement.points.push([[c, d]]));
            })
            .on("drag", function () {
                if (
                    "mousemove" == d3.event.sourceEvent.type &&
                    0 != d3.event.sourceEvent.button
                )
                    return !1;
                if ("drawing" != currentElement.iama) return !1;
                var a = get_xy_inverted_from_event(d3.event.sourceEvent),
                    b = _slicedToArray(a, 2),
                    c = b[0],
                    d = b[1];
                (currentElement.points[currentElement.points.length - 1].push([
                    c,
                    d,
                ]),
                    (currentElement.d +=
                        "L" +
                        [c, d].map(function (a) {
                            return round_to(a, 2);
                        })),
                    render_current_draw_group(context_single));
            })
            .on("end", function () {
                if (
                    "mousedown" == d3.event.sourceEvent.type &&
                    0 != d3.event.sourceEvent.button
                )
                    return !1;
                if ("drawing" != currentElement.iama) return !1; //TODO8 drawing met alleen punten niet te selecteren
                if (1 == currentElement.points.slice(-1)[0].length) {
                    var a = currentElement.points.slice(-1)[0],
                        b = a[0].map(function (a) {
                            return round_to(a, 2) + 1;
                        }),
                        c = _slicedToArray(b, 2),
                        d = c[0],
                        e = c[1];
                    ((currentElement.d += "L" + [d, e]),
                        a.push([d, e]),
                        render_current_draw_group(context_single));
                }
                ignore_svg_click = !0;
            }),
        manhattan_move = {
            drag: function (a, b) {
                ((cp = d3.event.subject), (cp.x += a), (cp.y += b));
                var c = get_manhattan_perc(currentElement, [cp.x, cp.y]),
                    e = currentElement;
                (path.set_path_attrs(e),
                    (cpa.hg = !1),
                    (cpa.fixed_side = !0),
                    (cpa.manhattan_perc = c));
                var d = path.remake_path(!0, !0);
                d.manhattan_perc = c; //gui.repos_plumbs_for_cp(pos);
                var f = !cpa.fixed_side;
                (f && (g_d3.fixed_side = null), show_path_control_points());
            },
        },
        end_point_move = {
            dragstart: function () {
                text_to_help_pane(help_text.end_point);
            },
            drag: function (a, b) {
                function c(a, b, c) {
                    if (("1" == c) | ("3" == c))
                        var d = round_to(
                            (a[1] - b.top) / (b.bottom - b.top),
                            4,
                        );
                    else
                        var d = round_to(
                            (a[0] - b.left) / (b.right - b.left),
                            4,
                        );
                    return (
                        (0 > d || 1 < d) &&
                            text_to_feedback_pane([
                                'to connect path to other side of figure, "use path direction"',
                                "you can find it by right clicking the path, or in the Path Controls menu",
                            ]),
                        round_to(Math.min(1, Math.max(d, 0)), 4)
                    );
                }
                function d(a, b, c, d) {
                    //offset positief als "buiten" shape, negatief als binnen shape
                    //scale=1
                    return "0" == c
                        ? round_to(b.top - a[1], 0) / d
                        : "1" == c
                          ? round_to(a[0] - b.right, 0) / d
                          : "2" == c
                            ? round_to(a[1] - b.bottom, 0) / d
                            : "3" == c
                              ? round_to(b.left - a[0], 0) / d
                              : void 0;
                }
                var e = d3.event.subject,
                    f = gui_buttons.get_el_with_cps();
                path.set_path_attrs(f);
                var g = !d3.event.sourceEvent.shiftKey;
                ((e.x += a), (e.y += b));
                var h,
                    i,
                    j = [e.x, e.y];
                if ("endpoint_from" == e.drag_type) {
                    var k = cpa.from_side,
                        l = posit2.tlbr(cpa.e1),
                        m = c(j, l, k);
                    h = g ? 0 : d(j, l, k, 1);
                } else {
                    var k = cpa.to_side,
                        l = posit2.tlbr(cpa.e2),
                        n = c(j, l, k);
                    i = g ? 0 : d(j, l, k, 1);
                }
                ((cpa.pos1 = m || parseFloat(cpa.pos1) || 0.5),
                    (cpa.pos2 = n || parseFloat(cpa.pos2) || 0.5),
                    (cpa.fixed_side = !0),
                    (cpa.offset_from = h || cpa.offset_from || 0),
                    (cpa.offset_to = i || cpa.offset_to || 0));
                var o = path.remake_path(!0, !0),
                    q = !cpa.fixed_side;
                (q && delete cpa.fixed_side, show_path_control_points());
            }, //'dragend': cp_drag_end
        }; //TODO9 plumbs bij control point drags weer aanzetten
    function get_path_custom_flow_attrs(a) {
        function b(a, b, c, d) {
            //cp ep zijn geen punten maar 1 coordinaat van een punt
            var f = Math.round(1e4 * ((a - b) / c)) / 1e4;
            if (0 > f || 1 < f) {
                var g;
                return (
                    0 == d && a < e.x && (g = a - e.x),
                    0 == d && a > e.x && (g = a - e.x - e.width),
                    1 == d && a < e.y && (g = a - e.y),
                    1 == d && a > e.y && (g = a - e.y - e.height),
                    Math.round(1e4 * g) / 1e4
                );
            }
            return f;
        } //als cp binnen bounding box van pad: procentueel tov ep1
        //als cp buiten bounding box van pad: absoluut tov ep1
        var c = a[0],
            d = a[a.length - 1],
            e = calc_bbox_endpoints(c.x, c.y, d.x, d.y),
            f = d.x - c.x || 1,
            g = d.y - c.y || 1,
            h = [];
        return (
            (h = a.slice(1, a.length - 1).map(function (a) {
                return [b(a.x, c.x, f, 0), b(a.y, c.y, g, 1)];
            })),
            h.join(", ")
        );
    }
    var poly_point_move = {
            dragstart: function () {
                //gui.remove_all();
            },
            drag: function (a, b) {
                if (0 != a || 0 != b) {
                    var c = d3.event.subject;
                    ((c.x += a), (c.y += b));
                    var d = gui_buttons
                        .get_path_control_points_as_ref()
                        .map(function (a) {
                            return [a.x, a.y];
                        });
                    (update_poly_points(currentElement, d),
                        currentElement.rough &&
                            delete currentElement.redraw_data);
                }
            },
            dragend: function () {
                //roughing.roughen_if_needed(currentElement);
            },
        },
        cubic_move = {
            drag: function (a, b) {
                var c = gui_buttons.get_el_with_cps();
                (path.set_path_attrs(c), (cpa.fixed_side = !0));
                var e = d3.event.subject,
                    f = parseInt(e.index),
                    g = c.d;
                ((p = path_to_array(g)),
                    move_cubic_cp(
                        a,
                        b,
                        p,
                        f,
                        void 0,
                        d3.event.sourceEvent.shiftKey,
                    ));
                var d = array_to_path(p);
                ((c.d = d),
                    c.rough && delete currentElement.redraw_data,
                    (c.custom_flow = get_path_custom_flow_attrs(p)),
                    (c.fixed_side = !0),
                    show_path_control_points());
            },
        },
        free_move = {
            drag: function (a, b) {
                if (d3.event.subject.index)
                    var c = parseInt(d3.event.subject.index);
                else var c = 0;
                var d = gui_buttons.get_el_with_cps(),
                    e = "path_group" == d.iama,
                    f =
                        (("manhattan" == cpa.flow ||
                            "straight" == cpa.flow ||
                            "hooked" == cpa.flow) &&
                            e) ||
                        (!e && "lineto" == d.flow),
                    g = path_to_array(d.d);
                ((g[c].x += a), (g[c].y += b));
                var h = [
                    g.map(function (a) {
                        var b = a.x,
                            c = a.y;
                        return [b + d.x, c + d.y];
                    }),
                ]; //set_drawing_pos moet abs poitns hebben,
                if (
                    ("drawing" == d.iama && set_drawing_pos(d, h),
                    "path_group" == d.iama && f)
                ) {
                    path.set_path_attrs(d);
                    var i = array_to_line(g);
                    ((d.d = i),
                        d.rough && delete currentElement.redraw_data,
                        (d.custom_flow = get_path_custom_flow_attrs(g)),
                        (d.fixed_side = !0),
                        show_path_control_points());
                }
                ((d3.event.subject.x += a),
                    (d3.event.subject.y += b),
                    d.rough && delete d.redraw_data,
                    gui_buttons.render_path_control_points());
            },
            dragend: function () {
                var a = gui_buttons.get_el_with_cps();
                "drawing" == a.iama &&
                    "add_ons" in a &&
                    Object.keys(a.add_ons).forEach(function (b) {
                        return add_arrow_test(
                            a,
                            b,
                            a.add_ons[b].figure,
                            a.add_ons[b].width,
                            a.add_ons[b].height,
                        );
                    });
            },
        };
    function drag_selector_resize(a, b) {
        if (0 != a || 0 != b) {
            var c = d3.event.subject;
            ((c.x += a),
                (c.y += b),
                0 == c.index
                    ? ((slider.x += a),
                      (slider.y += b),
                      (slider.width -= a),
                      (slider.height -= b))
                    : 1 == c.index
                      ? ((slider.y += b),
                        (slider.width += a),
                        (slider.height -= b))
                      : 2 == c.index
                        ? ((slider.x += a),
                          (slider.width -= a),
                          (slider.height += b))
                        : ((slider.width += a), (slider.height += b)));
        }
    } //TODO kan geen icons aanpassen op mobile
    //TODO kan niet menu positioneren op mobiel
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    var last_zoomed = 0,
        zoom_count = 0;
    function zoomed() {
        var a = d3.event.transform,
            b = d3.event.transform.k; //ALs always render ook altijd transform opnieuw instellen, anders fouten bij inlezen slides en instellen initiele positie van de map
        (a.always_render &&
            ((transform = a), (has_transformed = !0), (zoom_factor = b)),
            demo_mode && text_to_demo_pane("dragging canvas"),
            requestAnimationFrame(function (c) {
                return (
                    !(last_anim && 14 > c - last_anim && !a.always_render) &&
                    void ((last_anim = c),
                    (transform = a),
                    (has_transformed = !0),
                    (zoom_factor = b),
                    cc.clear_canvas(context_single),
                    cc.clear_canvas(hover_context),
                    render_all(c, !1, !0),
                    canvas_status.export_mode && printer.draw_print_region(!0))
                );
            }),
            (zoom_count += 1),
            gridlines.on() && gridlines.make());
    }
    var last_anim = 0;
    document.fonts &&
        (document.fonts.onloadingdone = function () {
            render();
        });
    function canvas_doubleclick_default() {
        if (canvas_status.view_mode) return !1;
        var a = get_xy_inverted_from_event(d3.event),
            b = _slicedToArray(a, 2),
            c = b[0],
            d = b[1],
            e = shapes_storage.find_clickable_shape(c, d);
        if ((demo_mode && text_to_demo_pane("double click", !1, 1e3), e))
            ("gui_resize" == e.iama && handle_gui_resize_double_click(),
                ("path_group" == e.iama ||
                    ("drawing" == e.iama && "line" == e.type)) &&
                    (set_current_element(e),
                    gui_buttons.get_el_with_cps() == e
                        ? (gui_buttons.reset_path_control_points(),
                          gui_buttons.frame_element(currentElement))
                        : "path_group" == e.iama
                          ? show_path_control_points(e)
                          : show_line_control_points(e)),
                "text" == e.iama && gui_cursor.handle_double_click(c, d, e),
                "fa_icon" == e.iama &&
                    (open_modal("icon_modal"),
                    fa_handler.opened_from_canvas(!0)),
                "math_shape" == e.iama && open_math_modal(e));
        else {
            if ("icon_basic" == active_style.shape) add_icon_to_canvas(c, d);
            else if ("math_shape" == active_style.shape)
                math_jax_specs.loaded
                    ? trigger_math("x+y")
                    : start_math().then(function () {
                          trigger_math("x+y");
                      });
            else if ("line" == active_style.shape.split("_")[0])
                add_line_to_canvas();
            else add_active_shape_to_canvas();
            render();
        }
    }
    function add_active_shape_to_canvas() {
        var a = add_shape_to_canvas();
        ((a.width = infinity.get_standard_scaling(120, a.level, 0)),
            (a.height = infinity.get_standard_scaling(70, a.level, 0)));
        var b = to_discrete_position([
                a.x - Math.floor(a.width / 2),
                a.y - Math.floor(a.height / 2),
            ]),
            c = _slicedToArray(b, 2),
            d = c[0],
            e = c[1];
        ((a.x = d), (a.y = e), set_current_element(a));
    }
    function canvas_click_default() {
        if (ignore_svg_click) return ((ignore_svg_click = !1), !1);
        if (
            (demo_mode &&
                (d3.event.ctrlKey
                    ? text_to_demo_pane("control + mouse click", !1, 1e3)
                    : d3.event.shiftKey
                      ? text_to_demo_pane("shift + mouse click", !1, 1e3)
                      : text_to_demo_pane("mouse click", !1, 1e3)),
            cmm.status() && cmm.off(),
            canvas_status.export_mode)
        )
            return !1;
        var a = get_xy_inverted_from_event(d3.event),
            b = _slicedToArray(a, 2),
            c = b[0],
            d = b[1];
        last_pos = to_discrete_position([c, d]);
        var e = shapes_storage.find_clickable_shape(c, d);
        if (canvas_status.view_mode)
            return (
                e &&
                    e.parent &&
                    "text" == e.parent.iama &&
                    is_web_link(e.parent.text) &&
                    window.open(e.parent.text, "_blank"),
                !1
            );
        if (d3.event.ctrlKey && !e)
            return (
                (poly_draw = !0),
                points_for_poly.push(last_pos),
                render_poly_line(points_for_poly, gui_context, !1),
                render_poly_points(points_for_poly, gui_context),
                !1
            );
        if (d3.event.shiftKey && !e)
            return (
                (poly_draw = !0),
                points_for_poly.push(last_pos),
                render_poly_line(points_for_poly, gui_context, !1),
                render_poly_points(points_for_poly, gui_context),
                !1
            );
        if (canvas_status.copy_on && el_to_copy) {
            var f = posit2.get_w_h(el_to_copy),
                g = _slicedToArray(f, 2),
                i = g[0],
                j = g[1],
                h = copy_prepped_shape_to_canvas(
                    el_to_copy,
                    to_discrete_position([
                        last_pos[0] - i / 2,
                        last_pos[1] - j / 2,
                    ]),
                );
            return (
                (el_to_copy = !1),
                (canvas_status.copy_on = !1),
                set_current_element(h),
                !1
            );
        }
        style_copier.is_on() && e
            ? style_copier.copy_styles_to_shape(e)
            : (e && "gui_connect" == e.iama) ||
              (e && "gui_resize" == e.iama) ||
              (e && "gui_flip" == e.iama
                  ? flip_shape(currentElement)
                  : e &&
                      "text" == e.iama &&
                      gui_cursor.has_selection() &&
                      gui_cursor.xy_is_in_range(c, d)
                    ? gui_cursor.range_contains_all_text_in_par()
                        ? gui_cursor.clear_selection()
                        : gui_cursor.select_all_text_in_par_from_range()
                    : e
                      ? (set_current_element(e),
                        display_fs_for_shape(e),
                        gui_buttons.frame_element(currentElement),
                        d3.event.ctrlKey &&
                            manage_groups.toggle_element(
                                part_to_chunk(currentElement),
                                !0,
                            ),
                        d3.event.shiftKey &&
                            (manage_groups.cycle_through_groups_of_shape(
                                currentElement,
                            ),
                            update_quick_grouping_forms()),
                        "path_group" != currentElement.iama &&
                            gui_buttons.reset_path_control_points(),
                        "path_group" == currentElement.iama &&
                            path.set_path_attrs(currentElement),
                        gui_buttons.add_marker_to_example_style(
                            part_to_chunk(e).style_class,
                        ))
                      : (gui_cursor.clear(),
                        to_canvas.set_canvas(),
                        display_fs_for_shape(currentElement),
                        gui_buttons.add_marker_to_example_style(
                            active_style.style_class,
                        ),
                        gui_buttons.clear(),
                        gui_buttons.add_location_circle(),
                        canvas_status.mobile_mode &&
                            display_cursor_mobile_mode(
                                20,
                                last_pos[0],
                                last_pos[1],
                            )));
    }
    function add_canvas_default_click() {
        //TODO9: drag veroorzaakt dragend framelement en vervolgens nog een keer click frame_element
        (canvas.on("click", canvas_click_default),
            canvas.on("dblclick", canvas_doubleclick_default));
    }
    function canvas_slide_exclusion_mode_click() {
        var a = get_xy_inverted_from_event(d3.event),
            b = _slicedToArray(a, 2),
            c = b[0],
            d = b[1];
        last_pos = to_discrete_position([c, d]);
        var e = shapes_storage.find_clickable_shape(c, d);
        return !!e && void slide_manager.handle_exclusion_mode_click(e);
    }
    function add_canvas_slide_exclusion_mode_click() {
        //TODO9: drag veroorzaakt dragend framelement en vervolgens nog een keer click frame_element
        canvas.on("click", canvas_slide_exclusion_mode_click);
    }
    ((document.body.onkeydown = document.body.onkeyup = handle_keyboard),
        (canvas.node().onmousemove = function (a) {
            if (canvas_status.drag_select) return !1;
            if (canvas_status.draw_mode) return !1;
            var b = get_xy_inverted_from_event(a),
                c = _slicedToArray(b, 2),
                d = c[0],
                e = c[1],
                f = shapes_storage.find_clickable_shape(d, e);
            return canvas_status.view_mode
                ? (f && "flipped" in f
                      ? ((canvas.node().style.cursor = "pointer"),
                        gui_buttons.add_hover_highlight(f))
                      : f && "text" == f.iama && is_web_link(f.parent.text)
                        ? (canvas.node().style.cursor = "pointer")
                        : ((canvas.node().style.cursor = "inherit"),
                          gui_buttons.remove_hover_highlight()),
                  !1)
                : void (style_copier.is_on() && f
                      ? ((canvas.node().style.cursor = "copy"),
                        gui_buttons.add_hover_highlight(f, "goldenrod"))
                      : f
                        ? (gui_buttons.remove_hover_highlight(),
                          "path_cp" == f.iama
                              ? (canvas.node().style.cursor = f.cursor)
                              : "gui_resize" == f.iama
                                ? (canvas.node().style.cursor = "se-resize")
                                : "gui_connect" == f.iama
                                  ? (canvas.node().style.cursor = "crosshair")
                                  : "gui_morph" == f.iama
                                    ? (canvas.node().style.cursor = "crosshair")
                                    : "gui_flip" == f.iama
                                      ? (canvas.node().style.cursor = "pointer")
                                      : ((canvas.node().style.cursor =
                                            "text" in f ? "text" : "move"),
                                        gui_buttons.add_hover_highlight(f)))
                        : ((canvas.node().style.cursor = "inherit"),
                          gui_buttons.remove_hover_highlight()));
        }));
    var cumulator_pos = drag_discrete();
    function set_zoom_and_trans(a, b, c) {
        var d =
                !!(3 < arguments.length && arguments[3] !== void 0) &&
                arguments[3],
            e =
                4 < arguments.length && arguments[4] !== void 0
                    ? arguments[4]
                    : render_all,
            f =
                !!(5 < arguments.length && arguments[5] !== void 0) &&
                arguments[5];
        ((goal_transform = get_new_transform(a, b, c)),
            f && (goal_transform.always_render = !0),
            d
                ? canvas
                      .transition()
                      .delay(200)
                      .duration(anim_dur)
                      .call(zoom_behavior.transform, goal_transform)
                      .on("end", e)
                : canvas.call(zoom_behavior.transform, goal_transform));
    }
    function get_new_transform(a, b, c) {
        return d3.zoomIdentity.translate(a, b).scale(c);
    }
    function zoom_to_area(a) {
        var b = a.x,
            c = a.y,
            d = a.width,
            e = a.height,
            f =
                !!(1 < arguments.length && arguments[1] !== void 0) &&
                arguments[1],
            g =
                !!(2 < arguments.length && arguments[2] !== void 0) &&
                arguments[2],
            h =
                3 < arguments.length && arguments[3] !== void 0
                    ? arguments[3]
                    : 6,
            i = calc_zoom_trans(b, c, d, e, h),
            j = _slicedToArray(i, 2),
            k = j[0],
            l = j[1];
        return (
            !(isNaN(k) || isNaN(l[0]) || isNaN(l[1])) &&
            void (g
                ? set_zoom_and_trans(
                      l[0],
                      l[1],
                      k,
                      f,
                      function () {
                          return render_all(0, !1, !0, g);
                      },
                      !f,
                  )
                : set_zoom_and_trans(l[0], l[1], k, f, null, !f))
        );
    }
    function find_scale_and_spare_margins(a, b, c, d) {
        var e =
                !!(4 < arguments.length && void 0 !== arguments[4]) &&
                arguments[4],
            f = (spare_margin_h = 0);
        if (!e)
            var g = Math.max(c, 300),
                i = Math.max(d, 150);
        else
            var g = c,
                i = d;
        var j = a / g,
            k = b / i;
        return (
            e && ((j = Math.min(j, e)), (k = Math.min(k, e))),
            j < k
                ? ((spare_margin_h = b - j * i + (d < i ? j * (i - d) : 0)),
                  (f = a - j * g + (c < g ? j * (g - c) : 0)))
                : ((f = a - k * g + (c < g ? k * (g - c) : 0)),
                  (spare_margin_h = b - k * i + (d < i ? k * (i - d) : 0))),
            [Math.min(j, k), f, spare_margin_h]
        );
    }
    var MARGE_COM = 100,
        MARGE_MENU = 200,
        FADE_MARGIN = 1500;
    function calc_zoom_trans(a, b, c, d) {
        var e =
                !!(4 < arguments.length && arguments[4] !== void 0) &&
                arguments[4],
            f = document
                .querySelector("#sidebar")
                .classList.contains("menu_hidden"),
            g = !f && full_screen ? MARGE_MENU : 0,
            h = canvas_width - g,
            i = canvas_height,
            j = find_scale_and_spare_margins(h, i, c, d, e),
            k = _slicedToArray(j, 3),
            l = k[0],
            m = k[1],
            n = k[2];
        return [l, [-a * l + m / 2, -b * l + n / 2]];
    }
    var zoom_level_start,
        zoom_factor = 1,
        has_transformed = !1,
        zoom_behavior = d3
            .zoom()
            .scaleExtent([1 / 30, 8])
            .on("start", zoom_start)
            .on("zoom", zoomed)
            .on("end", zoom_end);
    function zoom_end() {
        if (
            (currentElement &&
                !canvas_status.slide_mode &&
                set_current_element(currentElement, !0),
            gui_buttons.frame_element(currentElement),
            slides_mode ||
                infinity.get_level() == zoom_level_start ||
                (text_to_feedback_pane(infinity.get_level()),
                (mdd = infinity.get_mdd())),
            d3.event.sourceEvent)
        ) {
            var a = get_xy_inverted_from_event(d3.event.sourceEvent),
                b = _slicedToArray(a, 2),
                c = b[0],
                d = b[1];
            last_pos = to_discrete_position([c, d]);
        }
        (gui_buttons.add_location_circle(),
            canvas_status.export_mode && printer.draw_print_region(),
            has_transformed && to_canvas.set_canvas());
    }
    function zoom_start() {
        (text_for_render.start_sorting(),
            (zoom_level_start = infinity.get_level()),
            gui_cursor.stop_cursor(),
            cc.clear_canvas(gui_context),
            gui_cursor.has_selection() && gui_cursor.clear_selection(),
            cc.clear_canvas(cursor_context),
            (has_transformed = !1));
    }
    function set_button_class(a, b) {
        for (var c = a.querySelectorAll("button"), d = 0; d < c.length; d++)
            c[d].classList.toggle("onoff-on", !1);
        b.classList.toggle("onoff-on", !0);
    }
    (add_canvas_default_click(), add_canvas_drag_default());
    ("use strict");
    function _toConsumableArray(a) {
        return (
            _arrayWithoutHoles(a) ||
            _iterableToArray(a) ||
            _unsupportedIterableToArray(a) ||
            _nonIterableSpread()
        );
    }
    function _nonIterableSpread() {
        throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _iterableToArray(a) {
        if (
            ("undefined" != typeof Symbol && null != a[Symbol.iterator]) ||
            null != a["@@iterator"]
        )
            return Array.from(a);
    }
    function _arrayWithoutHoles(a) {
        if (Array.isArray(a)) return _arrayLikeToArray(a);
    }
    function _createForOfIteratorHelper(b, c) {
        var d =
            ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
            b["@@iterator"];
        if (!d) {
            if (
                Array.isArray(b) ||
                (d = _unsupportedIterableToArray(b)) ||
                (c && b && "number" == typeof b.length)
            ) {
                d && (b = d);
                var e = 0,
                    f = function () {};
                return {
                    s: f,
                    n: function () {
                        return e >= b.length
                            ? { done: !0 }
                            : { done: !1, value: b[e++] };
                    },
                    e: function (a) {
                        throw a;
                    },
                    f: f,
                };
            }
            throw new TypeError(
                "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
            );
        }
        var g,
            h = !0,
            i = !1;
        return {
            s: function () {
                d = d.call(b);
            },
            n: function () {
                var a = d.next();
                return ((h = a.done), a);
            },
            e: function (a) {
                ((i = !0), (g = a));
            },
            f: function () {
                try {
                    h || null == d["return"] || d["return"]();
                } finally {
                    if (i) throw g;
                }
            },
        };
    }
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    } //TODO2 filter voor slides misschien sneller te maken door eerst alle elementen met filter te renderen ??
    //MUST stroke color altijd voor line width, anders gaat pdf printen niet goed
    //geen manier gevonden om line width op nul te zetten, dus als line width voor pdf
    //op nul wordt gezet, wordt ook de stroke color op alpha 0 gezet. Gaat fout als daarna
    //stroke color weer wordt overschreven
    //MUSTDO controleren hoe niet stellen style voor wobble doorwerkt als er verschillen zijn in kleur
    var cc = (function () {
            return (
                (canvas_is_clear = {
                    gui_canvas: !0,
                    cursor_canvas: !0,
                    hover_canvas: !0,
                    draw_canvas_single: !0,
                    draw_canvas: !0,
                }),
                {
                    clear_canvas: function (a) {
                        return (
                            !!a.canvas &&
                            void (
                                !canvas_is_clear[a.canvas.id] &&
                                (a.clearRect(0, 0, canvas_width, canvas_height),
                                (canvas_is_clear[a.canvas.id] = !0))
                            )
                        );
                    },
                    set_has_ink: function (a) {
                        return (
                            !!a.canvas &&
                            void (canvas_is_clear[a.canvas.id] = !1)
                        );
                    },
                    clear_all: function () {
                        (context.clearRect(0, 0, canvas_width, canvas_height),
                            context_single.clearRect(
                                0,
                                0,
                                canvas_width,
                                canvas_height,
                            ),
                            hover_context.clearRect(
                                0,
                                0,
                                canvas_width,
                                canvas_height,
                            ),
                            gui_context.clearRect(
                                0,
                                0,
                                canvas_width,
                                canvas_height,
                            ),
                            cursor_context.clearRect(
                                0,
                                0,
                                canvas_width,
                                canvas_height,
                            ),
                            grid_context.clearRect(
                                0,
                                0,
                                canvas_width,
                                canvas_height,
                            ));
                    },
                    status: function () {
                        return canvas_is_clear;
                    },
                }
            );
        })(),
        view = (function () {
            function a() {
                var a = canvas_width,
                    b = canvas_height,
                    c = -transform.x / transform.k,
                    d = -transform.y / transform.k,
                    e = a / transform.k,
                    f = b / transform.k;
                return { x: c, y: d, width: e, height: f };
            }
            function b(a) {
                if (d) {
                    var b = d.has(a);
                    if (!b) return !1;
                }
                return (
                    a.x + a.width > c.x &&
                    a.x < c.x + c.width &&
                    a.y + a.height > c.y &&
                    a.y < c.y + c.height
                );
            }
            var c,
                d = !1;
            return {
                is_in_view: b,
                set_bbox: function b() {
                    var d =
                        !!(0 < arguments.length && arguments[0] !== void 0) &&
                        arguments[0];
                    c = d ? d : a();
                },
                set_shapes_to_render: function b(a) {
                    d = a;
                },
                clear_shapes_to_render: function a() {
                    d = !1;
                },
                get_view_bbox: a,
            };
        })(); //TODO8 bij plaatsing image ook rekening houden met padding ?
    //TODO8 bij berekening text positie ook rekening houden met border width?
    function render_single(a) {
        last_text_item_rendered = !1;
        var b;
        if (el_on_single) b = el_on_single;
        else return (render_all(), !1);
        var c = context_single;
        if (
            (cc.clear_canvas(c),
            c.save(),
            c.beginPath(),
            c.translate(transform.x, transform.y),
            c.scale(transform.k, transform.k),
            "border" == el_on_single.iama)
        ) {
            (drawBorders(b, c),
                el_on_single.id in shapes_storage.images &&
                    drawImage(shapes_storage.images[el_on_single.id], c));
            var d = get_text_with_border_id(b.id);
            (d.forEach(function (a) {
                return draw_text_border(a, c);
            }),
                d.forEach(function (a) {
                    return drawText(a, c, !0);
                }),
                paths_on_single.forEach(function (a) {
                    return drawPath(a, c);
                }));
        } else
            "math_shape" == el_on_single.iama
                ? render_math_jax_shape(el_on_single, c)
                : "drawing" == el_on_single.iama &&
                  drawDrawing(el_on_single, c);
        (c.restore(), cc.set_has_ink(c));
    }
    render = render_single;
    function get_items_to_render() {
        var a =
                !!(0 < arguments.length && void 0 !== arguments[0]) &&
                arguments[0],
            b =
                !!(1 < arguments.length && void 0 !== arguments[1]) &&
                arguments[1];
        view.set_bbox(a);
        var c = Object.values(shapes_storage.borders).filter(view.is_in_view);
        el_on_single &&
            !b &&
            (c = c.filter(function (a) {
                return a != el_on_single;
            })); //TODO3 kan handiger??
        var d = Object.values(shapes_storage.borders_bound).filter(
            view.is_in_view,
        );
        el_on_single &&
            !b &&
            (d = d.filter(function (a) {
                return a != el_on_single;
            })); //TODO3 kan handiger??
        var e = new Set(
                c.concat(d).map(function (a) {
                    return a.id;
                }),
            ),
            f = text_for_render.get_texts(e),
            g = shapes_storage.paths.filter(view.is_in_view); //const texts_to_draw = render_to_pdf?  _.flatten(Object.values(shapes_storage.texts))  : text_for_render.get_texts(border_ids)
        if (el_on_single && 0 < paths_on_single.length && !b) {
            var h = paths_on_single.map(function (a) {
                return a.id;
            });
            g = g.filter(function (a) {
                return -1 == h.indexOf(a.id);
            });
        }
        if (el_on_single && !b)
            var i = Object.keys(shapes_storage.images).filter(function (a) {
                return a != el_on_single.id;
            });
        else var i = Object.keys(shapes_storage.images);
        var j = shapes_storage.drawings.filter(view.is_in_view);
        el_on_single &&
            "drawing" == el_on_single.iama &&
            !b &&
            (j = j.filter(function (a) {
                return a != el_on_single;
            })); //TODO3 kan handiger??
        var k = Object.values(shapes_storage.math_shapes).filter(
            view.is_in_view,
        ); //TODO3 kan handiger??
        return (
            el_on_single &&
                "math_shape" == el_on_single.iama &&
                !b &&
                (k = k.filter(function (a) {
                    return a != el_on_single;
                })),
            [c, d, f, g, i, j, shapes_storage.icons, k]
        );
    }
    function render_for_pic(a, b, c) {
        var d =
            !!(3 < arguments.length && arguments[3] !== void 0) && arguments[3];
        (a.beginPath(),
            a.translate(c.x, c.y),
            a.scale(c.k, c.k),
            d &&
                (a.save(),
                (a.fillStyle = d),
                a.rect(slider.x, slider.y, slider.width, slider.height),
                a.fill(),
                a.restore()),
            (last_text_item_rendered = !1),
            render_shapes(a, b, get_items_to_render, !0));
    }
    function render_all(a) {
        var b =
                !!(1 < arguments.length && arguments[1] !== void 0) &&
                arguments[1],
            c =
                !!(2 < arguments.length && arguments[2] !== void 0) &&
                arguments[2],
            d =
                3 < arguments.length && arguments[3] !== void 0
                    ? arguments[3]
                    : get_items_to_render,
            e =
                4 < arguments.length && arguments[4] !== void 0
                    ? arguments[4]
                    : context; //num vanwege requestanimtimestamp laten staan
        //console.log(performance.now()-num)
        ((last_text_item_rendered = !1),
            c && cc.clear_canvas(context_single),
            e.save(),
            cc.clear_canvas(e),
            e.translate(transform.x, transform.y),
            e.scale(transform.k, transform.k),
            render_shapes(e, b, d, c),
            slider && draw_slider(slider),
            e.restore(),
            cc.set_has_ink(e));
    }
    function render_shapes(a, b, c, d) {
        wobbles = [];
        var e = c(b, d),
            f = _slicedToArray(e, 8),
            g = f[0],
            h = f[1],
            i = f[2],
            j = f[3],
            k = f[4],
            l = f[5],
            m = f[6],
            n = f[7];
        (j.forEach(function (b) {
            return drawPath(b, a);
        }),
            draw_shapes_in_order(g, a),
            h.forEach(function (b) {
                return drawBorders(b, a);
            }),
            k.forEach(function (b) {
                return drawImage(shapes_storage.images[b], a);
            }),
            i.forEach(function (b) {
                return draw_text_border(b, a);
            }),
            i.forEach(function (b) {
                return drawText(b, a);
            }),
            (context.fillStyle = "#252323"),
            wobbles.forEach(function (a) {
                return drawWobble(a, context);
            }),
            l.forEach(function (b) {
                return drawDrawing(b, a);
            }),
            m.forEach(function (b) {
                return draw_fa_icon(b, a);
            }),
            n.forEach(function (b) {
                return render_math_jax_shape(b, a);
            }));
    }
    function draw_shapes_in_order(a, b) {
        //context.save()
        var c = [];
        (a.forEach(function (a) {
            "draw_order" in a ? c.push(a) : drawBorders(a, b);
        }),
            c.sort(function (c, a) {
                return c.draw_order - a.draw_order;
            }),
            c.forEach(function (a) {
                return drawBorders(a, b);
            }));
    }
    function draw_text_border(a, b) {
        if (a.has_own_style) {
            var c = {};
            if (
                (a.fill && (c.fill = a.fill),
                a.stroke && (c.stroke = a.stroke),
                "stroke_width" in a && (c.stroke_width = a.stroke_width || 0),
                a.stroke_dasharray && (c.stroke_dasharray = a.stroke_dasharray),
                a.filter && (c.filter = a.filter),
                render_to_pdf && !("stroke_width" in c) && (a.stroke_width = 0),
                !("parts" in a))
            )
                return !1;
            var d = a.parts[0],
                e = a.parts[a.parts.length - 1];
            render_text_selection(d.x, e.x + e.width, d, e, c, b);
        }
    }
    function render_current_draw_group(a) {
        (cc.clear_canvas(a),
            a.save(),
            a.translate(transform.x, transform.y),
            a.scale(transform.k, transform.k),
            current_draw_group.forEach(function (b) {
                return drawDrawing(b, a);
            }),
            a.restore(),
            cc.set_has_ink(a));
    }
    function drawDrawing(a, b) {
        (b.save(),
            draw_line_for_drawing(a, b),
            b.restore(),
            "add_ons" in a &&
                Object.keys(a.add_ons).forEach(function (c) {
                    return drawAddon(a.add_ons[c], b);
                }));
    }
    function draw_line_for_drawing(a, b) {
        if (a.rough) roughing.draw(a, b);
        else {
            b.translate(a.x, a.y);
            var c = new Path2D(a.d);
            ((b.strokeStyle = a.stroke),
                (b.lineWidth = a.stroke_width),
                "stroke_dasharray" in a && b.setLineDash(a.stroke_dasharray),
                "canvas" in b
                    ? b.stroke(c)
                    : ((b.fillStyle = "rgba(0,0,0,0)"), b.path(a.d).stroke()));
        }
    } //TODO2 als canvas dragged of zoom maar geen zoomend, rendering met filters uitzetten.
    var wobbles = [];
    function drawText(a, b) {
        var c =
            !!(2 < arguments.length && arguments[2] !== void 0) && arguments[2];
        (b.beginPath(),
            c || no_wobble || !(5 > transform.k * a.font_size)
                ? (set_style_for_text(a, b),
                  a.parts
                      ? render_to_pdf
                          ? ((correction =
                                1.4 == a.line_height
                                    ? 0
                                    : (a.height * a.line_height) / 1.4 / 4),
                            a.parts.forEach(function (a) {
                                return b.fillText(
                                    a.text,
                                    r(a.x),
                                    r(a.y - correction),
                                );
                            }))
                          : a.parts.forEach(function (a) {
                                return b.fillText(
                                    a.text,
                                    r(a.x),
                                    r(a.y + a.baseline_offset),
                                );
                            })
                      : b.fillText(a.text, r(a.x), r(a.y)))
                : (set_style_for_text(a, b), drawWobble(a, b)));
    }
    function drawWobble(a, b) {
        a.parts &&
            a.parts.forEach(function (a) {
                return b.fillRect(a.x, a.y + a.baseline_offset / 2, a.width, 1);
            });
    } // function drawRect(rect, context){
    //     context.save();
    //     context.beginPath();
    //     context.strokeStyle = rect.stroke;
    //     context.fillStyle = rect.fill;
    //     context.lineWidth = rect.stroke_width;
    //     context.rect(rect.x, rect.y, rect.width, rect.height);
    //     context.fill();
    //     context.stroke();
    //     context.restore();
    // }
    // ___ //
    function drawPath(a, b) {
        if ((b.save(), a.rough))
            ("canvas" in b || (b.fillStyle = "rgba(0,0,0,0)"),
                roughing.draw(a, b));
        else {
            b.beginPath();
            var c = new Path2D(a.d);
            ("double" == a.type &&
                ((b.strokeStyle = a.stroke),
                (b.lineWidth = a.outer_width),
                "dasharray_outer" in a && b.setLineDash(a.dasharray_outer),
                "canvas" in b
                    ? b.stroke(c)
                    : ((b.fillStyle = "rgba(0,0,0,0)"), b.path(a.d).stroke())),
                (b.strokeStyle = a.fill),
                (b.lineWidth = a.inner_width),
                "dasharray_inner" in a && b.setLineDash(a.dasharray_inner),
                "filter" in a && (b.filter = a.filter),
                "canvas" in b
                    ? b.stroke(c)
                    : ((b.fillStyle = "rgba(0,0,0,0)"), b.path(a.d).stroke()));
        }
        (b.restore(),
            "add_ons" in a &&
                Object.keys(a.add_ons).forEach(function (c) {
                    return drawAddon(a.add_ons[c], b);
                }));
    }
    function drawAddon(a, b) {
        if (
            (b.save(),
            (b.strokeStyle = a.style.stroke),
            (b.lineWidth = a.style.stroke_width),
            (b.fillStyle = a.style.fill),
            b.translate(a.rotation[1], a.rotation[2]),
            b.rotate(a.rotation[0] * (Math.PI / 180)),
            "poly" == a.specs.fig)
        )
            (b.beginPath(),
                b.moveTo(a.specs.points[0][0], a.specs.points[0][1]),
                a.specs.points.forEach(function (a) {
                    var c = _slicedToArray(a, 2),
                        d = c[0],
                        e = c[1];
                    return b.lineTo(d, e);
                }),
                b.closePath(),
                b.fill(),
                b.stroke());
        else if ("canvas" in b) {
            var c = new Path2D(a.specs.d);
            b.stroke(c);
        } //TODO als pijl wel fill heeft???
        else
            //uitleggen
            ((b.fillStyle = "rgba(0,0,0,0)"), b.path(a.specs.d).stroke());
        b.restore();
    }
    function drawBorders(a, b) {
        "ellipse" == a.shape ? drawEllipse(a, b) : drawPolygon(a, b);
    }
    function r(a) {
        return a; //return Math.floor(x);
        //afronding uitgezet omdat bij volledig ingezoomd paragraven in level 3 shapes niet op gelijke afstand van elkaar werden gerendered
    }
    function drawEllipse(a, b) {
        (b.save(),
            a.rough
                ? roughing.draw(a, b)
                : (b.beginPath(),
                  set_style_for_context(a, b),
                  b.ellipse(
                      a.x + a.width / 2,
                      a.y + a.height / 2,
                      a.width / 2,
                      a.height / 2,
                      0,
                      0,
                      2 * Math.PI,
                  ),
                  b.closePath(),
                  b.fill(),
                  0 < a.stroke_width && b.stroke()),
            b.restore());
    }
    function drawPolygon(a, b) {
        (b.save(),
            a.rough
                ? roughing.draw(a, b)
                : (set_style_for_context(a, b),
                  poly_steps(a, b),
                  b.fill(),
                  0 < a.stroke_width && b.stroke()),
            b.restore());
    }
    var render_to_pdf = !1;
    function poly_steps(a, b) {
        ("scale" in a && b.scale(a.scale, a.scale),
            b.translate(r(a.x), r(a.y)));
        var c = a.width,
            d = a.height;
        if ("points" in a) var e = a.points;
        else
            var e = poly_config[a.shape].points || [
                [0, 0],
                [1, 0],
                [1, 1],
                [0, 1],
            ];
        ((e = e.map(function (a) {
            var b = _slicedToArray(a, 2),
                e = b[0],
                f = b[1];
            return [c * e, d * f];
        })),
            b.beginPath(),
            b.moveTo(e[0][0], e[0][1]),
            e.forEach(function (a) {
                var c = _slicedToArray(a, 2),
                    d = c[0],
                    e = c[1];
                return b.lineTo(r(d), r(e));
            }),
            b.closePath());
    }
    function drawImage(a, b) {
        //void ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
        var c = a.border_data,
            d = find_border_by_id(c.border_id);
        b.drawImage(
            a,
            0,
            0,
            c.img_width,
            c.img_height, //source, x,y ,width, height  of the sub-rectangle of the source image to draw into the destination context.
            //d.x +border.padding, d.y + border.padding, d.border_width, d.border_height //destination The width to draw the image in the destination canvas. This allows scaling of the drawn image.
            c.x,
            c.y,
            c.border_width,
            c.border_height, //destination The width to draw the image in the destination canvas. This allows scaling of the drawn image.
        );
    }
    function set_style_for_context(a, b) {
        //if (compare_styles_of_shapes_for_render(el, last_shape_rendered)){
        ((b.strokeStyle = a.stroke),
            (b.fillStyle = a.fill),
            (b.lineWidth = a.stroke_width),
            a.filter && (b.filter = a.filter),
            a.stroke_dasharray && b.setLineDash(a.stroke_dasharray));
    }
    var last_text_item_rendered = !1;
    function set_style_for_text(a, b) {
        var c =
            !!(2 < arguments.length && arguments[2] !== void 0) && arguments[2];
        if (
            !c &&
            last_text_item_rendered &&
            compare_styles_of_chunks_for_render(a, last_text_item_rendered)
        )
            return !1;
        var d = a.color || a.fill,
            e = predef_styles.get_font_style(a); //infinity.get_alpha(text_item.color || text_item.fill);
        ((b.filter = a.filter || "none"),
            (b.fillStyle = d),
            (b.font = e),
            (last_text_item_rendered = a));
    }
    function render_text_selection(a, b, c, d, e, f) {
        (f.save(),
            "stroke" in e && (f.strokeStyle = e.stroke),
            "fill" in e && (f.fillStyle = e.fill),
            "stroke_width" in e && (f.lineWidth = e.stroke_width),
            "stroke_dasharray" in e && f.setLineDash(e.stroke_dasharray),
            "filter" in e && (f.filter = e.filter),
            f.beginPath());
        var g = [];
        if (c == d)
            "text_border" in d
                ? g.push([d.text_border.x, d.y, d.text_border.width, d.height])
                : g.push([a, c.y, b - a, c.height]);
        else {
            (g.push([a, c.y, c.x + c.width - a, c.height]),
                "text_border" in d
                    ? g.push([
                          d.text_border.x,
                          d.y,
                          d.text_border.width,
                          d.height,
                      ])
                    : g.push([d.x, d.y, b - d.x, d.height]));
            var h,
                i = find_parts_with_border_id(c.border_id).sort(
                    function (c, a) {
                        return c.num - a.num;
                    },
                ),
                j = _createForOfIteratorHelper(i);
            try {
                for (j.s(); !(h = j.n()).done; ) {
                    var k = h.value;
                    k.num > c.num &&
                        k.num < d.num &&
                        g.push([k.x, k.y, k.width, k.height]);
                }
            } catch (a) {
                j.e(a);
            } finally {
                j.f();
            }
        }
        return (
            g.forEach(function (a) {
                var b = _slicedToArray(a, 4),
                    c = b[0],
                    d = b[1],
                    e = b[2],
                    g = b[3];
                return f.rect(c, d, e, g, f);
            }),
            "stroke" in e && 0 < e.stroke_width && f.stroke(),
            "fill" in e && f.fill(),
            f.closePath(),
            f.restore(),
            cc.set_has_ink(f),
            g
        );
    } // ___ //
    function draw_fa_icon(a, b) {
        // context.font = '900 48px "Font Awesome 5 Free"';
        // context.fillText("\uF252", 950, 450);
        // ar code = '1f628';
        // String.fromCodePoint(parseInt(code, 16));
        (b.save(),
            b.beginPath(),
            (b.textBaseline = "top"),
            (b.font =
                a.icon.weight +
                " " +
                a.font_size +
                "px " +
                (a.icon.is_brand
                    ? '"Font Awesome 5 Brands"'
                    : '"Font Awesome 5 Free"')),
            "fill" in a && (b.fillStyle = a.fill),
            "stroke_width" in a,
            (b.lineWidth = a.stroke_width),
            "stroke" in a && (b.strokeStyle = a.stroke),
            b.translate(a.x, a.y),
            "zoom_scale" in a && b.scale(a.zoom_scale, a.zoom_scale),
            "fill" in a &&
                b.fillText(
                    String.fromCodePoint(parseInt(a.icon.code, 16)),
                    0,
                    0,
                ),
            "stroke_width" in a &&
                0 < a.stroke_width &&
                !0 &&
                b.strokeText(
                    String.fromCodePoint(parseInt(a.icon.code, 16)),
                    0,
                    0,
                ),
            b.restore(),
            cc.set_has_ink(b));
    }
    function draw_gui_path(a, b) {
        (b.save(),
            b.beginPath(),
            (b.fillStyle = a.fill),
            (b.lineWidth = a.stroke_width),
            (b.strokeStyle = a.stroke),
            b.translate(a.x, a.y),
            "scale" in a && b.scale(a.scale, a.scale),
            "zoom_scale" in a && b.scale(a.zoom_scale, a.zoom_scale));
        var c = new Path2D(a.d); //context.stroke();
        (b.stroke(c), b.fill(c), b.restore(), cc.set_has_ink(b));
    }
    function render_poly_line(a, b) {
        var c =
            !(2 < arguments.length && arguments[2] !== void 0) || arguments[2]; //context.fill();
        //render_poly_points(poly_points, context);
        (b.save(),
            b.translate(transform.x, transform.y),
            b.scale(transform.k, transform.k),
            b.beginPath(),
            (b.strokeStyle = "yellowgreen"),
            (b.lineWidth =
                "drawing" == currentElement.iama
                    ? currentElement.stroke_width
                    : 2),
            b.moveTo(a[0][0], a[0][1]),
            a.forEach(function (a) {
                var c = _slicedToArray(a, 2),
                    d = c[0],
                    e = c[1];
                return b.lineTo(d, e);
            }),
            c && b.closePath(),
            b.stroke(),
            b.restore(),
            cc.set_has_ink(b));
    }
    function render_poly_points(a, b) {
        //context.stroke();
        (b.save(),
            b.translate(transform.x, transform.y),
            b.scale(transform.k, transform.k),
            b.beginPath(),
            (b.fillStyle = "yellowgreen"),
            a.forEach(function (a) {
                var c = _slicedToArray(a, 2),
                    d = c[0],
                    e = c[1];
                return drawEllipse({ x: d, y: e, width: 4, height: 4 }, b);
            }),
            b.fill(),
            b.restore(),
            cc.set_has_ink(b));
    }
    function draw_slider(a) {
        var b =
            1 < arguments.length && arguments[1] !== void 0
                ? arguments[1]
                : context_single;
        draw_rect_select([a.x, a.y], [a.x + a.width, a.y + a.height], b);
    }
    function draw_rect_select(a, b) {
        var c =
            2 < arguments.length && arguments[2] !== void 0
                ? arguments[2]
                : gui_context;
        (cc.clear_canvas(c),
            c.save(),
            c.beginPath(),
            c.translate(transform.x, transform.y),
            c.scale(transform.k, transform.k),
            (c.fillStyle = "rgba(0,0,360,0.25)"),
            (c.strokeStyle = "black"),
            c.rect(a[0], a[1], b[0] - a[0], b[1] - a[1]),
            c.fill(),
            c.stroke(),
            c.restore(),
            cc.set_has_ink(c));
    }
    function render_hover_highlight(a, b, c) {
        var d =
            3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : 0;
        if (
            (c.save(),
            c.beginPath(),
            c.translate(transform.x, transform.y),
            c.scale(transform.k, transform.k),
            (c.strokeStyle = b),
            (c.lineWidth = 2 * d),
            use_points_for_detection(a))
        )
            poly_steps(a, c);
        else if ("ellipse" == a.shape || "knot" == a.iama)
            c.ellipse(
                a.x + a.width / 2,
                a.y + a.height / 2,
                a.width / 2 + d,
                a.height / 2 + d,
                0,
                0,
                2 * Math.PI,
            );
        else if ("path_group" == a.iama) {
            c.beginPath();
            var e = new Path2D(a.d);
            c.stroke(e);
        } else if ("d" in a) {
            (c.save(), c.translate(a.x, a.y), c.beginPath());
            var f = new Path2D(a.d);
            (c.stroke(f), c.restore());
        } else {
            var g = d / 2; //Math.sqrt( 2*margin*margin);
            c.rect(a.x - g, a.y - g, a.width + 2 * g, a.height + 2 * g);
        }
        (c.stroke(), c.restore(), cc.set_has_ink(c));
    }
    function render_math_jax_shape(a, b) {
        //'rgba(0,0,0,1)';
        // if (shape.rough && !shape.redraw_data){
        //     roughing.draw(shape, context)
        // }else{
        //}
        (b.save(),
            b.translate(a.x, a.y + 0.6 * a.height),
            b.transform(1 / a.scale, 0, 0, -1 / a.scale, 0, 0),
            (b.fillStyle = a.fill),
            (b.strokeStyle = a.stroke),
            (b.lineWidth = a.stroke_width * a.scale),
            render_math_jax_item(a.items, b),
            b.restore());
    }
    function render_math_jax_item(a, b) {
        var c =
            !!(2 < arguments.length && arguments[2] !== void 0) && arguments[2];
        (b.save(),
            b.beginPath(),
            2 == a.trans.length &&
                b.translate.apply(b, _toConsumableArray(a.trans)),
            a.paths.forEach(function (a) {
                (b.save(),
                    a[0].trans && b.scale(a[0].trans[0], a[0].trans[0]),
                    b.translate(parseInt(a[0].x), parseInt(a[0].y))); // if (rough){
                //     roughing.math_jax_draw(p, context)
                // }else{
                var c = new Path2D(a[1]); // }
                (b.stroke(c),
                    "canvas" in b
                        ? (b.stroke(c), b.fill(c))
                        : b.path(a[1]).stroke(),
                    b.restore());
            }),
            a.rects.forEach(function (a) {
                //context.fillStyle = 'black';
                (b.rect(a.x, a.y, a.width, a.height), b.fill(), b.stroke());
            }),
            a.children &&
                a.children.forEach(function (a) {
                    return render_math_jax_item(a, b);
                }),
            b.restore());
    } // function add_text_path(path, text, offset=false){
    //     let p = document.createElementNS("http://www.w3.org/2000/svg", 'path');
    //     const text_length = measure_text_width({text, font_size: 26, font_family:'arial'});
    //     p.setAttribute('d', path.d);
    //     let interval = parseInt(text_length /text.length)
    //     const arr = get_points_along_path(p, interval , 0);
    //     const path_length = p.getTotalLength();
    //     if (!offset && text_length < path_length) offset = (1 - text_length / path_length) / 2;
    //     const reverse = arr[0][0] > arr[arr.length-1][0];
    //     if (reverse) {
    //         //arr.reverse()
    //         var start_index= _.findIndex(arr.map(d=>d[0]), d=>d<arr[0][0] - path_length*offset  );
    //     }else{
    //         var start_index= _.findIndex(arr.map(d=>d[0]), d=>d>path_length*offset + arr[0][0] )
    //     }
    //     console.log(reverse, start_index)
    //     context.save();
    //     gui_context.translate(transform.x, transform.y);
    //     gui_context.scale(transform.k, transform.k);
    //     //context.fillStyle = text_item.color || text_item.fill;
    //     context.font =   "26px arial"   //predef_styles.get_font_style(text_item);
    //     context.textBaseline = 'middle';
    //     text.split('').forEach( (letter, i)=>{
    //         let [x,y] = arr[start_index + i]
    //         context.save()
    //         context.translate(x,y)
    //         context.rotate(calc_angle(arr, start_index+i));
    //         context.fillText(letter, 0,0);
    //         context.restore()
    //     });
    //     context.fill()
    //     context.restore();
    //     function calc_angle(arr, i){
    //         let dx = arr[i+1][0] - arr[i][0];
    //         let dy = arr[i+1][1] - arr[i][1];
    //         let theta = Math.atan2(dy, dx); // range (-PI, PI]
    //         //if (theta < 0) theta = 360 + theta; // range [0, 360)
    //         return theta;
    //     }
    // }
    //TODO2 group move van shapes die op een slide staan.
    //TODO2 edge touch events
    //TODO1 zoomen op touchscreen: hoe ??
    //TODO1 search result orderen bij text grootte (groter font = header = belangrijker)?
    //TODO2 shape toevoegen zonder tekst en zonder border fill (of gelijk aan canvas) >> aanpassen en feedback
    ("use strict");
    function _regenerator() {
        function b(a, b, f, h) {
            var i = b && b.prototype instanceof g ? b : g,
                c = Object.create(i.prototype);
            return (
                _regeneratorDefine2(
                    c,
                    "_invoke",
                    (function (a, b, g) {
                        function h(a, b) {
                            for (
                                m = a, s = b, e = 0;
                                !w && t && !c && e < v.length;
                                e++
                            ) {
                                var c,
                                    f = v[e],
                                    g = p.p,
                                    h = f[2];
                                3 < a
                                    ? (c = h === b) &&
                                      ((s = f[(m = f[4]) ? 5 : ((m = 3), 3)]),
                                      (f[4] = f[5] = k))
                                    : f[0] <= g &&
                                      ((c = 2 > a && g < f[1])
                                          ? ((m = 0), (p.v = b), (p.n = f[1]))
                                          : g < h &&
                                            (c = 3 > a || f[0] > b || b > h) &&
                                            ((f[4] = a),
                                            (f[5] = b),
                                            (p.n = h),
                                            (m = 0)));
                            }
                            if (c || 1 < a) return q;
                            throw ((w = !0), b);
                        }
                        var j,
                            m,
                            s,
                            t = 0,
                            v = g || [],
                            w = !1,
                            p = {
                                p: 0,
                                n: 0,
                                v: k,
                                a: h,
                                f: h.bind(k, 4),
                                d: function c(a, b) {
                                    return (
                                        (j = a),
                                        (m = 0),
                                        (s = k),
                                        (p.n = b),
                                        q
                                    );
                                },
                            };
                        return function (c, f, g) {
                            if (1 < t)
                                throw TypeError("Generator is already running");
                            for (
                                w && 1 === f && h(f, g), m = f, s = g;
                                (e = 2 > m ? k : s) || !w;

                            ) {
                                j ||
                                    (m
                                        ? 3 > m
                                            ? (1 < m && (p.n = -1), h(m, s))
                                            : (p.n = s)
                                        : (p.v = s));
                                try {
                                    if (((t = 2), j)) {
                                        if ((m || (c = "next"), (e = j[c]))) {
                                            if (!(e = e.call(j, s)))
                                                throw TypeError(
                                                    "iterator result is not an object",
                                                );
                                            if (!e.done) return e;
                                            ((s = e.value), 2 > m && (m = 0));
                                        } else
                                            (1 === m &&
                                                (e = j["return"]) &&
                                                e.call(j),
                                                2 > m &&
                                                    ((s = TypeError(
                                                        "The iterator does not provide a '" +
                                                            c +
                                                            "' method",
                                                    )),
                                                    (m = 1)));
                                        j = k;
                                    } else if (
                                        (e = (w = 0 > p.n)
                                            ? s
                                            : a.call(b, p)) !== q
                                    )
                                        break;
                                } catch (a) {
                                    ((j = k), (m = 1), (s = a));
                                } finally {
                                    t = 1;
                                }
                            }
                            return { value: e, done: w };
                        };
                    })(a, f, h),
                    !0,
                ),
                c
            );
        }
        function g() {}
        function h() {}
        function i() {}
        function j(a) {
            return (
                Object.setPrototypeOf
                    ? Object.setPrototypeOf(a, i)
                    : ((a.__proto__ = i),
                      _regeneratorDefine2(a, m, "GeneratorFunction")),
                (a.prototype = Object.create(c)),
                a
            );
        }
        /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var k,
            e,
            f = "function" == typeof Symbol ? Symbol : {},
            l = f.iterator || "@@iterator",
            m = f.toStringTag || "@@toStringTag",
            q = {};
        e = Object.getPrototypeOf;
        var a = [][l]
                ? e(e([][l]()))
                : (_regeneratorDefine2((e = {}), l, function () {
                      return this;
                  }),
                  e),
            c = (i.prototype = g.prototype = Object.create(a));
        return (
            (h.prototype = i),
            _regeneratorDefine2(c, "constructor", i),
            _regeneratorDefine2(i, "constructor", h),
            (h.displayName = "GeneratorFunction"),
            _regeneratorDefine2(i, m, "GeneratorFunction"),
            _regeneratorDefine2(c),
            _regeneratorDefine2(c, m, "Generator"),
            _regeneratorDefine2(c, l, function () {
                return this;
            }),
            _regeneratorDefine2(c, "toString", function () {
                return "[object Generator]";
            }),
            (_regenerator = function a() {
                return { w: b, m: j };
            })()
        );
    }
    function _regeneratorDefine2(a, b, c, e) {
        var f = Object.defineProperty;
        try {
            f({}, "", {});
        } catch (a) {
            f = 0;
        }
        ((_regeneratorDefine2 = function g(a, b, c, e) {
            function h(b, c) {
                _regeneratorDefine2(a, b, function (a) {
                    return this._invoke(b, c, a);
                });
            }
            b
                ? f
                    ? f(a, b, {
                          value: c,
                          enumerable: !e,
                          configurable: !e,
                          writable: !e,
                      })
                    : (a[b] = c)
                : (h("next", 0), h("throw", 1), h("return", 2));
        }),
            _regeneratorDefine2(a, b, c, e));
    }
    function _toConsumableArray(a) {
        return (
            _arrayWithoutHoles(a) ||
            _iterableToArray(a) ||
            _unsupportedIterableToArray(a) ||
            _nonIterableSpread()
        );
    }
    function _nonIterableSpread() {
        throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _iterableToArray(a) {
        if (
            ("undefined" != typeof Symbol && null != a[Symbol.iterator]) ||
            null != a["@@iterator"]
        )
            return Array.from(a);
    }
    function _arrayWithoutHoles(a) {
        if (Array.isArray(a)) return _arrayLikeToArray(a);
    }
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var f = 0, g = Array(c); f < c; f++) g[f] = b[f];
        return g;
    }
    function _iterableToArrayLimit(b, c) {
        var g =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != g) {
            var h,
                j,
                k,
                l,
                m = [],
                a = !0,
                p = !1;
            try {
                if (((k = (g = g.call(b)).next), 0 === c)) {
                    if (Object(g) !== g) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (h = k.call(g)).done) &&
                        (m.push(h.value), m.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((p = !0), (j = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != g["return"] &&
                        ((l = g["return"]()), Object(l) !== l)
                    )
                        return;
                } finally {
                    if (p) throw j;
                }
            }
            return m;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    var cpa = {},
        path = (function () {
            function a(a, b) {
                return a.level > b.level ? a.level : b.level;
            }
            function b() {
                var a,
                    b,
                    e = predef_styles.get_classes()[active_style.style_class];
                return (
                    (b = is_visible_color(e.fill)
                        ? e.fill
                        : is_visible_color(e.stroke)
                          ? e.stroke
                          : "rgba(10,10,10,0.8)"),
                    (a = el.stroke),
                    (el.color = e.color),
                    "double" == cpa.type
                        ? ((a = e.fill),
                          (b = e.stroke),
                          !is_visible_color(a) && (a = "black"),
                          !is_visible_color(b) && (b = "black"))
                        : ((b = e.stroke), (a = b)),
                    [a, b]
                );
            }
            function c(c) {
                var e = b(),
                    f = _slicedToArray(e, 2),
                    g = f[0],
                    h = f[1],
                    i = j(c, cpa.type),
                    k = c[1],
                    l = get_path_pos(k.midpoints, k.cps),
                    m = _slicedToArray(l, 4),
                    n = m[0],
                    o = m[1],
                    p = m[2],
                    q = m[3],
                    r = a(cpa.e1, cpa.e2),
                    s = {
                        id: cpa.id,
                        from_side: k.i,
                        to_side: k.j,
                        type: cpa.type,
                        flow: cpa.flow,
                        pos1: cpa.pos1,
                        pos2: cpa.pos2,
                        d: i,
                        e1: 1,
                        e2: 2,
                        x: n,
                        y: o,
                        width: p,
                        height: q,
                        iama: "path_group",
                        fill: g, //'rgba(20,20,20,0.8)',
                        stroke: h, //'rgba(20,20,20,0.8)',
                        inner_width: infinity.get_standard_scaling(4, r),
                        outer_width: infinity.get_standard_scaling(7, r),
                    };
                return (
                    (cpa.level = r),
                    cpa.manhattan_perc &&
                        (s.manhattan_perc = cpa.manhattan_perc),
                    roughen_all && (s.rough = !0),
                    shapes_storage.paths.push(s),
                    s
                );
            }
            function e(a) {
                var b =
                        !(1 < arguments.length && void 0 !== arguments[1]) ||
                        arguments[1],
                    c = j(a, cpa.type),
                    e = a[1],
                    f = e.midpoints.slice();
                ("original_point_head" in e && (f[1] = e.original_point_head),
                    "original_point_tail" in e &&
                        (f[0] = e.original_point_tail));
                var g = get_path_pos(f, e.cps),
                    h = _slicedToArray(g, 4),
                    i = h[0],
                    k = h[1],
                    l = h[2],
                    m = h[3];
                ((cpa.path_g.d = c),
                    (cpa.path_g.x = i),
                    (cpa.path_g.y = k),
                    (cpa.path_g.width = l),
                    (cpa.path_g.height = m),
                    (cpa.path_g.from_side = a[1].i),
                    (cpa.path_g.to_side = a[1].j),
                    (cpa.path_g.pos1 = cpa.pos1),
                    (cpa.path_g.pos2 = cpa.pos2),
                    (cpa.path_g.offset_from = cpa.offset_from),
                    (cpa.path_g.offset_to = cpa.offset_to),
                    delete cpa.path_g.redraw_data,
                    "add_ons" in cpa.path_g || (cpa.path_g.add_ons = {}),
                    cpa.arrow_head &&
                        (cpa.path_g.add_ons.head = add_shape_to_line_end(
                            a[1],
                            1,
                            cpa.arrow_head,
                        )),
                    cpa.arrow_tail &&
                        (cpa.path_g.add_ons.tail = add_shape_to_line_end(
                            a[1],
                            0,
                            cpa.arrow_tail,
                        )));
                var n = Object.values(shapes_storage.borders_bound).filter(
                    function (a) {
                        return a.path_id == cpa.id;
                    },
                );
                return (
                    n.forEach(function (a) {
                        return repos_text_block(a, cpa.path_g);
                    }),
                    cpa.path_g
                );
            }
            function f() {
                e(k());
            }
            function g(a, b) {
                var c = find_borders_bound_by_path_id(cpa.path_g.id),
                    e = {
                        head_arrow: cpa.arrow_head,
                        tail_arrow: cpa.arrow_tail,
                        arrow_width: cpa.arrow_width,
                        arrow_height: cpa.arrow_height,
                    },
                    f = cpa.e1;
                ((currentElement = cpa.path_g),
                    style_copier.setup_style_copy(),
                    shapes_storage.remove(b),
                    shapes_storage.remove(cpa.path_g));
                var g = cpa.e1 == b ? cpa.e2 : cpa.e1;
                (path.make_new_connection(g, a, !1, { flow: cpa.flow }),
                    c.forEach(function (a) {
                        return (a.path_id = cpa.path_g.id);
                    }),
                    c.forEach(function (a) {
                        return repos_text_block(a, cpa.path_g);
                    })); //TODO2 attach path houd pijl niet vast
                var h = cpa.e1 !== f;
                (i(e, h),
                    style_copier.copy_styles_to_shape(cpa.path_g),
                    path.remake_path(!0));
            }
            function h(a, b) {
                var c = find_borders_bound_by_path_id(a.id),
                    e = {
                        head_arrow: cpa.arrow_head,
                        tail_arrow: cpa.arrow_tail,
                        arrow_width: cpa.arrow_width,
                        arrow_height: cpa.arrow_height,
                    };
                style_copier.setup_style_copy();
                var f = cpa.e1;
                (shapes_storage.remove(a), q(a));
                var g, h;
                (b
                    ? ((g = [cpa.e2.x - 25, cpa.e2.y - 25]), (h = cpa.e1))
                    : ((g = [cpa.e1.x - 25, cpa.e1.y - 25]), (h = cpa.e2)),
                    path_to_nothing(g, h, !1, cpa.flow),
                    c.forEach(function (a) {
                        return (a.path_id = cpa.path_g.id);
                    }),
                    c.forEach(function (a) {
                        return repos_text_block(a, cpa.path_g);
                    }));
                var j = cpa.e1 !== f; // if (head_arrow){
                // 	if (swapped){
                // 		cpa.arrow_tail = head_arrow;
                // 	}else{
                // 		cpa.arrow_head  = head_arrow;
                // 	}
                // }
                // if (tail_arrow){
                // 	if (swapped){
                // 		cpa.arrow_head = tail_arrow;
                // 	}else{
                // 		cpa.arrow_tail = tail_arrow;
                // 	}
                // }
                // if (tail_arrow || head_arrow){
                // 	cpa.arrow_width = arrow_width;
                // 	cpa.arrow_height = arrow_height;
                // }
                (i(e, j),
                    style_copier.copy_styles_to_shape(cpa.path_g),
                    path.remake_path(!0));
            }
            function i(a, b) {
                (a.head_arrow &&
                    (b
                        ? (cpa.arrow_tail = a.head_arrow)
                        : (cpa.arrow_head = a.head_arrow)),
                    a.tail_arrow &&
                        (b
                            ? (cpa.arrow_head = a.tail_arrow)
                            : (cpa.arrow_tail = a.tail_arrow)),
                    (a.tail_arrow || a.head_arrow) &&
                        ((cpa.arrow_width = a.arrow_width),
                        (cpa.arrow_height = a.arrow_height)));
            } //TODO2 in cpa staat soms arrow_to. kan eruit en terugvallen op arrow_head
            function j(a, b) {
                var c = a[1],
                    b = b ? b : active_style.line_style,
                    e = e ? e : active_style.line_flow,
                    f = "manhattan" == e;
                if (cpa.arrow_head || cpa.arrow_tail) {
                    if (cpa.arrow_head) {
                        var g = path_correction_for_arrow(a, 1);
                        ((a[0] = g[0]), (c.original_point_head = g[1]));
                    }
                    if (cpa.arrow_tail) {
                        var g = path_correction_for_arrow(a, 0);
                        ((a[0] = g[0]), (c.original_point_tail = g[1]));
                    }
                }
                return (
                    ("single_stroke" == path_specs[b].thickness ||
                        "double" == path_specs[b].thickness) &&
                        (d = a[0]),
                    d
                );
            }
            function k(a, b) {
                function c() {
                    var a = parseInt(
                        _.findIndex(n, function (a) {
                            return a.i == cpa.from_side && a.j == cpa.to_side;
                        }),
                    );
                    ((k = n.splice(a, 1)[0]),
                        (i = make_d(k)),
                        (h = !!w && f(i)));
                }
                function e(a) {
                    return !0; //Niet duidelijk welk probleem hiermee opgelost werd en
                    //veroorzaakte juist probleem met onnodig geflip tussen sides van pad, daarom uitgezet
                    //return  (c_to_c_pref.dist - c_to_c_alt.dist < MARGIN_PREFERRED);
                }
                function f(a) {
                    elements = Object.values(shapes_storage.borders); //http://stackoverflow.com/questions/16488884/add-svg-element-to-existing-svg-using-dom
                    var b = l(a),
                        c = g(b, elements),
                        e = _.values(c).some(function (a) {
                            return a;
                        }); //if (collision) path_buffer.add_path(cpa.id);
                    return e;
                }
                function g(a, b) {
                    var c =
                            !!(
                                2 < arguments.length && void 0 !== arguments[2]
                            ) && arguments[2],
                        e =
                            3 < arguments.length && void 0 !== arguments[3]
                                ? arguments[3]
                                : 100,
                        f = {},
                        g = get_points_along_path(a, e, 5); //25
                    if (0 == g.length) return { geenpunt: !1 }; //geen punten te controleren, dus geen conflict;
                    for (
                        var h,
                            j,
                            j,
                            k,
                            l = function a() {
                                if (
                                    ((h = b[m]),
                                    "border" == h.iama &&
                                        "rect" != h.shape &&
                                        "ellipse" != h.shape)
                                ) {
                                    var e = get_poly_config(h).points,
                                        i = e.map(function (a) {
                                            var b = _slicedToArray(a, 2),
                                                c = b[0],
                                                e = b[1];
                                            return [
                                                h.x + c * h.width,
                                                h.y + e * h.height,
                                            ];
                                        });
                                    j = _.any(
                                        g.map(function (a) {
                                            return point_is_inside(a, i);
                                        }),
                                    );
                                } else
                                    j = points_in_area(
                                        g,
                                        get_bbox_of_figure(h, !1, !0),
                                        _.any,
                                    );
                                return ((f[h.id] = j), j)
                                    ? { v: c ? [f, g] : f }
                                    : void 0;
                            },
                            m = 0;
                        m < b.length;
                        m++
                    )
                        if (((k = l()), k)) return k.v;
                    return c ? [f, g] : f;
                }
                var h,
                    i,
                    j,
                    k,
                    n = m(),
                    o = []; //kijken of path recent collision heeft
                if (
                    ((!w || path_buffer.check_path(cpa.id)) && (b = !0),
                    (a || b || x) && (c(), o.push([i, k])),
                    b || x || 0 == n.length)
                )
                    return [i, k];
                if (a && e(n[n.length - 1]) && (!h || !w)) return [i, k];
                if (!w) {
                    var j = n.pop(),
                        p = make_d(j);
                    return [p, j];
                }
                for (; 0 < n.length; ) {
                    var j = n.pop(),
                        q = make_d(j);
                    if (!f(q)) return [q, j];
                    o.push([q, j]);
                }
                return (path_buffer.add_path(cpa.id), o[0]);
            }
            function l(a) {
                var b = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "path",
                );
                return (b.setAttribute("d", a), b);
            }
            function m() {
                function a(a) {
                    return "number" == typeof a && 0 <= a && 3 >= a;
                }
                function b(a, b) {
                    var c =
                            2 < arguments.length && void 0 !== arguments[2]
                                ? arguments[2]
                                : 0,
                        e = [a.x, a.y],
                        f = e[0],
                        g = e[1],
                        i = [a.width, a.height],
                        j = i[0],
                        k = i[1],
                        h = !1,
                        l = [a.x, a.y],
                        m = l[0],
                        n = l[1];
                    return (
                        (h =
                            "rect" != a.shape && "knot" != a.iama && 0 == c
                                ? path_placement_correction(a, b, f, g, j, k)
                                : [
                                      [j * b, 0], //top
                                      [j, k * b], //right
                                      [j * b, k], //bottom
                                      [0, k * b], //left
                                  ]),
                        (h[0][1] -= c),
                        (h[1][0] += c),
                        (h[2][1] += c),
                        (h[3][0] -= c),
                        h.map(function (a) {
                            return [m + a[0], n + a[1]];
                        })
                    );
                }
                var c = cpa.from_side,
                    e = cpa.to_side,
                    f = cpa.pos1,
                    g = cpa.pos2,
                    h = [],
                    k = b(cpa.e1, cpa.pos1, cpa.offset_from || 0),
                    l = b(cpa.e2, cpa.pos2, cpa.offset_to || 0);
                if (cpa.fixed_side && a(c) && a(e)) {
                    var m = l[e][0] - k[c][0],
                        n = l[e][1] - k[c][1];
                    return (
                        h.push({
                            i: c,
                            j: e,
                            dist: Math.sqrt(m * m + n * n),
                            dx: m,
                            dy: n,
                            midpoints: [k[c], l[e]],
                        }),
                        h
                    );
                }
                var o = cpa.fixed_side && c ? [c] : [0, 1, 2, 3],
                    p = cpa.fixed_side && e ? [e] : [0, 1, 2, 3];
                for (var q in o) {
                    var r = o[q];
                    for (var s in p) {
                        var t = p[s],
                            m = l[t][0] - k[r][0],
                            n = l[t][1] - k[r][1];
                        h.push({
                            i: r,
                            j: t,
                            dist: Math.sqrt(m * m + n * n),
                            dx: m,
                            dy: n,
                            midpoints: [k[r], l[t]],
                        });
                    }
                }
                return h.sort(function (c, a) {
                    var b = c.i % 2 == c.j % 2 ? 1 : z,
                        e = a.i % 2 == a.j % 2 ? 1 : z;
                    return a.dist * e - c.dist * b;
                });
            }
            function n(a, b) {
                var c = o(a.id, b.id),
                    e = _slicedToArray(c, 2),
                    f = e[0],
                    g = e[1]; //sub =0; //
                ((cpa["class"] = "from" + f + "_to" + g),
                    (cpa.id = cpa["class"]),
                    a.id < b.id
                        ? ((cpa.e1 = a), (cpa.e2 = b))
                        : ((cpa.e2 = a), (cpa.e1 = b)));
            }
            function o(c, e) {
                //id1 < id2 zodat alle paden tussen dezelfde figuren makkelijker gevonden kunnen worden.
                var f = c < e ? c : e,
                    a = c > e ? c : e;
                return [f, a];
            }
            function p() {
                A.forEach(function (a) {
                    cpa[a] = null;
                });
            }
            function q(a) {
                (A.forEach(function (b) {
                    cpa[b] = b in a ? a[b] : null;
                }),
                    (cpa.path_g = a));
                var b = u(cpa.id);
                ((cpa.e1 =
                    shapes_storage.borders[b[0]] ||
                    shapes_storage.knots.filter(function (a) {
                        return a.id == b[0];
                    })[0]),
                    (cpa.e2 =
                        shapes_storage.borders[b[1]] ||
                        shapes_storage.knots.filter(function (a) {
                            return a.id == b[1];
                        })[0]),
                    (cpa.from_side = cpa.path_g.from_side),
                    (cpa.to_side = cpa.path_g.to_side),
                    "add_ons" in a &&
                        (a.add_ons.head &&
                            ((cpa.arrow_head = a.add_ons.head.figure),
                            (cpa.arrow_width = a.add_ons.head.width),
                            (cpa.arrow_height = a.add_ons.head.height)),
                        a.add_ons.tail &&
                            ((cpa.arrow_tail = a.add_ons.tail.figure),
                            (cpa.arrow_width = a.add_ons.tail.width),
                            (cpa.arrow_height = a.add_ons.tail.height))),
                    (cpa.path_g = a),
                    (cpa.offset_from = "offset_from" in a ? a.offset_from : 0),
                    (cpa.offset_to = "offset_to" in a ? a.offset_to : 0));
            }
            function r(a, b, e) {
                var f =
                    !!(3 < arguments.length && arguments[3] !== void 0) &&
                    arguments[3];
                if (a.id != b.id) {
                    (p(),
                        n(a, b),
                        (cpa.pos1 = 0.5),
                        (cpa.pos2 = 0.5),
                        (cpa.type = active_style.line_style),
                        (cpa.flow = active_style.line_flow),
                        f &&
                            Object.keys(f).forEach(function (a) {
                                cpa[a] = f[a];
                            }));
                    var g = k(),
                        h = c(g);
                    return ((cpa.path_g = h),
                    e &&
                        (set_current_element(h),
                        (path_end_fig = "curved_arrow"),
                        cpa.e1 == a
                            ? ((cpa.arrow_to = path_end_fig),
                              change_path_end_fig("head", !0))
                            : ((cpa.arrow_tail = path_end_fig),
                              change_path_end_fig("tail", !0))),
                    f && "disperse" in f && !f.disperse)
                        ? h
                        : (disperse_path_over_side(cpa.e1, g[1].i, MARGIN_DIV),
                          disperse_path_over_side(cpa.e2, g[1].j, MARGIN_DIV),
                          h);
                }
            }
            function s(a) {
                var b =
                        !!(1 < arguments.length && arguments[1] !== void 0) &&
                        arguments[1],
                    f =
                        !(2 < arguments.length && arguments[2] !== void 0) ||
                        arguments[2],
                    g =
                        !!(3 < arguments.length && arguments[3] !== void 0) &&
                        arguments[3],
                    h =
                        !!(4 < arguments.length && arguments[4] !== void 0) &&
                        arguments[4],
                    j = t(a);
                if (0 == j.length) return !1;
                for (var l, m = 0; m < j.length; m++) {
                    ((l = j[m]), q(l));
                    var n = k(!0, b);
                    (e(n, f), !1);
                }
                return !0;
            }
            function t(a, b) {
                return (
                    (ids = b ? b : shapes_storage.paths),
                    ids.filter(function (b) {
                        var c = u(b.id),
                            e = _slicedToArray(c, 2),
                            f = e[0],
                            g = e[1];
                        return (f == a) | (g == a);
                    })
                );
            }
            function u(a) {
                return [a.slice(4, 9), a.slice(12, 17)];
            }
            function v(a, b, c) {
                (q(a),
                    (b = -1 == b ? cpa.from_side : b),
                    (cpa.from_side = b),
                    (cpa.path_g.from_side = b),
                    (c = -1 == c ? cpa.to_side : c),
                    (cpa.to_side = c),
                    (cpa.path_g.to_side = c),
                    (cpa.path_g.fixed_side = !0),
                    (cpa.fixed_side = !0));
            }
            var w = !0,
                x = !1,
                y = 25,
                z = 1.25,
                A = [
                    "class",
                    "id",
                    "e1",
                    "e2",
                    "from_side",
                    "to_side",
                    "pos1",
                    "pos2",
                    "flow",
                    "type",
                    "fixed_side",
                    "arrow_head",
                    "arrow_tail",
                    "arrow_width",
                    "arrow_height",
                    "custom_flow",
                    "path_g",
                    "manhattan_perc",
                    "hg",
                    "tail_style",
                    "head_style",
                    "on_top",
                    "flasher",
                    "offset_from",
                    "offset_to",
                ],
                B = (function () {
                    var a = !1,
                        b = !1;
                    return {
                        turn_off_temporary: function c() {
                            b || ((a = w), (w = !1), (b = !0));
                        },
                        restore: function c() {
                            b && ((w = a), (b = !1));
                        },
                        turn_on: function a() {
                            return (w = !0);
                        },
                        turn_off: function a() {
                            return (w = !1);
                        },
                        status: function a() {
                            return w;
                        },
                    };
                })(),
                C = {
                    turn_on: function a() {
                        return (x = !0);
                    },
                    turn_off: function a() {
                        return (x = !1);
                    },
                    status: function a() {
                        return x;
                    },
                },
                D = !1; //1 = no penalty, > 1 prefer hor or vertical < 1 prefer corners
            return {
                clear_path_attrs: p,
                set_path_attrs: q,
                make_new_connection: function c(a, b) {
                    var e =
                            !!(
                                2 < arguments.length && arguments[2] !== void 0
                            ) && arguments[2],
                        f =
                            !!(
                                3 < arguments.length && arguments[3] !== void 0
                            ) && arguments[3];
                    manage_groups.get_group(a, !0).forEach(function (a) {
                        var c = r(a, b, e, f);
                    });
                },
                recalc_connections: s,
                find_connections: t,
                fix_path_side: v,
                remake_path: function a() {
                    var b =
                            !!(
                                0 < arguments.length && arguments[0] !== void 0
                            ) && arguments[0],
                        c =
                            !!(
                                1 < arguments.length && arguments[1] !== void 0
                            ) && arguments[1];
                    return e(k(b, c));
                },
                redo_path: f,
                change_collision_detection: B,
                change_all_paths_fixed: C,
                extract_elements_from_path_id: u,
                create_svg_path_for_measurement: l,
                detach_path: h,
                find_path: k,
                attach_path: g,
            };
        })(); //currentPathAttributes
    path.clear_path_attrs();
    function make_d(a) {
        function b(a, b, c) {
            var e = 0.3 * a.dist;
            switch (parseInt(b)) {
                case 0:
                    k = [a.midpoints[c][0], a.midpoints[c][1] - e];
                    break;
                case 1:
                    k = [a.midpoints[c][0] + e, a.midpoints[c][1]];
                    break;
                case 2:
                    k = [a.midpoints[c][0], a.midpoints[c][1] + e];
                    break;
                case 3:
                    k = [a.midpoints[c][0] - e, a.midpoints[c][1]];
            }
            return k;
        }
        function c(a, b, c, e) {
            if (e == null)
                var f = line_styles[active_style.line_flow].perpendicular[c],
                    g = line_styles[active_style.line_flow].inline[c];
            else
                var f = line_styles[e].perpendicular[c],
                    g = line_styles[e].inline[c];
            var h = a.dx,
                j = a.dy,
                l = a.midpoints[c][0],
                m = a.midpoints[c][1],
                n = 0 == c ? 1 : -1;
            if ("function" == typeof g)
                switch (parseInt(b)) {
                    case 0:
                        k = [g(l, h, n), f(m, j, n)];
                        break;
                    case 1:
                        k = [f(l, h, n), g(m, j, n)];
                        break;
                    case 2:
                        k = [g(l, h, n), f(m, j, n)];
                        break;
                    case 3:
                        k = [f(l, h, n), g(m, j, n)];
                } //0,2 en 1,3 zijn aan elkaar gelijk
            else
                switch (parseInt(b)) {
                    case 0:
                        ((l = -2 > g || 2 < g ? l + n * g : l + h * g * n),
                            (m = -2 > f || 2 < f ? m + n * f : m + j * f * n),
                            (k = [l, m]));
                        break;
                    case 1:
                        ((m = -2 > g || 2 < g ? m + n * g : m + j * g * n),
                            (l = -2 > f || 2 < f ? l + n * f : l + h * f * n),
                            (k = [l, m]));
                        break;
                    case 2:
                        ((l = -2 > g || 2 < g ? l + n * g : l + h * g * n),
                            (m = -2 > f || 2 < f ? m + n * f : m + j * f * n),
                            (k = [l, m]));
                        break;
                    case 3:
                        ((m = -2 > g || 2 < g ? m + n * g : m + j * g * n),
                            (l = -2 > f || 2 < f ? l + n * f : l + h * f * n),
                            (k = [l, m]));
                }
            return k;
        }
        function e(a) {
            var b =
                    !!(1 < arguments.length && arguments[1] !== void 0) &&
                    arguments[1],
                c = _slicedToArray(a.midpoints, 2),
                e = c[0],
                f = c[1],
                g = Math.abs(e[0] - f[0]),
                h = Math.abs(e[1] - f[1]),
                i = calc_bbox_endpoints.apply(
                    void 0,
                    _toConsumableArray(e).concat(_toConsumableArray(f)),
                ),
                j = i.x,
                k = i.y,
                l = i.width,
                m = i.height;
            if (cpa.custom_flow)
                var n = cpa.custom_flow.split(",").map(function (a) {
                        return parseFloat(a);
                    }),
                    o = [j + l * n[0], k + m * n[1]];
            else if (b) {
                if (0 == a.i) var o = [e[0], e[1] - 0.3 * h];
                else if (1 == a.i) var o = [e[0] + 0.3 * g, e[1]];
                else if (2 == a.i) var o = [e[0], e[1] + 0.3 * h];
                else if (3 == a.i) var o = [e[0] - 0.3 * g, e[1]];
            } else if (0 == a.j) var o = [f[0], f[1] - 0.3 * h];
            else if (1 == a.j) var o = [f[0] + 0.3 * g, f[1]];
            else if (2 == a.j) var o = [f[0], f[1] + 0.3 * h];
            else if (3 == a.j) var o = [f[0] - 0.3 * g, f[1]];
            var p = "M" + e + "L" + o + "L" + f;
            return [p.replace(/[\]\[]/g, ""), o];
        }
        function f(a) {
            function b(a, b, c) {
                return c * a[0][b] + (1 - c) * a[1][b];
            }
            function c() {
                return [(e[0] + f[0]) / 2, (e[1] + f[1]) / 2];
            }
            var e,
                f,
                g = 40,
                h = _slicedToArray(a.midpoints, 2),
                i = h[0],
                j = h[1]; //var start = c_to_c.midpoints[0], end = c_to_c.midpoints[1];
            if (a.i == a.j) {
                //manhattan bow , halve rechthoek
                //var abs = (cpa.manhattan_perc > 1)? cpa.manhattan_perc: MANH_OFFSET;
                var k = cpa.manhattan_perc || 40;
                if (0 == a.i % 2) {
                    //boven naar boven of onder naar onder
                    var l = 0 == a.i ? Math.min : Math.max; //cor =  func(start[1], end[1]) + Math.abs(start[0] - end[0]) * perc * (1 -2*(c_to_c.i==0));
                    ((m = l(i[1], j[1]) + k * (1 - 2 * (0 == a.i))),
                        (e = [i[0], m]),
                        (f = [j[0], m]));
                } else {
                    //links naar links of rechts naar rechts
                    var l = 3 == a.i ? Math.min : Math.max,
                        m = l(i[0], j[0]) + k * (1 - 2 * (3 == a.i));
                    ((e = [m, i[1]]), (f = [m, j[1]]));
                }
            } else if (a.i % 2 != a.j % 2)
                e = 1 == a.i % 2 ? (f = [j[0], i[1]]) : (f = [i[0], j[1]]);
            else if (1 == a.i % 2) {
                //zijkant naar zijkant:
                //mid1: x=midden tussen p1 en p2, y = p1.y
                var n = cpa.manhattan_perc ? cpa.manhattan_perc : 0.5;
                ((e = [b(a.midpoints, 0, n), i[1]]), (f = [e[0], j[1]]));
            } else if (0 == a.i % 2) {
                //boven naar onderkant of andersom
                //y = midden, mid1.x = p1.x
                var n = cpa.manhattan_perc ? cpa.manhattan_perc : 0.5;
                ((e = [i[0], b(a.midpoints, 1, n)]), (f = [j[0], e[1]]));
            }
            var o = "M" + i + "L" + e + "L" + f + "L" + j;
            return [o.replace(/[\]\[]/g, ""), c()];
        } //, arrow_cor){
        //moet in ieder geval d attr retourneren en c_to_c.cps toewijzen aan object c_to_c
        if ("manhattan" == cpa.flow && !cpa.custom_flow) {
            //straight lines with 90deg corners
            var g = f(a),
                h = g[0];
            ((a.manhattan_midpoint = g[1]), (a.cps = [g[1]]));
        } else if ("straight" == cpa.flow && cpa.custom_flow)
            var h = get_path_from_custom_flow(cpa.custom_flow, a, !0);
        else if ("hooked" == cpa.flow || "hooked_rev" == cpa.flow) {
            if (cpa.custom_flow)
                var h = get_path_from_custom_flow(cpa.custom_flow, a, !0);
            else {
                var i = e(a, "hooked_rev" == cpa.flow),
                    j = _slicedToArray(i, 2),
                    h = j[0],
                    k = j[1];
                a.cps = [k];
            }
        } else if (cpa.custom_flow)
            //cubic bezier en straight
            var h = get_path_from_custom_flow(
                cpa.custom_flow,
                a,
                "lineto" == cpa.flow || "manhattan" == cpa.flow,
            );
        else {
            if (a.i == a.j)
                var l = b(a, a.i, 0),
                    m = b(a, a.j, 1);
            else
                var l = c(a, a.i, 0, cpa.flow),
                    m = c(a, a.j, 1, cpa.flow); //, arrow_cor);
            //, arrow_cor);
            var h = make_cubic_bezier_path([
                a.midpoints[0],
                l,
                m,
                a.midpoints[1],
            ]);
            a.cps = [l, m];
        }
        return h;
    }
    function make_cubic_bezier_path(a) {
        var b = a.map(function (a) {
            return { x: round_to(a[0], 0), y: round_to(a[1], 0) };
        });
        return array_to_path(b);
    }
    function array_to_path(a) {
        //array_to_cubic path
        for (
            var b = "M" + a[0].x + "," + a[0].y + " ", c = 1;
            c < a.length;
            c++
        )
            (1 == c % 3 && (b += "C"), (b += a[c].x + "," + a[c].y + " "));
        return b;
    }
    function array_to_line(a) {
        for (
            var b = "M" + round_to(a[0].x, 2) + "," + round_to(a[0].y, 2) + " ",
                c = 1;
            c < a.length;
            c++
        )
            b += "L" + round_to(a[c].x, 2) + "," + round_to(a[c].y, 2) + " ";
        return b;
    }
    function is_cubic_cp_of_type(a, b) {
        //ith = hoeveelste cp van pad (exclusief eindpunten)
        //n = totaal aantal cp's
        return 1 == a || a == b ? "free" : 0 == a % 3 ? "mid" : "bound";
    }
    function path_to_nothing(a, b) {
        var c =
                !!(2 < arguments.length && arguments[2] !== void 0) &&
                arguments[2],
            e =
                !!(3 < arguments.length && arguments[3] !== void 0) &&
                arguments[3],
            f = get_default_knot.apply(void 0, _toConsumableArray(a));
        shapes_storage.knots.push(f);
        var g = {};
        (e && (g = { flow: e }),
            path.make_new_connection(b, f, c, g),
            set_current_element(cpa.path_g));
    }
    function find_paths_on_my_side(a, b) {
        function c(a, b, c) {
            return find_path_by_id(a)[b] == c;
        }
        var e = path.find_connections(a),
            f = e.filter(function (b) {
                var c = path.extract_elements_from_path_id(b.id),
                    e = _slicedToArray(c, 2),
                    f = e[0],
                    g = e[1];
                return g != a;
            }),
            g = e.filter(function (b) {
                var c = path.extract_elements_from_path_id(b.id),
                    e = _slicedToArray(c, 2),
                    f = e[0],
                    g = e[1];
                return g == a;
            });
        return (
            (f = f.filter(function (a) {
                return c(a.id, "from_side", b);
            })),
            (g = g.filter(function (a) {
                return c(a.id, "to_side", b);
            })),
            (f = f.map(function (a) {
                var b = path.extract_elements_from_path_id(a.id),
                    c = _slicedToArray(b, 2),
                    e = c[0],
                    f = c[1];
                return { path: a, fig: f, side: "to_" };
            })),
            (g = g.map(function (a) {
                var b = path.extract_elements_from_path_id(a.id),
                    c = _slicedToArray(b, 2),
                    e = c[0],
                    f = c[1];
                return { path: a, fig: e, side: "from_" };
            })),
            f.concat(g)
        );
    }
    function disperse_path_over_side(a, b, c) {
        function e(a, b) {
            //correctie om te zorgen dat paden elkaar niet kruisen als ze op dezelfde kant landen (alleen voor paden tussen zelfde elementen ??)
            // van onder<> boven of links <> rechts =  standaard = pos percentage hetzelfde
            // vam boven > links of van onder > rechts = standaard = pos percentage hetzelfde
            // anders pos_perc spiegelen a:perc1 b: 1-perc2 door 'to' aan te passen
            //true als correctie nodzakelijk
            var c = 0 == (a + b) % 2;
            if (c && a != b) return !1;
            return (
                (0 != a || 3 != b) &&
                (3 != a || 0 != b) &&
                (1 != a || 2 != b) &&
                (2 != a || 1 != b)
            );
        } // sidenum = 0,1,2,3 = NESW
        //margin is percentage. 1 -  2 x margin van lengte of breedte gebruikt voor verdeling
        var f = a.id,
            g = find_paths_on_my_side(f, b);
        if (1 > g.length) return !1;
        if ("knot" == a.iama) return !1;
        var h = (1 - 2 * c) / (g.length + 1),
            k = c,
            l = g.map(function (a) {
                a["class"] = a.path.id.slice(0, 17);
                var c = find_border_by_id(a.fig),
                    b = [c.x, c.y, c.width, c.height],
                    e = b[0],
                    f = b[1],
                    g = b[2],
                    h = b[3];
                return ((a.box = { x: e, y: f, width: g, height: h }), a);
            });
        func =
            0 == b % 2
                ? function b(c, a) {
                      return (
                          c.box.x +
                          c.box.width / 2 -
                          (a.box.x + a.box.width / 2)
                      );
                  }
                : function b(c, a) {
                      return (
                          c.box.y +
                          c.box.height / 2 -
                          (a.box.y + a.box.height / 2)
                      );
                  };
        for (
            var m = l.sort(function (c, a) {
                    return func(c, a);
                }),
                n = _.groupBy(m, function (a, b) {
                    return a["class"];
                }),
                o = 0;
            o < m.length;
            o++
        ) {
            for (
                var p,
                    q = n[m[o]["class"]].sort(function (c, a) {
                        return c.path < a.path;
                    }),
                    r = q.length,
                    s = 0;
                s < r;
                s++
            )
                ((p = q[s]),
                    path.set_path_attrs(p.path),
                    "from_" == p.side
                        ? (cpa.pos2 = k + h * (1 + o + s))
                        : e(parseInt(cpa.from_side), parseInt(cpa.to_side))
                          ? (cpa.pos1 = k + h * (o + r) - h * s)
                          : (cpa.pos1 = k + h * (1 + o + s)),
                    path.remake_path(!0, !0));
            o += s - 1;
        }
    } // function change_cubic_path_to_line(path_g){
    // 	var d = path_g.querySelector('path').getAttribute('d');
    // 	d = cubic_d_to_line_d(d);
    // 	d3.select(path_g).selectAll('path.mainfig, path.catcher').attr('d', d);
    // 	var ps = path_to_array(d);
    // 	var cf = get_path_custom_flow_attrs(ps);
    // 	path_g.setAttribute('custom_flow', cf);
    // 	path_g.setAttribute('flow', 'lineto');
    // 	if (path_g.querySelector('.cp')){
    // 		toggle_visible();//uit en weer aan zodat nieuwe punt ook meegepakt.
    // 		toggle_visible();
    // 	}
    // }
    // function cubic_d_to_line_d(d){
    // 	ps = path_to_array(d);
    // 	new_ps = []
    // 	push_point(ps[0].x, ps[0].y, 0);
    // 	if (ps.length <5){
    // 		for (var i=1; i<ps.length; i+=1){
    // 			push_point(ps[i].x, ps[i].y, i);
    // 		}
    // 	}else{
    // 		push_point(ps[1].x, ps[1].y, 1);
    // 		for (var i=3; i<ps.length-2; i+=3){
    // 			push_point(ps[i].x, ps[i].y, i);
    // 		}
    // 		var n = ps.length-1
    // 		push_point(ps[n].x, ps[n].y, n);
    // 	}
    // 	return make_line_d(new_ps);
    // 	function push_point(x,y){
    // 		new_ps.push([x,y])
    // 	}
    // 	function __push_point(x, y, i){
    // 		new_ps.push({type: 'L', i: i, x: x, y: y})
    // 	}
    // }
    // function make_line_d(coords){
    // 	var ps = coords.map(d=> {return {x:d[0], y:d[1]}});
    // 	return array_to_line(ps);
    // }
    function get_points_along_path_generator(a, b, c) {
        var e = a.getTotalLength();
        500 < e / b && (b = parseInt(e / 500));
        var f = c;
        return /*#__PURE__*/ _regenerator().m(function g() {
            var h;
            return _regenerator().w(function (g) {
                for (; 1; )
                    switch (g.n) {
                        case 0:
                            if (!(f < e - c)) {
                                g.n = 2;
                                break;
                            }
                            return (
                                (h = a.getPointAtLength(f)),
                                (f += b),
                                (g.n = 1),
                                [h.x, h.y]
                            );
                        case 1:
                            g.n = 0;
                            break;
                        case 2:
                            return g.a(2);
                    }
            }, g);
        });
    }
    function get_points_along_path(a, b, c) {
        //demper geeft enige ruimte voor begin en eind van pad, ging anders fout bij ellipse indien pad niet in midden lag
        var e = a.getTotalLength();
        500 < e / b && (b = parseInt(e / 500));
        for (
            var f, g = [], h = c;
            h < e - c;
            h += b //TODO: firefox 10 keer langzamer
        )
            ((f = a.getPointAtLength(h)), g.push([f.x, f.y]));
        return g;
    }
    function get_path_pos(a, b) {
        var c = a.concat(b),
            e = Math.min.apply(
                null,
                c.map(function (a) {
                    return a[0];
                }),
            ),
            f = Math.min.apply(
                null,
                c.map(function (a) {
                    return a[1];
                }),
            ),
            g = Math.max.apply(
                null,
                c.map(function (a) {
                    return a[0];
                }),
            ),
            i = Math.max.apply(
                null,
                c.map(function (a) {
                    return a[1];
                }),
            ),
            j = g - e,
            k = i - f;
        return [e, f, j, k];
    }
    function calc_bbox_endpoints(a, b, c, e) {
        return {
            x: Math.min(a, c),
            y: Math.min(b, e),
            width: Math.abs(a - c),
            height: Math.abs(b - e),
        };
    }
    function get_path_from_custom_flow(a, b) {
        function c(a, b, c, e) {
            if (0 > a || 1 < a) {
                if (0 == e && 0 > a) return j.x + a;
                if (0 == e && 0 < a) return j.x + j.width + a;
                if (1 == e && 0 > a) return j.y + a;
                if (1 == e && 0 < a) return j.y + j.height + a;
            }
            return a * c + b;
        }
        var e =
                !!(2 < arguments.length && void 0 !== arguments[2]) &&
                arguments[2],
            f = b.midpoints[0],
            g = b.midpoints[1],
            h = a.split(",").map(function (a) {
                return parseFloat(a);
            }),
            j = calc_bbox_endpoints(f[0], f[1], g[0], g[1]),
            k = g[0] - f[0],
            l = g[1] - f[1]; //ep1, ep2 => array met x y coordinaten
        //custom_flow = string met: zie get_path_custom_flow_attrs funtie. geeft interpolatie factor of absolute afstand
        h = h.map(function (a, b) {
            return c(a, f[b % 2], 0 == b % 2 ? k : l, b % 2);
        });
        for (var m = [], n = 0; n < h.length; n += 2) m.push([h[n], h[n + 1]]); //if (line) return make_line_d( [ep1].concat(ps).concat([ep2]) );
        return (
            (b.cps = m),
            e
                ? array_to_line(
                      [f]
                          .concat(m)
                          .concat([g])
                          .map(function (a) {
                              return { x: a[0], y: a[1] };
                          }),
                  )
                : make_cubic_bezier_path([f].concat(m).concat([g]))
        );
    }
    function get_manhattan_perc(a, b) {
        var c = a,
            e = path_to_array(c.d),
            f = e[0],
            g = e.slice(-1)[0],
            f = [f.x, f.y],
            g = [g.x, g.y],
            h = parseInt(c.from_side) % 2,
            i = 1 * !h; //let op: 0 ==y, 1 ==x
        if (cpa.from_side == cpa.to_side) {
            var j = Math.min.apply(
                null,
                [f, g].map(function (a) {
                    return a[i] - b[i];
                }),
            );
            return 1 == cpa.from_side || 2 == cpa.from_side ? -j : j;
        } //perc is 1 als manhattan perc op vanaf kant ligt, 0 als op naar kant ligt,
        //daartussen geinterpoleerd.
        return 1 - (b[i] - f[i]) / (g[i] - f[i]);
    }
    function path_to_array(a) {
        data = a.match(/([A-Z])|(-?\d+\.?\d*)/g);
        for (var b = [], c = "", e = 0; e < data.length; e += 0)
            isNaN(parseFloat(data[e]))
                ? ((c = data[e]), (e += 1), (start_of_el = !0))
                : (b.push({
                      x: parseFloat(data[e]),
                      y: parseFloat(data[e + 1]),
                      i: e,
                      type: c,
                      start: start_of_el,
                  }),
                  (e += 2),
                  (start_of_el = !1));
        return b;
    } // function copy_part_of_path(path, start_len, path_length, text_length, n, offset){
    // 	var d = '', point;
    // 	var step = (text_length) / (n-1);
    // 	var points = [];
    // 	for(var i=0; i< n; i++){
    // 		point = path.getPointAtLength(path_len_to_check(start_len + i*step, path_length));
    // 		if (offset){
    // 			var point2 = path.getPointAtLength(path_len_to_check(start_len + i*step + 2, path_length));
    // 			point = get_offset_for_path(point, point2);
    // 		}
    // 		points.push(point);
    // 	}
    // 	return line_generator(points);
    // 	function get_offset_for_path(p1, p2){
    // 		//returns p1 plus offset
    // 		var dx = p2.x - p1.x
    // 		var dy = p2.y - p1.y;
    // 		var tan = Math.atan(dy/dx);
    // 		var rc = (dx < 0)? -1 : 1;
    // 		var res= { x: p1.x  + Math.sin(tan) * offset[0] * rc,
    //  				  y: p1.y  + Math.cos(tan) * offset[1] * rc
    //  				}
    //  		return res
    // 	}
    // }
    // function path_len_to_check(cur_pos, path_length){
    // 	//mod dubbele lengte zodat continue loop heen en terug over pad
    // 	//als groter dan lengte, lengte - mod lengte, zodat terug telt
    // 	var v = cur_pos % (path_length * 2);
    // 	if (v > path_length) v = path_length - (v % path_length);
    // 	return Math.abs(v);
    // }
    path_buffer = (function () {
        var a = {};
        return {
            check_path: function c(b) {
                if (b in a) {
                    var e = Date.now();
                    return 1e3 > e - a[b]
                        ? ("c" != a[b] &&
                              setTimeout(this.generate_callback(b), 3e3),
                          (a[b] = "c"),
                          !0)
                        : "c" == a[b] || (delete a[b], !1);
                }
                return !1;
            },
            generate_callback: function c(b) {
                return function () {
                    delete a[b];
                };
            },
            add_path: function c(b) {
                b in a || (a[b] = Date.now());
            },
        };
    })();
    function change_path_flow_and_style(a, b, c) {
        path.set_path_attrs(currentElement);
        var e;
        (a
            ? ((cpa.flow = b || "fluid"),
              (currentElement.flow = b || "fluid"),
              (cpa.custom_flow = null),
              delete currentElement.custom_flow,
              (active_style.line_flow = cpa.flow))
            : ((cpa.type = c || "plain"),
              (currentElement.type = c || "plain"),
              (active_style.line_style = cpa.type)),
            path.redo_path(),
            form_update && update_open_fs(currentElement));
    }
    document.querySelector("#cm-path-detach").onclick = function () {
        (path.detach_path(currentElement, "from" != cpa.side), render());
    };
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var h,
                j,
                k,
                l,
                m = [],
                a = !0,
                p = !1;
            try {
                if (((k = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (h = k.call(d)).done) &&
                        (m.push(h.value), m.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((p = !0), (j = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((l = d["return"]()), Object(l) !== l)
                    )
                        return;
                } finally {
                    if (p) throw j;
                }
            }
            return m;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function show_line_control_points(a) {
        gui_buttons.clear();
        var b = path_to_array(a.d).map(function (b) {
            var c = b.x,
                d = b.y;
            return { x: c + a.x, y: d + a.y };
        });
        (setup_path_control_point(a, b[0], "free_endpoint", 0),
            setup_path_control_point(
                a,
                b[b.length - 1],
                "free_endpoint",
                b.length - 1,
            ),
            b.slice(1, -1).forEach(function (b, c) {
                return setup_path_control_point(a, b, "free_endpoint", c + 1);
            }),
            gui_buttons.set_el_with_cps(a),
            gui_buttons.render_path_control_points());
    }
    function show_path_control_points() {
        var a =
            !!(0 < arguments.length && void 0 !== arguments[0]) && arguments[0];
        (gui_buttons.clear(),
            (a = a || currentElement),
            gui_buttons.reset_path_control_points());
        var b = a.d,
            c = path_to_array(b),
            e = a,
            f = 7,
            d = "path_group" == e.iama,
            h = "drawing" == e.iama; //radius circle
        if (
            (setup_path_control_point(e, c[0], "endpoint_from", cpa.from_side),
            setup_path_control_point(
                e,
                c[c.length - 1],
                "endpoint_to",
                cpa.to_side,
            ),
            d && "manhattan" == cpa.flow)
        ) {
            var i = {};
            ((i.x = (c[1].x + c[2].x) / 2),
                (i.y = (c[1].y + c[2].y) / 2),
                setup_path_control_point(e, i, "manhattan"));
        } else
            d && "straight" == cpa.flow
                ? c.slice(1, -1).forEach(function (a, b) {
                      return setup_path_control_point(
                          e,
                          a,
                          "free_endpoint",
                          b + 1,
                          c.length,
                      );
                  })
                : "hooked" == cpa.flow
                  ? setup_path_control_point(e, c[1], "free_endpoint", 1, 1, f)
                  : c.slice(1, -1).forEach(function (a, b) {
                        return setup_path_control_point(
                            e,
                            a,
                            "bezier",
                            b + 1,
                            c.length - 2,
                            f,
                        );
                    });
        (gui_buttons.set_el_with_cps(e),
            gui_buttons.render_path_control_points());
    }
    function show_poly_points(a) {
        "points" in a ||
            console.log(
                "onterecht aanroepen show poly points: geen points arr",
            );
        var b = a.points.map(function (b) {
            var c = _slicedToArray(b, 2),
                d = c[0],
                e = c[1];
            return [a.x + a.width * d, a.y + a.height * e];
        });
        (gui_buttons.reset_path_control_points(),
            b.forEach(function (b, c) {
                setup_path_control_point(
                    a,
                    { x: b[0], y: b[1] },
                    "poly_point",
                    c.toString(),
                );
            }),
            gui_buttons.set_el_with_cps(a),
            gui_buttons.render_path_control_points());
    }
    function setup_path_control_point(a, b, c, d, e) {
        var f,
            h,
            i =
                5 < arguments.length && void 0 !== arguments[5]
                    ? arguments[5]
                    : 7; //r argument niet meer gebruikt sinds afnajelijk gemaakt is van zoomniveau.
        if ("endpoint" == c.slice(0, 8)) {
            var j = end_point_move;
            ((f = "red"),
                (h = 1 == d % 2 ? "ns-resize" : "ew-resize"),
                (d = !1));
        } else if ("manhattan" == c) {
            var j = manhattan_move;
            ((f = "purple"),
                (h = 1 == cpa.to_side % 2 ? "ew-resize" : "ns-resize"));
        } else if ("bezier" == c) {
            var k = is_cubic_cp_of_type(d, e),
                j = cubic_move;
            ((f =
                "free" == k ? "greenyellow" : "bound" == k ? "blue" : "purple"),
                (h = "move"));
        } else if ("poly_point" == c) {
            var j = poly_point_move;
            ((f = "green"), (h = "cell"));
        } else if ("free_endpoint" == c) {
            var j = free_move;
            ((f = "pink"), (h = "cell"));
        } else console.log("onbekende dragtype in add control_point");
        var l = [-5, -5];
        "path_basic" != a.iama && "country_basic" != a.iama; //var zoom = toggle_zoom.get_zoom_factor()
        var m = {
            x: b.x + l[0],
            y: b.y + l[1],
            index: d,
            drag_type: c,
            drag_func: j,
            width: 10,
            height: 10,
            cursor: h,
            fill: f,
            iama: "path_cp",
        };
        return (gui_buttons.add_path_control_point(m), m);
    }
    function move_all_control_points(a, b) {
        "path_group" == gui_buttons.get_el_with_cps().iama
            ? show_path_control_points(gui_buttons.get_el_with_cps())
            : gui_buttons
                  .get_path_control_points_as_ref()
                  .forEach(function (c) {
                      ((c.x += a), (c.y += b));
                  });
    }
    function move_cubic_cp(a, b, c, d, e) {
        var f =
                !!(5 < arguments.length && void 0 !== arguments[5]) &&
                arguments[5],
            h = [];
        if (((e = e || is_cubic_cp_of_type(d, c.length - 2)), "mid" == e && !f))
            ((h = [d - 1, d, d + 1]),
                h.forEach(function (e) {
                    ((c[e].x += a), (c[e].y += b));
                }));
        else if ("bound" == e && !f) {
            //(i != 1 && i != points.length-2){//bound
            //gespiegeld bewegen van andere bound
            var i = 2 == d % 3 ? d + 2 : d - 2; //console.log(check_if_cps_mirrored(points[i], points[ii],  points[(i+ii)/2] ));
            ((c[d].x += a),
                (c[d].y += b),
                (c[i].x -= a),
                (c[i].y -= b),
                (h = [d, i]));
        } //free
        else
            // new_coords[0];
            // new_coords[1];
            ((c[d].x += a), (c[d].y += b), (h = [d]));
        "path_basic" == currentElement.iama ||
            "country_basic" == currentElement.iama ||
            (offset = [0, 0]);
    }
    function add_cp_to_path(a) {
        var b = path_to_array(a.d).map(function (a) {
                return [a.x, a.y];
            }),
            c = "manhattan" == a.flow || "straight" == a.flow;
        if (c)
            var e = b.pop(),
                f = b.pop(),
                h = [(e[0] + f[0]) / 2, (e[1] + f[1]) / 2],
                i = b.concat([f, h, e]);
        else if (4 < b.length) {
            var i = casteljau_insert(b.splice(0, 4), 0.5);
            i = i.concat(b);
        } else var i = casteljau_insert(b, 0.5);
        i = i.map(function (a) {
            return { x: a[0], y: a[1] };
        });
        var j = c ? array_to_line(i) : array_to_path(i);
        a.d = j;
    }
    function casteljau_insert(b, c) {
        function d(a) {
            var d = b.map(function (b) {
                    return b[a];
                }),
                e = _slicedToArray(d, 4),
                f = e[0],
                h = e[1],
                i = e[2],
                j = e[3],
                k = (1 - c) * f + c * h,
                l = (1 - c) * h + c * i,
                m = (1 - c) * i + c * j,
                n = (1 - c) * k + c * l,
                o = (1 - c) * l + c * m,
                p = (1 - c) * n + c * o;
            return [
                [f, k, n, p],
                [p, o, m, j],
            ];
        } //knot insertion problem
        //http://stackoverflow.com/questions/2613788/algorithm-for-inserting-points-in-a-piecewise-cubic-b%C3%A9zier-path
        var a = d(0),
            e = _slicedToArray(a, 2),
            f = e[0],
            h = e[1],
            i = d(1),
            j = _slicedToArray(i, 2),
            k = j[0],
            l = j[1],
            m = _.zip(f, k),
            n = _.zip(h, l);
        return m.concat(n.splice(1));
    }
    function straighten_cps(a) {
        // d3.select(path_g).selectAll('path').attr('d', array_to_path(ps));
        // d3.select(path_g)
        // 	.attr('custom_flow', get_path_custom_flow_attrs(ps)) //p[0], p[3], p[1], p[2]) )
        // 	.attr('fixed_side', 'true');
        //add_lines_to_control_points(ps);
        function b(d) {
            var e = _slicedToArray(d, 3),
                f = e[0],
                a = e[1],
                b = e[2];
            return (
                (a.x = (f.x + b.x) / 2),
                (a.y = (f.y + b.y) / 2),
                [a.x, a.y]
            );
        }
        var c = a.d,
            d = path_to_array(c),
            e = gui_buttons.get_path_control_points_as_ref();
        if (4 < d.length && a.custom_flow)
            for (var f = 3; f < d.length - 2; f += 3) {
                var h = b(d.slice(f - 1, f + 2)),
                    j = _slicedToArray(h, 2),
                    k = j[0],
                    l = j[1],
                    m = e[f];
                ((m.x = k), (m.y = l));
            }
        ((a.d = array_to_path(d)),
            (a.custom_flow = get_path_custom_flow_attrs(d)),
            (a.fixed_side = !0));
    }
    function draw_slider_resize_points() {
        ((positions = [
            [slider.x - 5, slider.y - 5],
            [slider.x + slider.width - 5, slider.y - 5],
            [slider.x - 5, slider.y + slider.height - 5],
            [slider.x + slider.width - 5, slider.y + slider.height - 5],
        ]),
            gui_buttons.reset_path_control_points(),
            positions.forEach(function (a, b) {
                gui_buttons.add_path_control_point({
                    cursor: [
                        "nw-resize",
                        "ne-resize",
                        "sw-resize",
                        "se-resize",
                    ][b],
                    index: b,
                    x: a[0],
                    y: a[1],
                    drag_type: "poly_point",
                    drag_func: poly_point_move,
                    width: 10,
                    height: 10,
                    fill: "red",
                    iama: "slider_cp",
                });
            }),
            gui_buttons.set_el_with_cps(slider),
            gui_buttons.render_path_control_points(!0));
    }
    function add_lines_to_control_points(a) {
        function b(a, b) {
            render_poly_line(
                [
                    [a.x, a.y],
                    [b.x, b.y],
                ],
                gui_context,
            );
        }
        var c =
            !!(1 < arguments.length && arguments[1] !== void 0) && arguments[1];
        if (2 < a.length)
            for (var d = a.slice(1, -1), e = 0; e < d.length - 1; e += 3)
                if (c) {
                    var f = { x: d[e].x + c[0], y: d[e].y + c[1] },
                        h = { x: d[e + 1].x + c[0], y: d[e + 1].y + c[1] },
                        j = { x: d[e + 2].x + c[0], y: d[e + 2].y + c[1] };
                    (b(f, h), b(h, j));
                } else (b(d[e], d[e + 1]), b(d[e + 1], d[e + 2]));
    }
    ((document.querySelector("#form_path_add_control_point").onclick =
        function () {
            //if (svg.node().querySelector('.cp')) toggle_visible();
            if ("manhattan" == g.flow)
                return (
                    text_to_feedback_pane(
                        "currently not possible for paths with flow manhattan",
                    ),
                    !1
                );
            add_cp_to_path(currentElement);
            var a = currentElement.d;
            ((cpa.custom_flow = get_path_custom_flow_attrs(path_to_array(a))),
                (currentElement.custom_flow = cpa.custom_flow),
                (currentElement.fixed_side = !0),
                show_path_control_points());
        }),
        (document.querySelector("#form_path_toggle_cps").onclick = function () {
            currentElement == gui_buttons.get_el_with_cps()
                ? (gui_buttons.reset_path_control_points(),
                  gui_buttons.frame_element(currentElement))
                : show_path_control_points(currentElement);
        }),
        $(".cm_button_toggle_poly_point").on("click", function () {
            currentElement == gui_buttons.get_el_with_cps()
                ? (gui_buttons.reset_path_control_points(),
                  gui_buttons.frame_element(currentElement))
                : show_poly_points(currentElement);
        }),
        $(".cm_button_add_point").on("click", function () {
            add_point_to_polygon(currentElement, last_pos);
        }),
        (document.querySelector("#form_path_straighten_cps").onclick =
            function () {
                (straighten_cps(currentElement),
                    show_path_control_points(),
                    render());
            }),
        $(".cm-show-path-basic-points").on("click", function () {
            show_line_control_points(currentElement);
        }),
        (document.querySelector("#cm-show-drawing-points").onclick =
            function () {
                show_line_control_points(currentElement);
            }));
    ("use strict");
    function _slicedToArray(c, d) {
        return (
            _arrayWithHoles(c) ||
            _iterableToArrayLimit(c, d) ||
            _unsupportedIterableToArray(c, d) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(c, d) {
        if (c) {
            if ("string" == typeof c) return _arrayLikeToArray(c, d);
            var e = {}.toString.call(c).slice(8, -1);
            return (
                "Object" === e && c.constructor && (e = c.constructor.name),
                "Map" === e || "Set" === e
                    ? Array.from(c)
                    : "Arguments" === e ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)
                      ? _arrayLikeToArray(c, d)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(c, d) {
        (null == d || d > c.length) && (d = c.length);
        for (var f = 0, g = Array(d); f < d; f++) g[f] = c[f];
        return g;
    }
    function _iterableToArrayLimit(c, d) {
        var g =
            null == c
                ? null
                : ("undefined" != typeof Symbol && c[Symbol.iterator]) ||
                  c["@@iterator"];
        if (null != g) {
            var h,
                j,
                k,
                l,
                m = [],
                p = !0,
                q = !1;
            try {
                if (((k = (g = g.call(c)).next), 0 === d)) {
                    if (Object(g) !== g) return;
                    p = !1;
                } else
                    for (
                        ;
                        !(p = (h = k.call(g)).done) &&
                        (m.push(h.value), m.length !== d);
                        p = !0
                    );
            } catch (c) {
                ((q = !0), (j = c));
            } finally {
                try {
                    if (
                        !p &&
                        null != g["return"] &&
                        ((l = g["return"]()), Object(l) !== l)
                    )
                        return;
                } finally {
                    if (q) throw j;
                }
            }
            return m;
        }
    }
    function _arrayWithHoles(c) {
        if (Array.isArray(c)) return c;
    }
    function append_options(c, d) {
        d.forEach(function (d) {
            $(c).append($("<option></option>").attr("value", d).text(d));
        });
    }
    var fonts = [
        "PT Sans",
        "Cabin",
        "Zilla Slab",
        "Roboto",
        "Open Sans",
        "Ubuntu", //'monospace', 'Arial',
        "Lato",
        "Roboto condensed",
        "Source Code Pro",
        "Ubuntu Condensed",
        "Comfortaa",
        "Hind",
        "Lora",
        "Aleo",
        "Montserrat",
        "Raleway",
        "Acme",
        "Amatic SC",
        "Handlee",
        "Caveat",
        "Schoolbell",
        "Athiti",
        "Kalam",
        "Sacramento",
        "Quattrocento",
        "Arimo",
        "Exo",
        "Cinzel",
        "Orbitron",
        "Audiowide",
    ];
    (append_options(".form_font_list", fonts),
        append_options("#predef_font_list", fonts));
    function change_font(c) {
        var d = c.target.innerText;
        ("text" == currentElement.iama &&
            check_for_range_when_p_form_action(currentElement),
            manage_groups.get_group(currentElement, !0).forEach(function (c) {
                ("text" == c.iama
                    ? ((c = part_to_chunk(c)),
                      change_font_fam_for_chunk(c, d),
                      (c.font_fam_inherited = !1))
                    : change_font_fam_for_border(c, d),
                    resize_if_wanted_after_font_change(c));
            }),
            render_all(!1, !1, !0));
    }
    function change_font_fam_for_border(c, d) {
        ((c.font_family = d), predef_styles.style_class_to_custom(c));
        var e = get_text_with_border_id(c.id);
        e.forEach(function (e) {
            e.font_fam_inherited && change_font_fam_for_chunk(e, d);
        });
    }
    function change_font_fam_for_chunk(c, d) {
        c.font_family = d;
    }
    plus_minus_generator(
        document.getElementById("form_max_width"),
        function (c) {
            ((max_border_width = parseInt(c.value)),
                (this.value = max_border_width));
        },
        100,
        0,
    );
    function resize_if_wanted_after_font_change(c) {
        var d =
                !!(1 < arguments.length && arguments[1] !== void 0) &&
                arguments[1],
            e =
                !!(2 < arguments.length && arguments[2] !== void 0) &&
                arguments[2],
            f =
                "width" ==
                document.querySelector(
                    '#form_font_resize_action input[name="action"]:checked',
                ).value;
        "text" == c.iama && (c = find_border_by_id(c.border_id));
        var g = c.id;
        shapes_storage.texts[g] &&
            (path.change_collision_detection.turn_off_temporary(),
            path.change_all_paths_fixed.turn_on(),
            (f || (!d && e)) &&
                recalc_border_width(g, !0, !0, key_pressed[16] || d),
            position_texts(g),
            (!f || (!d && e)) && recalc_border_height(g, key_pressed[16]),
            path.change_collision_detection.restore(),
            path.change_all_paths_fixed.turn_off());
    }
    ((document.querySelector("#form_font_size .plus").onmousedown =
        function () {
            var c = document.querySelector("#form_font_size input"),
                d = parseInt(c.value);
            ((c.value = d + 1), $("#form_font_size input").change());
        }),
        (document.querySelector("#form_font_size .minus").onmousedown =
            function () {
                ((document.querySelector("#form_font_size input").value -= 1),
                    $("#form_font_size input").change());
            }),
        [1, 2, 3, 4, 5].forEach(function (c) {
            $(".font" + c + "_holder").on("click", function () {
                change_font_class(c - 1);
            });
        }));
    function change_font_class(c) {
        check_for_range_when_p_form_action(); //var font_size = predef_styles.font_sizes[font_class];
        //var font_size = predef_styles.scaled_font_sizes[currentElement.level || "L1"][font_class];
        var d =
                "text" == currentElement.iama
                    ? shapes_storage.borders[currentElement.border_id].level
                    : currentElement.level,
            e = infinity.get_font_size(d || "L1", c),
            f = manage_groups.get_group(currentElement, !0);
        (f.forEach(function (c) {
            var d = c.font_size,
                f = change_font_size_of_el(c, e);
            f && resize_if_wanted_after_font_change(c, d < e, !0);
        }),
            (document.querySelector("#form_font_size input").value = e),
            font_button_on_off(c),
            gui_buttons.frame_element(currentElement),
            set_current_element(currentElement));
    }
    function part_to_chunk(c) {
        return c && "parent" in c ? c.parent : c;
    }
    function change_font_size_of_el(c, d) {
        if ("text" == c.iama)
            ((c = part_to_chunk(c)),
                (c.font_size_inherited = !1),
                (c.font_size = d),
                measure_text(c));
        else {
            if ("fa_icon" == c.iama)
                return ((c.font_size = d), (c.width = d), (c.height = d), !1);
            (predef_styles.style_class_to_custom(c), (c.font_size = d));
            var e = get_text_with_border_id(c.id);
            e.forEach(function (c) {
                c.font_size_inherited && ((c.font_size = d), measure_text(c));
            });
        }
        return !0;
    }
    function font_button_on_off(c) {
        d3.selectAll(".form_font_class button").classed("onoff-on", !1);
        for (
            var d = document.querySelectorAll(
                    ".form_font_class button:nth-child(" + (c + 2) + ")",
                ),
                e = 0;
            e < d.length;
            e++
        )
            d[e].classList.toggle("onoff-on", !0);
    }
    function toggle_font_class(c, d) {
        var e = predef_styles.is_font_class(c, d);
        font_button_on_off(e);
    }
    document.querySelector("#form_font_size input").onchange = function () {
        "text" == currentElement.iama && check_for_range_when_p_form_action();
        var c = parseInt($("#form_font_size input").val());
        (manage_groups.get_group(currentElement, !0).forEach(function (d) {
            var e = d.font_size,
                f = change_font_size_of_el(d, c);
            f && resize_if_wanted_after_font_change(d, e < c);
        }),
            gui_buttons.frame_element(currentElement),
            set_current_element(currentElement));
    };
    function get_height_of_par(c) {
        //INCLUSIEF MARGIN TOP
        for (var d, e = 0, f = 0, g = Object.entries(c); f < g.length; f++)
            ((d = _slicedToArray(g[f], 2)),
                (line_num = d[0]),
                (parts = d[1]),
                (e += Math.max.apply(
                    null,
                    parts.map(function (c) {
                        return (
                            c.height +
                            (0 == line_num) * (c.parent.margin_top || 0)
                        );
                    }),
                )));
        return e;
    }
    function get_height_per_par(c) {
        //INCLUSIEF MARGIN TOP
        for (var d, e = {}, f = 0, g = Object.entries(c); f < g.length; f++) {
            ((d = _slicedToArray(g[f], 2)), (a = d[0]), (b = d[1]));
            var h = _.flatten(
                b.map(function (c) {
                    return c.parts;
                }),
            ).filter(function (c) {
                return c;
            }); //undefined filteren, kan voorkomen als range voor of achter "" als text heeft
            if (1 == h.length)
                //komt soms vanuit toevoegen nieuwe shape door typen hier terecht zonder parts
                e[a] =
                    h[0].parent.line_height * h[0].parent.font_size +
                    (h[0].parent.margin_top || 0);
            else {
                var i = _.groupBy(h, function (c) {
                    return c.line_num;
                });
                e[a] = get_height_of_par(i);
            }
        }
        return e;
    }
    function get_width_of_par(c) {
        for (var d, e = 0, f = 0, g = Object.entries(c); f < g.length; f++)
            ((d = _slicedToArray(g[f], 2)),
                (line_num = d[0]),
                (parts = d[1]),
                (e = Math.max(
                    e,
                    parts
                        .map(function (c) {
                            return c.height;
                        })
                        .reduce(function (e, c) {
                            return e + c;
                        }),
                    0,
                )));
        return e;
    }
    function get_width_per_par(c) {
        for (
            var d, e = {}, f = 0, g = Object.entries(c);
            f < g.length;
            f++ // let parts = _.flatten(b.map(d=>d.parts))
        )
            // let parts_by_line_in_par = _.groupBy(parts, d=>d.line_num)
            // res[a] = get_width_of_par(parts_by_line_in_par);
            ((d = _slicedToArray(g[f], 2)),
                (a = d[0]),
                (b = d[1]),
                (e[a] =
                    b.reduce(function (c, e) {
                        return e.width + c;
                    }, 0) + (b[0].margin_left || 0)));
        return e;
    }
    function measure_total_text_height(c) {
        return Object.values(c).reduce(function (c, e) {
            return c + e;
        }, 0);
    }
    function measure_text_width(c) {
        gui_context.font = predef_styles.get_font_style(c);
        var d = gui_context.measureText(c.text).width;
        return d;
    }
    function measure_max_text_width(c) {
        return ((by_line = Object.values(c)), Math.max.apply(void 0, by_line));
    }
    function recalc_text_widths(c) {
        var d = get_text_with_border_id(c);
        d.forEach(function (c) {
            var d = measure_text_width(c);
            c.width = Math.max(d, MIN_PAR_WIDTH);
        });
        var e = borders_bound.filter(function (e) {
            return e.border_id == c;
        });
        e.forEach(function (c) {
            return recalc_text_widths(c.id);
        });
    }
    function measure_text(c) {
        ((c.height = round_to(c.font_size * c.line_height, 2)),
            (c.width = round_to(measure_text_width(c), 2)));
    }
    var get_dict_with_vals = (function () {
        var c = {};
        return function (d) {
            var e = predef_styles.get_font_style(d);
            if (!(e in c)) {
                gui_context.font = e;
                var f = {};
                ([
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G",
                    "H",
                    "I",
                    "J",
                    "K",
                    "L",
                    "M",
                    "N",
                    "O",
                    "P",
                    "W",
                    "Q",
                    "R",
                    "S",
                    "T",
                    "U",
                    "V",
                    "W",
                    "X",
                    "Y",
                    "Z",
                    "a",
                    "b",
                    "c",
                    "d",
                    "e",
                    "f",
                    "g",
                    "h",
                    "i",
                    "j",
                    "k",
                    "l",
                    "m",
                    "n",
                    "o",
                    "p",
                    "q",
                    "r",
                    "s",
                    "t",
                    "u",
                    "v",
                    "w",
                    "x",
                    "y",
                    "z",
                    "0",
                    "1",
                    "2",
                    "3",
                    "4",
                    "5",
                    "6",
                    "7",
                    "8",
                    "9",
                    ",",
                    ".",
                    "/",
                    ";",
                    ":",
                    "[",
                    "]",
                    "\\",
                    "=",
                    "+",
                    "-",
                    "{",
                    "}",
                    "|",
                    "<",
                    ">",
                    "?",
                    "!",
                    "@",
                    "#",
                    "$",
                    "%",
                    "^",
                    "&",
                    "*",
                    "(",
                    ")",
                    "~",
                    "`",
                    "'",
                    '"',
                    " ",
                ].map(function (c) {
                    f[c] = gui_context.measureText(c).width;
                }),
                    (c[e] = f));
            }
            return c[e];
        };
    })(); //p: part of chunk
    function measure_par_width_at_each_letter(c) {
        var d,
            e = [0];
        d =
            "parent" in c
                ? get_dict_with_vals(c.parent)
                : get_dict_with_vals(c);
        try {
            c.text.split("").map(function (c) {
                if (c in d) var f = d[c];
                else var f = gui_context.measureText(c).width;
                e.push(f);
            });
        } catch (c) {
            debugger;
        }
        for (var f = 1; f < e.length; f++) e[f] += e[f - 1];
        return e;
    }
    ($(".button_bold").on("mousedown", function () {
        add_styling_to_par("bold");
    }),
        $(".button_italic").on("mousedown", function () {
            add_styling_to_par("italic");
        }));
    function add_styling_to_par(c) {
        (check_for_range_when_p_form_action(),
            manage_groups.get_group(currentElement, !0).forEach(function (e) {
                "font_style" in e
                    ? e.font_style.includes(c)
                        ? (e.font_style = e.font_style.replace(c, "").trim())
                        : (e.font_style += " " + c)
                    : (e.font_style = c);
            }),
            render_all(!1, !1, !0));
    }
    var paragraph_prefixes = {
        bullet: !1,
        triangle: !1,
        rhombus: !1,
        check: !1,
        cross: !1,
        arrow: !1,
        letter: !0,
        number: !0,
        roman: !0,
    };
    ($(".form_paragraph_prefix").on("click", function (c) {
        "BUTTON" == c.target.tagName &&
            (manage_groups.get_group(currentElement).forEach(function (d) {
                ((d = part_to_chunk(d)),
                    (d.text = paragraph_prefixes[c.target.value]
                        ? c.target.innerText + ". " + d.text
                        : c.target.innerText + d.text),
                    measure_text(d),
                    recalc_border_width(d.border_id, !1, !0, !0),
                    position_texts(d.border_id),
                    (d.par_prefix = c.target.value),
                    render());
            }),
            set_current_element(currentElement, !0));
    }),
        ["text_align_left", "text_align_center", "text_align_right"].forEach(
            function (c) {
                $("." + c).on("click", function () {
                    (manage_groups
                        .get_group(currentElement, !0)
                        .forEach(function (d) {
                            ((d.text_align = c.split("_")[2]),
                                position_texts(d.id));
                        }),
                        set_current_element(currentElement));
                });
            },
        ),
        $(".form_paragraph_clear_style").on("click", function () {
            manage_groups
                .get_group(part_to_chunk(currentElement), !0)
                .forEach(function (c) {
                    var d = find_border_by_id(c.border_id);
                    ((c.fill = "rgba(0,0,0,1)"),
                        (c.has_own_style = !1),
                        (c.font_fam_inherited = !0),
                        (c.font_size = d.font_size),
                        (c.font_family = d.font_family));
                });
        }),
        $(".form_even_out_pars").on("click", function () {
            var c = manage_groups.get_group(currentElement, !1);
            c.forEach(even_out_paragraphs);
        }),
        $(".chunk_cover_whole_line").on("click", function () {
            (manage_groups.get_group(currentElement, !0).forEach(function (c) {
                ((c.cover_whole_line = !0), position_texts(c.border_id));
            }),
                set_current_element(currentElement, !0));
        }),
        plus_minus_generator(
            document.querySelector("#form_article_padding"),
            function (c) {
                (manage_groups
                    .get_group(currentElement, !0)
                    .forEach(function (d) {
                        ((d.padding = parseInt(c.value)),
                            resize_if_wanted_after_font_change(d),
                            (d.style_class = !1));
                    }),
                    render_all(0, !1, !0));
            },
            1,
            0,
        ),
        plus_minus_generator(
            document.getElementById("form_paragraph_line_height"),
            function (c) {
                //document.querySelector('#form_all_pars').checked;
                (manage_groups
                    .get_group(currentElement, !0)
                    .forEach(function (d) {
                        "text" == d.iama && (d = part_to_chunk(d));
                        var e =
                            "text" != d.iama
                                ? get_text_with_border_id(d.id || d.border_id)
                                : [d];
                        (e.forEach(function (d) {
                            ((d.line_height = parseFloat(c.value)),
                                measure_text(d));
                        }),
                            position_texts(d.id || d.border_id));
                    }),
                    render());
            },
            0.1,
            2,
        ),
        $(".form_reset_par_margins_all").on("click", function () {
            delete_par_margings(currentElement.id);
        }),
        $("#form_reset_par_margin").on("click", function () {
            var c = get_chunks_in_par(
                currentElement.border_id,
                currentElement.par_num,
            );
            (c.forEach(function (c) {
                (delete c.margin_top, delete c.margin_left);
            }),
                position_texts(currentElement.border_id),
                render());
        }));
    function delete_par_margings(c) {
        var d = get_chunks_by_par(c);
        (Object.keys(d).forEach(function (c) {
            d[c].forEach(function (c) {
                (delete c.margin_top, delete c.margin_left);
            });
        }),
            position_texts(c),
            render());
    }
    function change_par_margin(c, d, e) {
        var f = get_chunks_in_par(c.border_id, c.par_num);
        (f.forEach(function (c) {
            (c.margin_top || (c.margin_top = 0),
                c.margin_left || (c.margin_left = 0),
                (c.margin_top = Math.max(0, e + c.margin_top)),
                (c.margin_left = Math.max(0, d + c.margin_left)));
        }),
            position_texts(c.border_id));
        var g = find_border_by_id(c.border_id),
            h = f.slice(-1)[0].parts.slice(-1)[0],
            i = h.y + h.height - (g.y + g.height); //const last_part = get_chunks_in_par(el.border_id, border.num_pars-1).slice(-1)[0].parts.slice(-1)[0];
        (0 < i && (g.height += i), render());
    } //TODO2 wordt er bij double click resize wel rekening gehouden met font family??
    function find_text_with_web_links() {
        //https://mathiasbynens.be/demo/url-regex //@stephenhay
        //var regex = /^(https?|ftp):\/\/[^\s/$.?#].[^\s]*$/
        var c = /^(https?):\/\/[^\s/$.?#].[^\s]*$/;
        return arr
            .filter(function (e) {
                return e.text.match(c);
            })
            .map(function (c) {
                return c.text;
            });
    }
    function is_web_link(c) {
        return c.match(/^(https?):\/\/[^\s/$.?#].[^\s]*$/);
    }
    ("use strict");
    (plus_minus_generator(
        document.getElementById("form_border_width"),
        change_border_width,
        0.5,
        2,
    ),
        plus_minus_generator(
            document.getElementById("cm_border_width"),
            change_border_width,
            0.5,
            2,
        ));
    function change_border_width(a) {
        ("text" == currentElement.iama && check_for_range_when_p_form_action(),
            manage_groups.get_group(currentElement, !0).forEach(function (b) {
                var c = b.iama,
                    e = "stroke_width";
                ("path_group" == c
                    ? "plain" == b.type ||
                      ("double" == b.type &&
                          document.querySelector("#form_border_inner").checked)
                        ? (e = "inner_width")
                        : (e = "outer_width")
                    : "text" == c &&
                      ((b = part_to_chunk(b)),
                      !b.has_own_style && add_own_style_to_text(b)),
                    b.rough && delete b.redraw_data,
                    b.style_class && predef_styles.style_class_to_custom(b),
                    (b[e] = parseFloat(a.value)),
                    b.add_ons &&
                        Object.keys(b.add_ons).forEach(function (c) {
                            b.add_ons[c].style.stroke_width = parseFloat(
                                a.value,
                            );
                        }));
            }),
            set_current_element(currentElement, !0));
    }
    ($("#form_border_side button").on("click", function (a) {
        a.target.classList.toggle("onoff-on");
        var b = _.map(
            this.parentElement.querySelectorAll("button"),
            function (a) {
                return a.classList.contains("onoff-on");
            },
        );
        (manage_groups.get_group(currentElement, !0).forEach(function (a) {
            ((a = part_to_chunk(a)),
                _.any(b)
                    ? calc_border_dasharray(a, b)
                    : "stroke_dasharray" in a && delete a.stroke_dasharray,
                _.all(b) ||
                _.all(
                    b.map(function (a) {
                        return !a;
                    }),
                )
                    ? delete a.border_sides_arr
                    : (a.border_sides_arr = b));
        }),
            render());
    }),
        (document.querySelector("#form_border_dash input").oninput =
            function () {
                change_border_dasharray(
                    currentElement,
                    this.value.split(" ").map(function (a) {
                        return parseFloat(a);
                    }),
                );
            }),
        $(".form_border_dash_styles > svg").on("click", function () {
            var a = Array.from(this.querySelectorAll("path")).map(function (a) {
                return a.style["stroke-dasharray"].split(" ").map(function (a) {
                    return parseFloat(a);
                });
            });
            change_border_dasharray(currentElement, a[0], a[1]);
        })); //TODO2 bij klik op svg dash button input vullen met dashes en strokes
    function change_border_dasharray(a, b) {
        var c =
            !!(2 < arguments.length && arguments[2] !== void 0) && arguments[2];
        (manage_groups.get_group(a, !0).forEach(function (a) {
            ("path_group" == a.iama && "double" == cpa.type
                ? ((a.dasharray_inner = b), c && (a.dasharray_outer = c))
                : "path_group" == a.iama
                  ? (a.dasharray_inner = b)
                  : (a.stroke_dasharray = b),
                delete a.border_sides_arr);
        }),
            set_current_element(a),
            d3
                .selectAll("#form_border_side button.onoff-on")
                .classed("onoff-on", !1));
    }
    document.querySelector("#form_border_inner").onchange = function () {
        return (
            ("path_group" == currentElement.iama ||
                "double" == currentElement.type) &&
            void (this.checked
                ? ("dasharray_inner" in currentElement &&
                      (document.querySelector("#form_border_dash input").value =
                          currentElement.dasharray_inner.join(" ")),
                  (document.querySelector("#form_border_width input").value =
                      currentElement.inner_width))
                : ("dasharray_outer" in currentElement &&
                      (document.querySelector("#form_border_dash input").value =
                          currentElement.dasharray_outer.join(" ")),
                  (document.querySelector("#form_border_width input").value =
                      currentElement.outer_width)))
        );
    };
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var h,
                j,
                k,
                l,
                m = [],
                a = !0,
                p = !1;
            try {
                if (((k = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (h = k.call(d)).done) &&
                        (m.push(h.value), m.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((p = !0), (j = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((l = d["return"]()), Object(l) !== l)
                    )
                        return;
                } finally {
                    if (p) throw j;
                }
            }
            return m;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    } //TODO2 onnodige functies weghalen
    var manage_groups = (function () {
        function a() {
            ((w.last_clicked_shape = !1), (w.colors = []), (w.index = -1));
        }
        function b() {
            ((l = {
                red: [],
                green: [],
                yellow: [],
                blue: [],
                purple: [],
                black: [],
                white: [],
                orange: [],
            }),
                (o = l.red),
                (p = "red"),
                (q = []));
        }
        function c() {
            for (; -1 != q.indexOf(v); ) v += 1;
            return v;
        }
        function d() {
            ((l = {}),
                q.forEach(function (a) {
                    return (l[a] = []);
                }));
        }
        function e(a, b) {
            return "fa_icon" == a
                ? 1
                : "border" == a && b.bound
                  ? 2
                  : "path_group" == a
                    ? 3
                    : "text" == a
                      ? 4
                      : "cell_basic" == a
                        ? 5
                        : "graph_basic" == a
                          ? 6
                          : 0;
        }
        function f() {
            ((s = !1), (u = ""), (l.black = []));
        }
        function h(a) {
            var b = new Set(o);
            if (merged.is_child(a)) {
                var c = merged.get_parent(a);
                if (b.has(c)) return !1;
            } // if (merged.is_parent(new_el)){
            //     const children = merged.get_children(new_el);
            //     if (_.any(children.map(child=>shapes_in_current_group.has(child)))) return false
            // }
            return !0;
        }
        function i(a) {
            // if (el.tagName =='P'){
            // 	el.style['text-shadow'] = null;
            // }else{
            // 	el.style['filter'] = null;
            // }
        }
        function j() {
            0 == o.length &&
                (delete l[p],
                (q = q.filter(function (a) {
                    return a != p;
                })),
                (p = "black"),
                (l[p] = o = []),
                q.push("black"),
                (for_group = !1));
        }
        function k(a) {
            a in l &&
                0 == l[a].length &&
                ((q = q.filter(function (b) {
                    return b != a;
                })),
                delete l[a],
                p == a && (p = "black"));
        }
        var l = {
                red: [],
                green: [],
                yellow: [],
                blue: [],
                purple: [],
                black: [],
                white: [],
                orange: [],
            },
            o = l.red,
            p = "red",
            q = [],
            r = !1,
            s = !1,
            t = !1,
            u = "",
            v = 1;
        j();
        var w = { last_clicked_shape: !1, index: 0, colors: [] },
            x = function a() {
                var b = 1 / 0,
                    c = 1 / 0,
                    d = 0,
                    e = 0;
                group_no_paths = o.filter(function (a) {
                    return "path_group" != a.iama;
                });
                for (var f = 0; f < group_no_paths.length; f++) {
                    var h = group_no_paths[f],
                        j = [h.x, h.y],
                        k = [h.x + h.width, h.y + h.height];
                    ((b = Math.min(b, j[0])),
                        (c = Math.min(c, j[1])),
                        (d = Math.max(d, k[0])),
                        (e = Math.max(e, k[1])));
                } //return [(hi_x + low_x)/2, (hi_y + low_y)/2 ];
                return [b, c];
            };
        return {
            push_temp_to_new_group: function a() {
                ((v = c()),
                    q.push(v),
                    (l[v] = o.slice()),
                    this.activate_group(v));
            },
            permanent_group_active: function a() {
                return "black" != p && 0 < o.length;
            },
            get_color_from_index: function b(a) {
                return q[a];
            },
            swap_group_for_nth_paragraps: function b(a) {
                var c = this,
                    d = [],
                    e = manage_groups.get_current_group().filter(function (b) {
                        return b.num_pars && b.num_pars >= a;
                    });
                (e.forEach(function (b) {
                    var c = get_text_with_border_id(b.id);
                    0 == a
                        ? _.forEach(c, function (a) {
                              return d.push(a);
                          })
                        : c.length >= a && d.push(c[a - 1]);
                }),
                    this.reset(!1),
                    d.forEach(function (a) {
                        return c.add(a);
                    }));
            },
            activate_group: function b(a) {
                //var new_color = colors[parseInt(new_color_index)];
                (f(),
                    this.unshow_my_group(),
                    a in l
                        ? ((o = l[a]),
                          (p = a),
                          this.set_my_filter(),
                          this.show_my_group(),
                          (for_group = !0))
                        : text_to_feedback_pane("not a valid group name"));
            },
            deactivate_group: function a() {
                (this.unshow_my_group(), update_quick_grouping_forms());
            },
            activate_temp_group: function c(a, b) {
                (this.unshow_my_group(),
                    (for_group = !0),
                    (s = !0),
                    (u = b || ""),
                    (o = l.black = []),
                    (p = "black"));
                for (var d = 0; d < a.length; d++) this.add(a[d]);
                (this.set_my_filter(), (r = !0), (for_group = !0));
            },
            get_group_of_element: function b(a) {
                for (var c, d = 0; d < q.length; d++)
                    if (
                        ((c = q[d]),
                        l[c].find(function (b) {
                            return b == a;
                        }))
                    )
                        return c;
                return !1;
            },
            get_groups_of_element: function b(a) {
                //colors waren vroeger kleuren, nu aangepast naar cijfers omdat meer groepen mogelijk zijn
                // ivm oude maps, wel rekening houden met mogelijkheid key == kleur = string
                for (var c, d = [], e = 0; e < q.length; e++)
                    ((c = q[e]),
                        l[c].find(function (b) {
                            return b == a;
                        }) && d.push(c));
                return d;
            },
            element_in_active_group: function b(a) {
                return o.find(function (b) {
                    return b == a;
                });
            },
            add: function b(a) {
                var c = a.iama;
                return (
                    "slide" != c &&
                    void (!for_group && this.activate_temp_group([], "temp"),
                    o.push(a),
                    update_quick_grouping_forms())
                ); //if (iama(el.parentElement)=='slide') return false;
            },
            remove: function b(a) {
                var c = o.length;
                ((o = o.filter(function (b) {
                    return b != a;
                })),
                    (l[p] = o));
                var d = o.length,
                    e = a.iama;
                if (c != d)
                    (i(a),
                        text_to_feedback_pane(
                            "removed " +
                                e +
                                "\n Group length = " +
                                d.toString(),
                            !0,
                        ));
                else return !1;
                return !0;
            },
            toggle_elements: function b(a) {
                var c = this;
                if (canvas_status.align_on)
                    return (
                        text_to_feedback_pane(
                            "keep or reset alignment first",
                            !0,
                        ),
                        !1
                    );
                var d = a.length;
                ((a = a.filter(function (a) {
                    return !("table" in a);
                })),
                    a.forEach(function (a) {
                        return c.toggle_element(a);
                    }),
                    a.length == d
                        ? text_to_feedback_pane(
                              "".concat(a.length, " shapes in current group"),
                          )
                        : text_to_feedback_pane(
                              "cannot add shapes that already belong to a table to a group",
                              !0,
                          ));
            },
            toggle_element: function b(a) {
                var c =
                    !!(1 < arguments.length && arguments[1] !== void 0) &&
                    arguments[1];
                return canvas_status.align_on
                    ? (text_to_feedback_pane(
                          "keep or reset alignment first",
                          !0,
                      ),
                      !1)
                    : h(a)
                      ? void (0 <
                        o.filter(function (b) {
                            return b == a;
                        }).length
                            ? (this.remove(a),
                              c &&
                                  text_to_feedback_pane(
                                      "removed shape: ".concat(
                                          o.length,
                                          " remaining",
                                      ),
                                  ),
                              j(),
                              set_current_element(a, !0))
                            : (this.add(a),
                              c &&
                                  text_to_feedback_pane(
                                      "added shape: group has ".concat(
                                          o.length,
                                          " shapes",
                                      ),
                                  )),
                        0 < o.length && this.show_my_group())
                      : (c &&
                            text_to_feedback_pane("cannot add shape to group"),
                        !1);
            },
            reset: function b() {
                var c =
                    !(0 < arguments.length && arguments[0] !== void 0) ||
                    arguments[0];
                (this.unshow_my_group(),
                    delete l[p],
                    (q = q.filter(function (a) {
                        return a != p;
                    })),
                    c && text_to_feedback_pane("group has been deleted"),
                    a(),
                    to_canvas.set_canvas(),
                    gui_buttons.clear());
            },
            to_list: function a() {
                var b =
                        !!(0 < arguments.length && arguments[0] !== void 0) &&
                        arguments[0],
                    c = !!b && b.iama;
                if (!c) return o.slice(); //filter op text_block, text_path // path_group // text_basic, icon_basic // rest (figuren)
                var f = e(c, b),
                    h = o.filter(function (a) {
                        return e(a.iama, a) == f;
                    }); //var table = el.getAttribute('table')
                //if (table) els= els.filter(d=>d.getAttribute('table')==table);
                return h;
            },
            show_my_group: function a() {
                (cc.clear_canvas(hover_context),
                    gui_buttons.render_hover_highlight_for_group(o));
            },
            unshow_my_group: function a() {
                (o.forEach(function (a) {
                    i(a);
                }),
                    (r = !1),
                    (for_group = !1),
                    (o = []));
            },
            toggle_showing: function a() {
                r ? this.unshow_my_group() : this.show_my_group();
            },
            set_my_filter: function a() {
                // var R, G, B ;
                // R = G = B = '0.2';
                // if (color == 'red') R = '0.4';
                // if (color == 'green') G = '0.4';
                // if (color == 'blue') B = '0.4';
                // var m = R + " 0 0 0 0 0 " + G + " 0 0 0 0 0 " + B + " 0 0 0 0 0 1 0";
                // document.querySelector('#f2 feColorMatrix')
                // 	.setAttribute('values', m);
            },
            paste_group: function b(a) {
                var c = x(),
                    e = {},
                    f = []; //copy_paths_in_group(id_mapper);
                ((group_no_paths = o.filter(function (a) {
                    return "path_group" != a.iama && "knot" != a.iama;
                })),
                    group_no_paths.forEach(function (b) {
                        offset = [c[0] - b.x, c[1] - b.y];
                        var d = to_discrete_position([
                                a[0] - offset[0],
                                a[1] - offset[1],
                            ]),
                            h = copy_element_new(
                                b,
                                d,
                                document.querySelector("#form_copy_with_text")
                                    .checked,
                            ); //roughing.copy(d, new_g.node());
                        (snap_to_grid(h), (e[b.id] = h.id), f.push(h));
                    }),
                    this.activate_temp_group(f));
            },
            remove_element_if_present: function b(a) {
                var c = [];
                for (key in l)
                    -1 != l[key].indexOf(a) &&
                        ((l[key] = l[key].filter(function (b) {
                            return b != a;
                        })),
                        k(key),
                        c.push(key));
                return (i(a), c);
            },
            add_element_to_multiple_groups: function c(a, b) {
                a.forEach(function (a) {
                    (a in l || (l[a] = []), l[a].push(b), a == p && (o = l[a]));
                });
            },
            returninternals: function a() {
                return { color: p, groups: l };
            },
            save: function a() {
                var b = {};
                for (g in l)
                    b[g] = l[g].map(function (a) {
                        return a.id;
                    });
                return b;
            },
            load: function b(a) {
                for (g in (d(), a))
                    (-1 == q.indexOf(g) && q.push(g),
                        (l[g] = a[g]
                            .map(function (a) {
                                return shapes_storage.search_shapes_with_id(a);
                            })
                            .filter(function (a) {
                                return a;
                            })));
                v =
                    d3.max(
                        q
                            .map(function (a) {
                                return parseInt(a);
                            })
                            .filter(function (a) {
                                return !isNaN(a);
                            }),
                    ) + 1 || 1;
            },
            add_highlight: function a() {
                o.forEach(function (a) {
                    return render_hover_highlight(a, "pink", hover_context);
                });
            },
            get_group: function c(a, b) {
                if (t) return ((t = !1), [a]);
                if (
                    ("text" == a.iama && (a = part_to_chunk(a)),
                    !(for_group && manage_groups.element_in_active_group(a)))
                )
                    var d = [a];
                else if (!b) var d = manage_groups.to_list();
                else var d = manage_groups.to_list(a);
                return d;
            },
            set_pass_on_next_call: function a() {
                return ((t = !0), t);
            },
            get_group_info: function a() {
                return u;
            },
            get_current_group: function a() {
                return o;
            },
            get_group_from_color: function b(a) {
                //retourneerd groep, maakt verder niet active groep
                return a in l ? l[a] : [];
            },
            ready_for_paste: !1,
            cycle_through_groups_of_shape: function b(a) {
                if (
                    (a != w.last_clicked_shape &&
                        ((w.last_clicked_shape = a),
                        (w.colors = manage_groups.get_groups_of_element(a)),
                        (w.index = -1)),
                    0 == w.colors.length)
                )
                    return !1;
                w.index += 1;
                var c = w.colors[w.index % w.colors.length];
                c
                    ? manage_groups.activate_group(c)
                    : manage_groups.unshow_my_group();
            },
            find_els_in_bbox_not_in_group: function b(a) {
                var c = get_bbox_of_group(a),
                    d = _slicedToArray(c, 4),
                    e = d[0],
                    f = d[1],
                    h = d[2],
                    i = d[3],
                    j = parse_to_bbox(e - 5, h - 5, f - e + 10, i - h + 10),
                    k = find_elements_in_bbox_test(j, !0, !0),
                    l = new Set(a);
                return [
                    k.filter(function (a) {
                        return !l.has(a);
                    }),
                    j,
                ];
            },
            reset_all_groups: b,
        };
    })(); //TODO1 ???weghalen
    function find_merged_shapes(a) {
        return merged.get_children(a); // var res = direct_child_only_selector(g, 'g');
        // var extra = []
        // res.forEach(d=>{
        // 	if (d.classList.contains('i_have_a_group') && !d.classList.contains('hg')) {
        // 		extra = extra.concat(find_merged_shapes(d));
        // 	}
        // });
        // return res.concat(extra)
    }
    ($(".form_deselect_group").on("click", function (a) {
        (manage_groups.deactivate_group(), update_quick_grouping_forms());
    }),
        $(".form_temp_group_to_perm").on("click", function (a) {
            (manage_groups.push_temp_to_new_group(),
                update_quick_grouping_forms());
        }),
        $(".form_temp_group_to_perm_deactivate").on("click", function (a) {
            (manage_groups.push_temp_to_new_group(),
                manage_groups.deactivate_group(),
                update_quick_grouping_forms());
        }));
    for (
        var t = document.querySelectorAll(".form_reset_group"), i = 0;
        i < t.length;
        i++
    )
        t[i].onclick = function () {
            manage_groups.reset();
        };
    function update_quick_grouping_forms() {
        manage_groups.permanent_group_active()
            ? ($(".when_group").css("display", "flex"),
              $(".form_deselect_group").css("display", "inline-block"),
              $(".form_temp_group_to_perm").css("display", "none"),
              $(".form_temp_group_to_perm_deactivate").css("display", "none"))
            : 0 < manage_groups.get_current_group().length
              ? ($(".when_group").css("display", "flex"),
                $(".form_temp_group_to_perm").css("display", "inline-block"),
                $(".form_temp_group_to_perm_deactivate").css(
                    "display",
                    "inline-block",
                ),
                $(".form_deselect_group").css("display", "none"))
              : ($(".when_group").css("display", "none"),
                $("#fs_grouping_quick .when_group").css("display", "none"));
    }
    var searcher = (function () {
        function a(a) {
            var c = b(),
                d =
                    "text" == currentElement.iama
                        ? part_to_chunk(currentElement)
                        : currentElement;
            "shape" == a &&
                (a =
                    "border" == d.iama
                        ? d.bound
                            ? "bound"
                            : "shape"
                        : "iama");
            var e = d[a],
                f = c.filter(function (b) {
                    return b[a] == e;
                });
            manage_groups.activate_temp_group(f);
        }
        function b() {
            var a = manage_groups.get_current_group();
            return (
                0 == a.length && (a = shapes_storage.get_all()),
                (a = a.map(part_to_chunk)),
                a
            );
        }
        ($("#form_search_for_grouping button").on("click", function (b) {
            var c = this.getAttribute("search_attrib");
            (a(c), manage_groups.show_my_group());
        }),
            (document.querySelector("#button_group_reset").onclick =
                function () {
                    manage_groups.reset();
                }));
    })();
    function disperse_group(a) {
        var b =
                1 < arguments.length && arguments[1] !== void 0
                    ? arguments[1]
                    : 1.1,
            c =
                2 < arguments.length && arguments[2] !== void 0
                    ? arguments[2]
                    : 1.1,
            d = get_bbox_of_group(a),
            e = _slicedToArray(d, 4),
            f = e[0],
            h = e[1],
            i = e[2],
            j = e[3];
        (a.forEach(function (a) {
            var d = posit2.get_top_left(a, !0),
                e = _slicedToArray(d, 2),
                h = e[0],
                j = e[1],
                h = (h - f) * b + f,
                j = (j - i) * c + i;
            ((a.x = h), (a.y = j));
        }),
            resize_protocol(a[0], 0, 0),
            render());
    }
    ((document.querySelector(".form_group_disperse_a").onclick = function (a) {
        disperse_group(manage_groups.get_group(currentElement, !0), 0.9, 1);
    }),
        (document.querySelector(".form_group_disperse_b").onclick = function (
            a,
        ) {
            disperse_group(manage_groups.get_group(currentElement, !0), 1.1, 1);
        }),
        (document.querySelector(".form_group_disperse_c").onclick = function (
            a,
        ) {
            disperse_group(manage_groups.get_group(currentElement, !0), 1, 0.9);
        }),
        (document.querySelector(".form_group_disperse_d").onclick = function (
            a,
        ) {
            disperse_group(manage_groups.get_group(currentElement, !0), 1, 1.1);
        }),
        (document.querySelector("#form_group_delete_all").onclick =
            manage_groups.reset_all_groups),
        $(".form_paste_group").on("click", function (a) {
            (manage_groups.paste_group(last_pos), render());
        }),
        $(".form_select_nth_paragraph").on("click", function (a) {
            var b = parseInt(document.querySelector("#form_nth_par").value);
            manage_groups.swap_group_for_nth_paragraps(b);
        }));
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    var form_filled = !1;
    function make_form_prelim() {
        //document.querySelector('#form_path_lineto').style.display = 'none';
        document.querySelector("#form_border_inner_outer").style.display =
            "none";
    }
    function set_fs(a) {
        var b = a.getAttribute("i_am_a"),
            b =
                d3.select(a).classed("polygon_basic") && "slide" != b
                    ? "polygon"
                    : b;
        make_form_prelim();
        minimal_menu
            ? all_form_elements.filter(function (a) {
                  return -1 == non_minimal_fieldsets.indexOf(a);
              })
            : all_form_elements;
        (minimal_menu &&
            non_minimal_fieldsets.forEach(function (a) {
                return d3.select("#" + a).style("display", "none");
            }),
            a.querySelector("article") &&
                (a
                    .querySelector("article")
                    .classList.contains("has_background") &&
                    set_background_button(a.querySelector("article")),
                (document.querySelector("#form_article_padding input").value =
                    parseInt(a.querySelector("article").style.padding || 0))));
    }
    function fill_forms(a) {
        a = part_to_chunk(a);
        var b = a.iama;
        return (
            "slider" != b &&
            void (fill_fs_infinity(a),
            "text" == b
                ? (fill_fs_border(a), fill_fs_para(a), fill_fs_font(a))
                : "fa_icon" == b
                  ? (fill_fs_border(a), fill_font_size(a))
                  : "path_group" == b
                    ? (fill_fs_border(a),
                      fill_fs_path(a),
                      fill_fs_path_advanced(a),
                      fill_fs_path_label(a))
                    : "path_addon" == a.iama
                      ? fill_fs_path_label(a)
                      : "canvas" == a.iama ||
                        ("text_block" == b || "text_path" == b
                            ? fill_fs_border(a)
                            : "drawing" == b
                              ? (fill_fs_border(a), fill_fs_drawing(a))
                              : "knot" == b ||
                                (b
                                    ? (fill_fs_border(a),
                                      fill_fs_font(a),
                                      fill_fs_fig_stuff(a),
                                      "path_basic" == b && fill_fs_drawing(a),
                                      "line_for_graph" == b &&
                                          (fill_fs_line_for_graph(a),
                                          fill_fs_graphing(a)),
                                      !minimal_menu && fill_fs_merge(a))
                                    : console.log(
                                          "fillform onbekend type",
                                          a,
                                      ))),
            help_on && display_help(a),
            gui_buttons.add_marker_to_example_style(a.style_class),
            (form_filled = !0))
        );
    }
    function display_help(a) {
        "text" == a.iama
            ? text_to_help_pane(help_text.P)
            : "path_addon" == a.iama
              ? text_to_help_pane(help_text.path_addon)
              : "canvas" == a.iama
                ? text_to_help_pane(help_text.svg)
                : "path_group" == a.iama
                  ? text_to_help_pane(help_text.path_group)
                  : "drawing" == a.iama
                    ? text_to_help_pane(help_text.drawing_lineto)
                    : a.shape in help_text
                      ? text_to_help_pane(help_text[a.shape])
                      : -1 != polygon_shapes.indexOf(a.shape) &&
                        text_to_help_pane(help_text.polygon);
    }
    function set_invalid_form_inputs_to_zero() {
        var a = [
            [document.querySelector("#form_border_width input"), 1],
            [document.querySelector("#form_paragraph_padding_left input"), 0],
            [document.querySelector("#form_paragraph_padding_top input"), 0],
            [document.querySelector("#form_font_size input"), 0],
            [document.querySelector("#form_border_dash input"), 0],
        ];
        return (
            a.forEach(function (a) {
                var b = _slicedToArray(a, 2),
                    c = b[0],
                    d = b[1];
                if ("Nan" == c.value || "" == c.value) c.value = 0;
                else {
                    var e = c.value,
                        f = e.match(/[+-]?\d+(\.\d+)?/g);
                    ((f =
                        f && 1 == f.length
                            ? parseFloat(f[0]).toFixed(d)
                            : f
                              ? f.join(" ")
                              : ""),
                        (c.value = f));
                }
            }),
            !1
        );
    }
    function display_fs_for_shape(a) {
        "parent" in a && (a = a.parent); //close_other_fieldsets();
        var b = minimal_menu
            ? all_form_elements.filter(function (a) {
                  return -1 == non_minimal_fieldsets.indexOf(a);
              })
            : all_form_elements;
        minimal_menu &&
            non_minimal_fieldsets.forEach(function (a) {
                return d3.select("#" + a).style("display", "none");
            });
        var c;
        ("text" == a.iama
            ? (c = paragraph_form_elements.slice())
            : "path_group" == a.iama
              ? (c = path_form_elements.slice())
              : "fa_icon" == a.iama
                ? (c = figs.fa_icon.my_form_elements.slice())
                : "drawing" == a.iama
                  ? ((c = drawing_form_elements.slice()),
                    "line" == a.type && c.push("fs_rough"))
                  : "path_addon" == a.iama
                    ? (c = path_add_on_form_elements.slice())
                    : "canvas" == a.iama
                      ? (c = svg_form_elements.slice())
                      : a.is_cell
                        ? (c = figs.cell_basic.my_form_elements.slice())
                        : a.shape
                          ? (a.shape in poly_config
                                ? (c = figs.polygon.my_form_elements.slice())
                                : a.shape in figs
                                  ? (c = figs[a.shape].my_form_elements.slice())
                                  : "custom" == a.shape &&
                                    (c =
                                        figs.poly_point.my_form_elements.slice()),
                            a.id in shapes_storage.images && c.push("fs_image"))
                          : "math_shape" == a.iama
                            ? (c = [
                                  "form_fill",
                                  "fs_border",
                                  "fs_colors",
                                  "colors_svg",
                                  "ffw_fill",
                                  "ffw_stroke",
                                  "fs_grouping_quick",
                              ])
                            : (c = []),
            hide_or_display_form_fields(b, c),
            (form_filled = !1),
            update_open_fs(a));
    }
    function hide_or_display_form_fields(a, b) {
        a.forEach(function (a) {
            -1 == b.indexOf(a)
                ? d3.select("#" + a).style("display", "none")
                : (el = d3.select("#" + a).style("display", "flex"));
        });
    }
    function update_open_fs(a) {
        var b = document.querySelectorAll(
            "#edit_mode_menu fieldset:not(.collapsed):not(#fs_help)",
        );
        if (
            (!form_hidden && help_on && display_help(a),
            fill_fs_infinity(a),
            1 == b.length)
        ) {
            if ("none" == b[0].style.display) return !1;
            var c = b[0].id;
            "fs_border" == c
                ? fill_fs_border(a)
                : "fs_font" == c
                  ? fill_fs_font(a)
                  : "fs_fig_stuff" == c
                    ? fill_fs_fig_stuff(a)
                    : "fs_image" == c ||
                      ("fs_para" == c
                          ? fill_fs_para(a)
                          : "fs_path" == c
                            ? fill_fs_path(a)
                            : "fs_path_label" == c
                              ? fill_fs_path_label(a)
                              : "fs_path_advanced" == c ||
                                ("fs_graphing" == c || "fs_board" == c
                                    ? (fill_fs_graphing(a),
                                      "line_for_graph" == iama(a) &&
                                          fill_fs_line_for_graph(a))
                                    : "fs_drawing" == c
                                      ? fill_fs_drawing(a)
                                      : "fs_grouping" == c
                                        ? fill_fs_merge(a)
                                        : "fs_grouping_quick" == c));
        }
    }
    function fill_fs_line_for_graph(a) {
        ($(".cm_graph_formula_text").prop(
            "value",
            find_g(a).getAttribute("my_func"),
        ),
            $(".form_graph_when_line").css("display", "block"));
    }
    function fill_fs_graphing(a) {
        var b = if_line_to_graph(a);
        ($(".form_graph_crossed_axis").prop(
            "checked",
            b.hasAttribute("graph_axis_crossed"),
        ),
            $(".form_graph_grid").prop("checked", b.hasAttribute("gridded")));
        var c = b
                .getAttribute("domain_x")
                .split(",")
                .map(function (a) {
                    return parseFloat(a);
                }),
            d = _slicedToArray(c, 2),
            e = d[0],
            f = d[1];
        if (
            ($(".cm_graph_min_domain").val(e),
            $(".cm_graph_max_domain").val(f),
            $(".cm_graph_formula_text").val(""),
            $(".form_graph_num_ticks_x").val(
                b.querySelector(".x_axis").getAttribute("num_ticks"),
            ),
            $(".form_graph_num_ticks_y").val(
                b.querySelector(".y_axis").getAttribute("num_ticks"),
            ),
            b.hasAttribute("asymptotic") || b.hasAttribute("fixed_range"))
        ) {
            var g = b
                    .getAttribute("domain_y")
                    .split(",")
                    .map(function (a) {
                        return parseFloat(a);
                    }),
                h = _slicedToArray(g, 2),
                i = h[0],
                j = h[1];
            ($(".cm_graph_min_range").val(j),
                $(".cm_graph_max_range").val(i),
                (document.querySelector("#form_if_asymptotic").style.display =
                    "flex"));
        } else
            document.querySelector("#form_if_asymptotic").style.display =
                "none";
        if (
            ($(".form_show_axis_num").prop(
                "checked",
                !b.classList.contains("no_nums"),
            ),
            "axes_board" == iama(b))
        ) {
            var k = b.classList.contains("no_nums") ? "none" : "block";
            document.querySelector("#form_domain_and_ranges").style.display = k;
        }
    }
    function fill_fs_path_advanced() {
        // if (el.getAttribute('flow') == 'lineto'){
        // 	setup_smoothing_for_lineto();
        // 	document.querySelector('#form_undo_smoothing').style.display = 'none'
        // 	document.querySelector('#form_path_custom_flow').style.display = 'none';
        // 	document.querySelector('#form_path_lineto').style.display = 'block';
        // }else{
        // 	document.querySelector('#form_path_custom_flow').style.display = 'block';
        // }
    }
    function fill_fs_merge(a) {
        ((document.querySelector(
            ".form_ungroup_all_children",
        ).parentElement.style.display = merged.is_parent(a)
            ? "inherit"
            : "none"),
            (document.querySelector(
                "#form_ungroup",
            ).parentElement.style.display = merged.is_child(a)
                ? "inherit"
                : "none"));
    } //arrows
    function fill_fs_path_label(a) {
        if ("path_group" == a.iama || "drawing" == a.iama) {
            var b = "add_ons" in a ? Object.keys(a.add_ons) : [];
            if (0 < b.length)
                ((a = a.add_ons[b[0]]), $(".if-arrow").css("display", "block"));
            else return ($(".if-arrow").css("display", "none"), !1);
        }
        ((document.querySelector("#form_add_on_height input").value = a.height),
            (document.querySelector("#form_add_on_width input").value =
                a.width));
    }
    function update_path_direction_buttons() {
        (d3.selectAll(".path_from_to").classed("on", !1),
            document
                .querySelectorAll("#cm-path-directions-from .path_from_to")
                [parseInt(cpa.from_side)].classList.toggle("on", !0),
            document
                .querySelectorAll("#cm-path-directions-to .path_from_to")
                [parseInt(cpa.to_side)].classList.toggle("on", !0),
            document
                .querySelectorAll("#form-path-directions-from .path_from_to")
                [parseInt(cpa.from_side)].classList.toggle("on", !0),
            document
                .querySelectorAll("#form-path-directions-to .path_from_to")
                [parseInt(cpa.to_side)].classList.toggle("on", !0));
    }
    function fill_fs_path(a) {
        (toggle_path_reset_button(a),
            $(".form_path_style2 select").val(a.type),
            update_path_direction_buttons());
    }
    function toggle_path_reset_button(a) {
        a.fixed_side || a.custom_flow
            ? $(".form_path_reset").css("display", "flex")
            : $(".form_path_reset").css("display", "none");
    }
    function fill_fs_para(a) {
        a = part_to_chunk(a);
        var b = a.line_height;
        ((document.querySelector("#form_paragraph_line_height input").value =
            "normal" == b ? 1.4 : parseFloat(b)),
            (document.querySelector(
                "#form_paragraph_padding_left input",
            ).value = a.margin_left || 0),
            (document.querySelector("#form_paragraph_padding_top input").value =
                a.margin_right || 0));
    }
    function fill_fs_fig_stuff(a) {
        ((document.querySelector("#form_article_padding input").value =
            a.padding),
            set_language_for_syntax_highlight(a));
    }
    function fill_font_size(a) {
        document.querySelector("#form_font_size input").value = a.font_size;
        var b =
            "text" == a.iama ? find_border_by_id(a.border_id).level : a.level;
        toggle_font_class(a.font_size, b);
    }
    function fill_fs_font(a) {
        ("text" == a.iama && (a = part_to_chunk(a)),
            fill_font_size(a),
            toggle_font_alignment(a),
            change_selected_in_font_list(
                document.querySelector("#form_fonts_list"),
                a.font_family,
            ));
    }
    function fill_fs_infinity(a) {
        ($("#form_set_infinity_level")
            .find("button")
            .toggleClass("onoff-on", !1),
            "border" == a.iama
                ? $(
                      '#form_set_infinity_level button[value="'.concat(
                          a.level || "L1",
                          '"]',
                      ),
                  ).toggleClass("onoff-on", !0)
                : $(
                      '#form_set_infinity_level button[value="'.concat(
                          infinity.get_level() || "L1",
                          '"]',
                      ),
                  ).toggleClass("onoff-on", !0));
    } //TODO9 border dash in rough implementeren
    function fill_fs_border(a) {
        var b = a.iama,
            c = 0;
        ((document.querySelector("#form_border_inner").checked = !0),
            (document.querySelector("#form_border_inner_outer").style.display =
                "none"),
            "path_group" == b
                ? ("double" == a.type &&
                      (document.querySelector(
                          "#form_border_inner_outer",
                      ).style.display = "inherit"),
                  "double" != a.type ||
                  document.querySelector("#form_border_inner_outer input")
                      .checked
                      ? ((c = a.inner_width),
                        (document.querySelector(
                            "#form_border_dash input",
                        ).value = a.dasharray_inner || ""))
                      : ((c = a.outer_width),
                        (document.querySelector(
                            "#form_border_dash input",
                        ).value = a.dasharray_outer || "")))
                : ((c = a.stroke_width),
                  (document.querySelector("#form_border_dash input").value =
                      a.stroke_dasharray || "")),
            (document
                .getElementById("form_border_width")
                .querySelector("input").value = c),
            (document
                .getElementById("cm_border_width")
                .querySelector("input").value = c),
            (document
                .getElementById("form_article_padding")
                .querySelector("input").value = a.padding),
            $(".form_fig_has_path").css(
                "display",
                0 == path.find_connections(a.id).length ? "none" : "flex",
            ),
            (document.querySelector("#form_border_side").style.display =
                "path_group" == b ||
                "text" == b ||
                a.rough ||
                "ellipse" == a.shape
                    ? "none"
                    : "flex"),
            "path_group" != a.iama || "double" != a.type || a.rough
                ? a.rough
                    ? ((document.querySelector(
                          "#form_border_dash_double",
                      ).style.display = "none"),
                      (document.querySelector(
                          "#form_border_dash_single",
                      ).style.display = "none"))
                    : ((document.querySelector(
                          "#form_border_dash_double",
                      ).style.display = "none"),
                      (document.querySelector(
                          "#form_border_dash_single",
                      ).style.display = "block"))
                : ((document.querySelector(
                      "#form_border_dash_double",
                  ).style.display = "block"),
                  (document.querySelector(
                      "#form_border_dash_single",
                  ).style.display = "none")),
            set_language_for_syntax_highlight(a),
            (b || "P" == tag) && toggle_border_buttons(a),
            set_invalid_form_inputs_to_zero());
    }
    function set_language_for_syntax_highlight(a) {
        "syntax_highlighted" in a &&
            (document.querySelector(
                "#form_language_for_syntax_highlight",
            ).value = a.syntax_highlighted);
    }
    function fill_fs_drawing() {
        //let flow = shape['flow']
        // if (flow == 'lineto'){
        // 	document.querySelector('#form_path_lineto').style.display = 'block';
        // 	setup_smoothing_for_lineto();
        // }else{
        // 	document.querySelector('#form_path_lineto').style.display = 'none';
        // }
    }
    function toggle_border_buttons(a) {
        if (
            ((buttons = document.querySelectorAll("#form_border_side button")),
            "border_sides_arr" in a)
        ) {
            var b = a.border_sides_arr;
            _.forEach(buttons, function (a, c) {
                return a.classList.toggle("onoff-on", b[c]);
            });
        } else
            _.forEach(buttons, function (a) {
                return a.classList.toggle("onoff-on", !1);
            });
    }
    function toggle_font_alignment(a) {
        var b = ".text_align_" + a.text_align;
        (d3
            .selectAll(
                ".text_align_left, .text_align_center, .text_align_right",
            )
            .classed("onoff-on", !1),
            d3.selectAll(b).classed("onoff-on", !0));
    }
    function position_path_direction_buttons(a) {
        function b(a, b) {
            //0,1
            //2,3
            var c = {
                    0: [0, 0], //left, top
                    1: ["30px", 0],
                    2: [0, "30px"],
                    3: ["30px", "30px"],
                },
                d = _slicedToArray(c[a], 2),
                e = d[0],
                f = d[1],
                g = _slicedToArray(c[b], 2),
                h = g[0],
                i = g[1];
            (d3.selectAll(".path_direction_tail").style("margin-left", e),
                d3.selectAll(".path_direction_tail").style("margin-top", f),
                d3.selectAll(".path_direction_head").style("margin-left", h),
                d3.selectAll(".path_direction_head").style("margin-top", i));
        }
        var c = path_to_array(a.d),
            d = c[0],
            e = c.slice(-1)[0],
            f = e.x - d.x,
            g = e.y - d.y,
            h =
                Math.min(Math.abs(f), Math.abs(g)) /
                Math.abs(Math.max(Math.abs(f), Math.abs(g)));
        0.25 > h
            ? Math.abs(f) < Math.abs(g)
                ? 0 < g
                    ? b(0, 2)
                    : b(2, 0)
                : 0 < f
                  ? b(0, 1)
                  : b(1, 0)
            : 0 < f && 0 < g
              ? b(0, 3)
              : 0 > f && 0 < g
                ? b(1, 2)
                : 0 < f && 0 > g
                  ? b(2, 1)
                  : b(3, 0);
    } //TODO1 arrow resize buttons wekt nu alleen maar verwarring..... verbeteren of weghalen
    //gifsicle  Peek.gif --no-loopcount > borders.gif
    ("use strict");
    function _toConsumableArray(a) {
        return (
            _arrayWithoutHoles(a) ||
            _iterableToArray(a) ||
            _unsupportedIterableToArray(a) ||
            _nonIterableSpread()
        );
    }
    function _nonIterableSpread() {
        throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _iterableToArray(a) {
        if (
            ("undefined" != typeof Symbol && null != a[Symbol.iterator]) ||
            null != a["@@iterator"]
        )
            return Array.from(a);
    }
    function _arrayWithoutHoles(a) {
        if (Array.isArray(a)) return _arrayLikeToArray(a);
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    var away = 80,
        cmm = (function () {
            function a() {
                ((h.style.display = "none"),
                    (e = !1),
                    predef_styles.styling_predef_done());
            }
            function b(a, b, c) {
                var d, e, f, g;
                return (
                    (d = a.x - c[0]),
                    (f = a.y - c[1]),
                    (e = b.x - c[0]),
                    (g = b.y - c[1]),
                    d * d + f * f < e * e + g * g
                );
            }
            function c() {
                for (var a = h.children, b = 0; b < a.length; b++)
                    a[b].style.display = "none";
                h.querySelector("#cm_closer").style.display = "inline-block";
            }
            function d(a, c) {
                var d = !0,
                    e = !0;
                if (canvas_status.view_mode) return !1;
                if (
                    c.target.parentElement.classList.contains("slide_preview")
                ) {
                    var h = "#cm-slide-preview";
                    ((d = !1), (e = !1));
                } else if (
                    slider &&
                    is_inside(a[0], a[1], xywh_to_bbox(slider))
                ) {
                    var h = "#cm-slide";
                    (set_buttons_for_slide(), (d = !1), (e = !1));
                } else {
                    var i,
                        j =
                            !!a &&
                            shapes_storage.find_clickable_shape(a[0], a[1]);
                    if (
                        (j ? set_current_element(j) : to_canvas.set_canvas(),
                        display_fs_for_shape(currentElement),
                        (me = currentElement.iama),
                        (i = gui_cursor).xy_is_in_range.apply(
                            i,
                            _toConsumableArray(a),
                        ) || gui_buttons.frame_element(currentElement),
                        (document.querySelector(
                            "#cm-fig-menu-addon-pb",
                        ).style.display = "none"),
                        (document.querySelector(
                            "#cm-fig-menu-addon-pp",
                        ).style.display = "none"),
                        "x_axis" == me || "y_axis" == me)
                    )
                        return (c.preventDefault(), !1);
                    if ("text" == me)
                        var h = "#cm-par"; // }else if(me == 'graph_basic'){
                    // 	var selector = '#cm-graph';
                    // 	show_colors = false;
                    // }else if(me == 'axes_board'){
                    // 	var selector = '#cm-board';
                    else if ("fa_icon" == me) var h = "#cm-icon";
                    else if ("drawing" == me) {
                        var h = "#cm-path-basic-without-fo";
                        ((document.querySelector(
                            "#cm-fig-menu-addon-pb",
                        ).style.display = "flex"),
                            (document.querySelector(
                                "#cm-show-drawing-points",
                            ).style.display =
                                "line" == currentElement.type
                                    ? "inherit"
                                    : "none"));
                    } else if ("path_group" == me) {
                        (path.clear_path_attrs(),
                            path.set_path_attrs(currentElement));
                        var k = path_to_array(currentElement.d),
                            l = k[0],
                            m = k.slice(-1)[0]; // to= ps[3];
                        ((cpa.side = b(l, m, a) ? "from" : "to"),
                            (document.querySelector(
                                "#cm-path-directions-from",
                            ).style.display = "flex"),
                            (document.querySelector(
                                "#cm-path-directions-to",
                            ).style.display = "flex"),
                            $(".no-hg").css("display", "block"),
                            $(".form_path_style2 select").val(
                                currentElement.type,
                            ));
                        var h = "#cm-path";
                    } else if ("slide" == me) {
                        var h = "#cm-" + figs[me].my_menu;
                        ((d = !1), (e = !1));
                    } else if ("canvas" == me) {
                        var h = "#cm-svg";
                        (0 < manage_groups.to_list().length
                            ? $(".when_group").css("display", "flex")
                            : $(".when_group").css("display", "none"),
                            update_quick_grouping_forms(),
                            (e = !1));
                    } else if (currentElement.is_cell)
                        //    && (e.ctrlKey || e.shiftKey)){
                        ((h = "#cm-table"), (d = !1), (e = !1));
                    else if ("path_addon" == me)
                        ((h = "#cm-addon"), (d = !1), (e = !1));
                    else if ("math_shape" == me)
                        ((h = "#cm-math-shape"),
                            (document.querySelector(
                                "#cm_math_scale input",
                            ).value = parseInt(
                                get_scale_of_math_shape(currentElement.scale),
                            )));
                    else if (me)
                        if (currentElement.bound && "path_id" in currentElement)
                            h = "#cm-" + figs.text_block.my_menu;
                        else {
                            var h = "#cm-fig";
                            ("custom" == currentElement.shape &&
                                (document.querySelector(
                                    "#cm-fig-menu-addon-pp",
                                ).style.display = "flex"),
                                $(".form_fig_has_path").css(
                                    "display",
                                    0 == path.find_connections(el.id).length
                                        ? "none"
                                        : "flex",
                                ));
                        }
                }
                (currentElement && fill_forms(currentElement),
                    h && (f(h, d, e), g(c.clientX, c.clientY, currentElement)),
                    c.preventDefault());
            }
            function f(a, b, d) {
                (c(),
                    (h.querySelector(a).style.display = "block"),
                    (h.style.display = "block"),
                    (document.querySelector("#cm-colors").style.display = b
                        ? "block"
                        : "none"),
                    (document.querySelector("#cm-delete").style.display = d
                        ? "block"
                        : "none"),
                    (e = !0));
            }
            function g(a, b, c) {
                "canvas" != c.iama &&
                    ((a =
                        transform.applyX(c.x + c.width) + canvas_offset_x + 30),
                    (b = transform.applyY(c.y) + canvas_offset_y));
                var d = h.getBoundingClientRect(),
                    e = window.innerWidth - a - d.width,
                    f = window.innerHeight - b - d.height;
                ((a = 0 < e ? a : a + e),
                    (b = 0 < f ? b : b + f),
                    (h.style.left = Math.max(0, a) + "px"),
                    (h.style.top = Math.max(0, b) + "px"),
                    (c = part_to_chunk(c)),
                    change_selected_in_font_list(
                        document.querySelector("#cm_fonts_list"),
                        c.font_family,
                    ),
                    change_selected_in_font_list(
                        document.querySelector("#cm_fonts_list_par"),
                        c.font_family,
                    ));
            }
            var h = document.querySelector("#context-menu"),
                e = !1;
            return (
                (h.onclick = function (b) {
                    b &&
                        b.target &&
                        !d3.select(b.target).classed("keep-open") &&
                        a();
                }),
                document.addEventListener("contextmenu", function (a) {
                    function b(a, b) {
                        (c(), d(b, a));
                    }
                    (demo_mode && text_to_demo_pane("right click"),
                        (last_pos = [
                            transform.invertX(a.clientX - canvas_offset_x),
                            transform.invertY(a.clientY - canvas_offset_y),
                        ])); //corrected_mouse_position([e.clientX, e.clientY]);
                    var e = document.elementFromPoint(
                        a.clientX - canvas_offset_x,
                        a.clientY - canvas_offset_y,
                    );
                    if (e.parentElement.classList.contains("slide_preview"))
                        b(a);
                    else {
                        if (e.closest("#context-menu")) return !0;
                        if (e.closest(".toolbar1")) return !0;
                        b(a, last_pos);
                    }
                }),
                {
                    off: a,
                    status: function () {
                        return e;
                    },
                    position_and_display: function (a, b, d, f, g) {
                        (c(),
                            (h.querySelector(d).style.display = "block"),
                            (h.style.display = "block"),
                            (document.querySelector(
                                "#cm-colors",
                            ).style.display = f ? "block" : "none"),
                            (document.querySelector(
                                "#cm-delete",
                            ).style.display = g ? "block" : "none"),
                            (e = !0));
                        var i = h.getBoundingClientRect(),
                            j = window.innerWidth - a - i.width,
                            k = window.innerHeight - b - i.height;
                        ((a = 0 < j ? a : a + j),
                            (b = 0 < k ? b : b + k),
                            (h.style.left = a + "px"),
                            (h.style.top = b + "px"));
                    },
                    display_fs_for_current_element: d,
                }
            );
        })(); //cmm = context menu manager
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    } //http://stackoverflow.com/questions/7245/puzzle-find-largest-rectangle-maximal-rectangle-problem
    //http://www.drdobbs.com/database/the-maximal-rectangle-problem/184410529
    function find_largest_rect(a) {
        function b(c, a) {
            ((i[j].one = c), (i[j].two = a), (j += 1));
        }
        function c() {
            return ((j -= 1), [i[j].one, i[j].two]);
        }
        function d(b) {
            a[b].forEach(function (a, b) {
                return (h[b] = a ? h[b] + 1 : 0);
            });
        } // test = ['0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0',
        //     '0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0',
        //     '0 0 0 1 1 0 0 1 0 0 0 1 1 0 1 0',
        //     '0 0 0 1 1 0 1 1 1 0 1 1 1 0 1 0',
        //     '0 0 0 0 1 1 1 1 1 1 1 1 0 0 1 0',
        //     '0 0 0 0 0 0 1 1 1 1 1 1 0 0 1 0',
        //     '0 0 0 0 0 0 1 1 0 1 1 1 1 1 1 0',
        //     '0 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0',
        //     '0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0',
        //     '0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0',
        //     '0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 0',
        //     '0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0']
        // test = ['0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0',
        //     '0 0 1 1 0 0 0 0 0 0 0 0 1 0 0 0',
        //     '0 0 0 1 1 0 0 1 0 0 0 1 1 0 1 0',
        //     '0 0 0 1 1 0 1 1 1 0 1 1 1 0 1 0',
        //     '0 0 0 0 1 1 1 1 1 1 1 1 0 0 1 0',
        //     '0 0 0 0 0 0 1 1 0 1 1 1 0 0 1 0',
        //     '0 0 0 0 0 0 1 1 0 1 1 1 1 1 1 0',
        //     '0 0 1 0 0 0 0 1 0 0 1 1 1 0 1 0',
        //     '0 0 1 1 0 0 0 0 0 0 0 0 0 0 0 0',
        //     '0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1',
        //     '0 0 0 0 1 0 0 0 0 1 1 1 1 1 1 1',
        //     '0 0 0 0 0 0 0 0 0 0 1 1 1 0 0 0']
        // data = test.map(d=> d.split(' ').map(d=> parseInt(d)));
        var e = { one: 0, two: 0 },
            f = { one: -1, two: -1 },
            g = 0,
            h = [],
            i = [],
            j = 0,
            k = a[0].length,
            l = a.length; //M is kolom, N is rij
        return (function a() {
            var j, o;
            for (j = 0; j < k + 1; j += 1)
                ((i[j] = { one: 0, two: 0 }), (h[j] = 0));
            for (o = 0; o < l; o += 1) {
                var p = 0;
                for (
                    d(o), j = 0;
                    j < k + 1;
                    j += 1 //close rectangles
                )
                    if ((h[j] > p && (b(j, p), (p = h[j])), h[j] < p)) {
                        var q, r, s;
                        do {
                            var t = c(),
                                u = _slicedToArray(t, 2);
                            ((q = u[0]),
                                (r = u[1]),
                                (s = p * (j - q)),
                                s > g &&
                                    ((g = s),
                                    (e.one = q),
                                    (e.two = o),
                                    (f.one = j - 1),
                                    (f.two = o - p + 1)),
                                (p = r));
                        } while (h[j] < p);
                        ((p = h[j]), 0 != p && b(q, r));
                    }
            } //return [best_ll.one+1, best_ll.two+1, best_ur.one+1, best_ur.two+1]
            return [e.one, e.two, f.one, f.two];
        })();
    }
    function get_pos_for_foreignObject(a) {
        if ("ellipse" == a.shape) {
            var b = a.width / 2,
                c = a.height / 2,
                d = [
                    (2 * b - Math.sqrt(2) * b) / 2 / a.width,
                    (2 * c - Math.sqrt(2) * c) / 2 / a.height,
                ];
            ((m = (Math.sqrt(2) * b) / a.width),
                (h = (Math.sqrt(2) * c) / a.height));
        } //polygon zonder structuur gedefinieerd in poly_config
        else
            var e = find_inside_pos_for_fo(a),
                f = _slicedToArray(e, 3),
                g = _slicedToArray(f[0], 2),
                i = g[0],
                j = g[1],
                k = f[1],
                l = f[2],
                d = [(i - a.x) / a.width, (j - a.y) / a.height],
                h = l / a.height,
                m = k / a.width;
        return { fo_top_left: d, fo_height: h, fo_width: m };
    }
    function find_inside_pos_for_fo(a) {
        //var offset = [0,0]// d3.transform(g.querySelector('path').getAttribute('transform')).translate;
        //var [x, y, w, h] = this.get_bbox_of_figure(d3.select(g), true, true, false) //laatset / 4de argument alleen van belang bij polygon
        for (
            var b,
                c = [a.x, a.y],
                d = c[0],
                e = c[1],
                f = [a.width, a.height],
                g = f[0],
                k = f[1],
                l = 5,
                m = [],
                n = 0;
            n <= k;
            n += l
        ) {
            b = [];
            for (var o = 0; o <= g; o += l) b.push([o + d, n + e]);
            m.push(b);
        }
        var p = get_points_on_border(a),
            q = m.map(function (a) {
                return a.map(function (a) {
                    return point_is_inside(a, p);
                });
            }),
            r = find_largest_rect(q),
            s = _slicedToArray(r, 4);
        ((tl_x = s[0]), (br_y = s[1]), (br_x = s[2]), (tl_y = s[3]));
        var t = [d + tl_x * l, e + tl_y * l],
            g = (br_x - tl_x + 1) * l,
            k = (br_y - tl_y + 1) * l;
        return [t, g, k];
    } //Polygon.prototype.
    function get_points_on_border(a) {
        var b = a.points,
            c = [a.x, a.y, a.width, a.height],
            d = c[0],
            e = c[1],
            f = c[2],
            g = c[3];
        return b.map(function (a) {
            var b = _slicedToArray(a, 2),
                c = b[0],
                h = b[1];
            return [d + c * f, e + h * g];
        });
    } // function make_poly_line(points){
    // 	var [point1, point2] = points;
    // 	var pos1 = posit2.get_trans(point1, true, false).translate;
    // 	var pos2 = posit2.get_trans(point2, true, false).translate;
    // 	svg.append('path')
    // 		.attr('d', 'M' + pos1 + ' L ' + pos2)
    // 		.attr('class', 'temp_poly_line');
    // }
    function for_triangle(c, d, e, f) {
        //i = index oif closest point
        var g = [0, 1, 2];
        g.splice(c, 1);
        var h = g[0],
            a = g[1],
            b = Math.min(
                Math.abs(d[c][0] - d[h][0]),
                Math.abs(d[c][1] - d[h][1]),
            ),
            i = Math.min(
                Math.abs(d[c][0] - d[a][0]),
                Math.abs(d[c][1] - d[a][1]),
            ),
            j = b < i ? h : a;
        inbetween2(d[c], d[j], e) || (g.splice(g.indexOf(j), 1), (j = g[0]));
        var k = calc_x_from_y(d[c], d[j], e[f], 0 == f % 2, !0);
        return k;
    }
    function get_offset(a, b, c, d, e) {
        ((d = parseInt(d)), (e = parseFloat(e)));
        var f = [
                [b * e, 0],
                [b, c * e],
                [b * e, c],
                [0, c * e],
            ][d],
            g = a.points.map(function (a) {
                var d = _slicedToArray(a, 2),
                    e = d[0],
                    f = d[1];
                return [b * e, c * f];
            }),
            h = 0 == d % 2 ? 0 : 1,
            k = find_index_of_closest_point(g, f),
            l = g.length; //var p = [[perc,0],[1,perc],[perc,1],[0,perc]][side];
        if (3 == g.length) var m = for_triangle(k, g, f, h);
        else {
            var n = inbetween2(g[k], g[(k + 1) % l], f, 0, 1),
                o = inbetween2(g[l * (1 > k) + ((k - 1) % l)], g[k], f, 0, 1);
            if (n && !o) var p = (k + 1) % l;
            else if (o && !n) var p = l * (1 > k) + ((k - 1) % l);
            else if (!(n && o))
                var q = find_closest_projectable(d, g, f),
                    r = _slicedToArray(q, 2),
                    k = r[0],
                    p = r[1];
            else if (between_two_lines(g[k], g[(k + 1) % l], [f]))
                //gebeurd bij parallellogram
                var p = (k + 1) % l;
            else if (
                between_two_lines(g[l * (1 > k) + ((k - 1) % l)], g[k], [f])
            )
                var p = l * (1 > k) + ((k - 1) % l);
            else
                var s = find_closest_projectable(d, g, f),
                    t = _slicedToArray(s, 2),
                    k = t[0],
                    p = t[1];
            var m = calc_x_from_y(g[k], g[p], f[h], 0 == h % 2, !0);
        }
        return [m[0], m[1]];
    }
    function get_offset_for_ellipse(a, b, c, d, e, f) {
        var g = Math.PI,
            h = 0,
            i = (1 - f) * g + f * 0; //functie rx cos t / ry sin t
        return 0 == e
            ? [b + b * Math.cos(i), d + -d * Math.sin(i)]
            : 2 == e
              ? [b + b * Math.cos(i), d + d * Math.sin(i)]
              : 1 == e
                ? [b + b * Math.sin(i), d + d * Math.cos(i)]
                : 3 == e
                  ? [b + -b * Math.sin(i), d + d * Math.cos(i)]
                  : void 0; //top
        //bottom
        //right
        //left
    }
    function path_placement_correction(a, b, c, d, e, f) {
        if ("ellipse" == a.shape) {
            var g = e / 2,
                h = f / 2,
                i = get_offset_for_ellipse(c, g, d, h, 0, b),
                j = get_offset_for_ellipse(c, g, d, h, 2, b),
                k = get_offset_for_ellipse(c, g, d, h, 1, b),
                l = get_offset_for_ellipse(c, g, d, h, 3, b); //x += rx; y+=ry;  //centrum ellipse ipv linksboven bbox
            return [i, k, j, l];
        }
        var m = get_poly_config(a),
            i = get_offset(m, e, f, 0, b),
            j = get_offset(m, e, f, 2, b),
            k = get_offset(m, e, f, 1, b),
            l = get_offset(m, e, f, 3, b);
        return [i, k, j, l];
    }
    function find_index_of_closest_point(a, b) {
        var c = a.map(function (a) {
            return pyth_dist(a, b);
        });
        return c.indexOf(d3.min(c));
    }
    function pyth_dist(a, b) {
        return Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2);
    }
    function between_two_lines(b, c, d) {
        //functie construeert twee parallele lijnen links en rechts van lijn tussen p1 en p2
        //en controleert vervolgens of p_to_check daartussen ligt
        for (
            var e,
                f,
                g =
                    3 < arguments.length && void 0 !== arguments[3]
                        ? arguments[3]
                        : 1,
                h = c[0] - b[0],
                j = c[1] - b[1],
                k = j / h,
                l = b[1] - b[0] * k,
                a = 0;
            a < d.length;
            a++
        )
            if (
                ((f = d[a]),
                k == 1 / 0 || k == -Infinity
                    ? ((t1 = b[0] + g), (t2 = b[0] - g), (e = 0))
                    : 0 == k
                      ? ((t1 = b[1] + g), (t2 = b[1] - g), (e = 1))
                      : ((t1 = k * f[0] + l + g),
                        (t2 = k * f[0] + l - g),
                        (e = 1)),
                !((f[e] > t1 && f[e] < t2) || (f[e] < t1 && f[e] > t2)))
            )
                return !1;
        return !0;
    }
    function find_closest_projectable(a, b, c) {
        var d = _.range(b.length).map(function (a) {
                return [a, (a + 1) % b.length];
            }),
            e = 0 == a || 2 == a ? 0 : 1,
            f = 0 == a || 2 == a ? 1 : 0,
            g = d.map(function (a) {
                return [b[a[0]][e], b[a[1]][e]].sort(function (c, a) {
                    return c > a;
                });
            }),
            h = d.map(function (a) {
                return [b[a[0]][f], b[a[1]][f]].sort(function (c, a) {
                    return c > a;
                });
            }),
            j = c[e];
        projections = g.map(function (a, b) {
            return j >= a[0] && j <= a[1]
                ? Math.min(Math.abs(c[f] - h[b][f]), Math.abs(c[f] - h[b][f]))
                : 1 / 0;
        });
        var k = Math.min.apply(null, projections);
        return d[projections.indexOf(k)];
    }
    function calc_x_from_y(b, c, d, e, f) {
        var g = c[0] - b[0],
            h = c[1] - b[1],
            i = h / g,
            j = b[1] - b[0] * i; //uitgaan van gebruik binnen domein / bereik:
        if (0 == i) return f ? [d, b[1]] : d;
        if (i == 1 / 0 || i == -Infinity) return f ? [b[0], d] : d;
        var a = j + i * d,
            k = (d - j) / i;
        return f ? (e ? [d, a] : [k, d]) : e ? a : k;
    }
    function find_closest_neighbour_fallback(a, b) {
        var c,
            d = Object.values(shapes_storage.borders)
                .concat(Object.values(shapes_storage.math_shapes))
                .filter(function (b) {
                    return b != a;
                }),
            e = d.map(function (a) {
                return posit2.get_mid_of_side(a, (b + 2) % 4);
            }),
            f = posit2.get_mid_of_side(a, b);
        (0 == b &&
            (c = function b(a) {
                return a[1] < f[1];
            }),
            2 == b &&
                (c = function b(a) {
                    return a[1] > f[1];
                }),
            3 == b &&
                (c = function b(a) {
                    return a[0] < f[0];
                }),
            1 == b &&
                (c = function b(a) {
                    return a[0] > f[0];
                }),
            (e = _.zip(d, e)));
        var g = e.filter(function (a) {
            return c(a[1]);
        });
        if (0 == g.length) return !1;
        for (
            var h = g.map(function (a) {
                    return pyth_dist(a[1], f);
                }),
                j = 1 / 0,
                k = 0,
                l = 0;
            l < h.length;
            l++
        )
            h[l] < j && ((j = h[l]), (k = l));
        return g[k][0].id;
    }
    function find_closest_neighbour(a, b) {
        function c(a, b) {
            var c = [(a.left + a.right) / 2, (a.top + a.bottom) / 2];
            return 0 == b
                ? [c[0], a.bottom]
                : 2 == b
                  ? [c[0], a.top]
                  : 1 == b
                    ? [a.left, c[1]]
                    : 3 == b
                      ? [a.right, c[1]]
                      : void 0;
        }
        function d(a, b, d) {
            var e = c(a, b);
            return 0 == b
                ? Math.abs(e[1] - d.bottom)
                : 2 == b
                  ? Math.abs(e[1] - d.top)
                  : 1 == b
                    ? Math.abs(e[0] - d.left)
                    : 3 == b
                      ? Math.abs(e[0] - d.right)
                      : void 0;
        }
        var e,
            f =
                !!(2 < arguments.length && arguments[2] !== void 0) &&
                arguments[2],
            g =
                !(3 < arguments.length && arguments[3] !== void 0) ||
                arguments[3],
            h = Object.values(shapes_storage.borders).concat(
                Object.values(shapes_storage.math_shapes),
            ),
            j = h.map(function (a) {
                return posit2.tlbr(a);
            }),
            k = posit2.tlbr(a); //return find_closest_neighbour_fallback(g, to )
        //pos current shape
        (0 == b && (e = [(k.left + k.right) / 2, k.bottom]),
            2 == b && (e = [(k.left + k.right) / 2, k.top]),
            1 == b && (e = [k.left, (k.bottom + k.top) / 2]),
            3 == b && (e = [k.right, (k.bottom + k.top) / 2]));
        var l;
        (0 == b &&
            (l = function b(a) {
                return (
                    e[1] > a.bottom &&
                    (inbetween(k.left, k.right, a.left) ||
                        inbetween(k.left, k.right, a.right) ||
                        covered(k.left, k.right, a.left, a.right))
                );
            }),
            2 == b &&
                (l = function b(a) {
                    return (
                        e[1] < a.top &&
                        (inbetween(k.left, k.right, a.left) ||
                            inbetween(k.left, k.right, a.right) ||
                            covered(k.left, k.right, a.left, a.right))
                    );
                }),
            1 == b &&
                (l = function b(a) {
                    return (
                        e[0] < a.left &&
                        (inbetween(k.top, k.bottom, a.top) ||
                            inbetween(k.top, k.bottom, a.bottom) ||
                            covered(k.top, k.bottom, a.top, a.bottom))
                    );
                }),
            3 == b &&
                (l = function b(a) {
                    return (
                        e[0] > a.right &&
                        (inbetween(k.top, k.bottom, a.top) ||
                            inbetween(k.top, k.bottom, a.bottom) ||
                            covered(k.top, k.bottom, a.top, a.bottom))
                    );
                }),
            (j = _.zip(h, j)));
        var n = j.filter(function (a) {
            return l(a[1]);
        });
        if (0 == n.length) return !!g && find_closest_neighbour_fallback(a, b);
        for (
            var o = n.map(function (a) {
                    return pyth_dist([a[1].left, a[1].top], e);
                }),
                p = 1 / 0,
                q = 0,
                r = 0;
            r < o.length;
            r++
        )
            o[r] < p && ((p = o[r]), (q = r));
        return 1e6 > o[q] || !g
            ? n[q][0].id
            : !!g && find_closest_neighbour_fallback(a, b);
    }
    function inbetween(a, b, c) {
        return a <= c && b >= c;
    }
    function covered(a, b, c, d) {
        //true if a covers b or b covers a
        return (a < c && b > d) || (c < a && d > b);
    }
    function inbetween2(c, d, e) {
        var f =
                3 < arguments.length && arguments[3] !== void 0
                    ? arguments[3]
                    : 0,
            g =
                4 < arguments.length && arguments[4] !== void 0
                    ? arguments[4]
                    : 0,
            h = Math.min(c[0], d[0]),
            i = Math.max(c[0], d[0]),
            j = Math.min(c[1], d[1]),
            k = Math.max(c[1], d[1]),
            l = i - h,
            m = k - j;
        if (l < f) {
            var n = (f - l) / 2;
            ((h -= n), (i += n));
        }
        if (m < f) {
            var n = (f - m) / 2;
            ((j -= n), (k += n));
        }
        0 < g && ((h -= g), (j -= g), (i += g), (k += g));
        var o = h <= e[0] && e[0] <= i,
            a = j <= e[1] && e[1] <= k;
        return o && a;
    }
    function point_is_inside(a, b) {
        // ray-casting algorithm based on
        // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
        // https://github.com/substack/point-in-polygon MIT LICENSE
        for (
            var c = a[0], d = a[1], e = !1, f = 0, g = b.length - 1;
            f < b.length;
            g = f++
        ) {
            var h = b[f][0],
                k = b[f][1],
                l = b[g][0],
                m = b[g][1],
                n = k > d != m > d && c < ((l - h) * (d - k)) / (m - k) + h;
            n && (e = !e);
        }
        return e;
    }
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    } //TODO2 testen of background color ook wordt opgeslagen
    function check_if_data_is_valid(a) {
        "gs" in a && (a = a.gs);
        new Set([
            "borders",
            "borders_bound",
            "drawings",
            "icons",
            "images",
            "knots",
            "paths",
            "texts",
            " math_shapes",
        ]); //const is_new_map =  Object.keys(data).filter(key=> !shape_keys.has(key)).length == 0 // &&
        //Object.keys(data).length == shape_keys.size;
        return !0;
    }
    function check_if_old_data_is_valid(a) {
        if (
            ("gs" in a && (a = a.gs),
            "[object Array]" != Object.prototype.toString.call(a))
        )
            return (
                text_to_feedback_pane("nothing to load found in file", !0),
                !1
            );
        if (0 == a.length) return !1;
        var b = Object.keys(a[0]);
        return (
            !!_.all(
                ["attrs", "element", "children"].map(function (a) {
                    return !!b.find(function (b) {
                        return b == a;
                    });
                }),
            ) ||
            (text_to_feedback_pane(
                "unknown data in json file. cannot parse",
                !0,
            ),
            !1)
        );
    }
    var save_and_load = (function () {
            // has_object_url = false;
            // object_url = '';
            function a(a, b, c) {
                ("pos" in a &&
                    set_zoom_and_trans(
                        a.pos.x,
                        a.pos.y,
                        a.pos.k,
                        !1,
                        function () {
                            return !1;
                        },
                        !0,
                    ),
                    "styles" in a && predef_styles.load(a.styles),
                    "merged" in a && merged.load(a.merged),
                    "groups" in a && !b && c && manage_groups.load(a.groups),
                    "map_name" in a && !b && (current_map_name = a.map_name),
                    "slides" in a &&
                        !b &&
                        c &&
                        0 < a.slides.order.length &&
                        slide_manager.load_slides(a.slides.order),
                    (document.querySelector(
                        "#grid_canvas",
                    ).style.backgroundColor =
                        "canvas_color" in a && c ? a.canvas_color : null));
            }
            function b() {
                return {
                    // 'load_mathjax': mathjax_loaded,
                    canvas_color:
                        document.querySelector("#grid_canvas").style
                            .backgroundColor, // //'svg_color': document.querySelector('.overlay').style['fill'],
                    pos: JSON.parse(JSON.stringify(transform)),
                    styles: predef_styles.get_classes(),
                    version: VERSION,
                    groups: manage_groups.save(),
                    map_name: current_map_name,
                    datetime: new Date().toUTCString(),
                    merged: merged.save(),
                    slides: { order: slide_manager.save_slides() }, // 'grid': [mdd,
                    //         parseInt(document.querySelector('#form_grid_lines_dx input').value),
                    //         parseInt(document.querySelector('#form_grid_lines_dy input').value),
                    //         ((document.querySelector('#grid'))? 1: 0  ),
                    //         catcher_width ],
                };
            }
            function c() {
                manage_groups.unshow_my_group();
                var a = { gs: shapes_storage.get_data_for_save(), info: b() };
                return a;
            }
            function d(a) {
                return (
                    (res = a.split(".")),
                    document.querySelector("#modal_save_zip").checked
                        ? res[0] + ".zip"
                        : res[0] + ".json"
                );
            }
            function e(a, b, c) {
                if (b) {
                    var d = new JSZip();
                    return (
                        d.file(c, a),
                        d.generateAsync({
                            type: "blob",
                            compression: "DEFLATE",
                        })
                    );
                }
                return Promise.resolve(
                    new Blob([a], { type: "application/json" }),
                ); //return new Blob([json], {type: "application/json"})
            } // function set_object_url(text){
            //     object_url = text;
            //     has_object_url = true;
            // }
            function f(a) {
                var b = document.querySelector("#modal_save_zip").checked;
                ((current_map_name = d(current_map_name || "yourMap.json")),
                    e(a, b, current_map_name.split(".")[0] + ".json").then(
                        function (a) {
                            var b = URL.createObjectURL(a),
                                c = document.getElementById("dl_link");
                            ((c.download = current_map_name),
                                (c.href = b),
                                (c.textContent = "Download"));
                        },
                    ));
            }
            return {
                canvas_to_json: c,
                get_info_for_save: b,
                set_info_on_load: a,
                get_data_to_save: function () {
                    return JSON.stringify(c());
                },
                reset_save: function () {
                    //http://stackoverflow.com/questions/16329293/save-json-string-to-client-pc-using-html5-api
                    var a = save_and_load.get_data_to_save();
                    f(a);
                    var b = document.getElementById("save_name");
                    ((b.value = current_map_name),
                        (document.querySelector("#dl_vis").style.visibility =
                            "inherit"),
                        document.querySelector("#save_name").focus(),
                        (b.onchange = function () {
                            ((current_map_name = d(this.value)),
                                (document.getElementById("dl_link").download =
                                    current_map_name));
                        }));
                }, // get_object_url:function(){
                //     if (this.has_object_url){
                //         return object_url
                //     }else{
                //         return false
                //     }
                // },
            };
        })(),
        local_store = (function () {
            function a() {
                var a = [];
                for (var b in localStorage)
                    "string" == typeof localStorage[b] &&
                        '{"gs":' == localStorage[b].slice(0, 6) &&
                        a.push(b);
                return a;
            }
            function b() {
                (d3.selectAll("#load_previews div").remove(),
                    (document.querySelector(
                        "#load_preview_buttons",
                    ).style.display = "flex"));
            }
            function c(a) {
                !!(1 < arguments.length && arguments[1] !== void 0) &&
                    arguments[1];
                try {
                    var b = save_and_load.get_data_to_save();
                    return (localStorage.setItem(a, b), !0);
                } catch (a) {
                    return (
                        ("QuotaExceededError" === a.name ||
                            "NS_ERROR_DOM_QUOTA_REACHED" === a.name) &&
                            (console.log(
                                "not enough space left in local storage",
                            ),
                            text_to_feedback_pane(
                                [
                                    "not enough space left in local storage",
                                    "Use download or gist save instead",
                                ],
                                !0,
                            )),
                        !1
                    );
                }
            }
            function d() {
                return 0 == shapes_storage.get_all().length;
            }
            function e(b) {
                var c = document.querySelector("#" + b + "_map");
                return (c && c.remove(), !0);
            }
            function f(a, b) {
                var c =
                        !!(2 < arguments.length && arguments[2] !== void 0) &&
                        arguments[2],
                    e = 3 < arguments.length ? arguments[3] : void 0,
                    f = a,
                    d = b
                        .append("div")
                        .attr("id", f + "_map")
                        .attr("class", "load_preview"),
                    g = d.append("label");
                (g.append("h5").text(f),
                    g
                        .append("input")
                        .attr("type", "radio")
                        .attr("name", "local_maps")
                        .attr("id", f)
                        .attr("value", f),
                    (d.node().onclick = function (a) {
                        (_.forEach(
                            document.querySelectorAll(".load_preview"),
                            function (a) {
                                return a.classList.remove("load_selected");
                            },
                        ),
                            a.currentTarget.classList.add("load_selected"));
                    }),
                    d.node().setAttribute("title", e.info.datetime));
            }
            return "undefined" == typeof Storage
                ? (console.log("no local storage"),
                  text_to_feedback_pane("no local storage", !0),
                  !1)
                : {
                      quick_save: function () {
                          var a =
                              "qs_" + current_map_name.split(".")[0] ||
                              "last_quicksave";
                          (text_to_feedback_pane("quick saving as " + a),
                              e(a),
                              this.save(a) &&
                                  text_to_feedback_pane(
                                      'saved map as "' + a + '"',
                                  ));
                      },
                      save: function (a) {
                          var b =
                              !!(
                                  1 < arguments.length &&
                                  void 0 !== arguments[1]
                              ) && arguments[1];
                          return ((a = a || current_map_name), d())
                              ? (show_feedback_modal(
                                    "",
                                    "no data found to save on map",
                                ),
                                text_to_feedback_pane(
                                    "no data found to save on map",
                                ),
                                !1)
                              : (this.check_if_maps_loaded(),
                                !!c(a, b) &&
                                    (f(
                                        a,
                                        d3.select("#load_previews"),
                                        !1,
                                        JSON.parse(localStorage.getItem(a)),
                                    ),
                                    b ||
                                        text_to_feedback_pane(
                                            "map saved locally with name: " + a,
                                        ),
                                    !0));
                      },
                      load: function (a, b) {
                          if (a in localStorage) {
                              var c = JSON.parse(localStorage.getItem(a));
                              return (loader.load_data(c, b, !0), !0);
                          }
                          return (
                              text_to_feedback_pane("could not find map"),
                              !1
                          );
                      },
                      delete: function (a) {
                          (delete localStorage[a], e(a));
                      },
                      log_size_of_storage: function () {
                          //http://stackoverflow.com/questions/4391575/how-to-find-the-size-of-localstorage
                          for (var a in localStorage)
                              console.log(
                                  a +
                                      "=" +
                                      (
                                          (2 * localStorage[a].length) /
                                          1024
                                      ).toFixed(2) +
                                      " kb",
                              );
                      },
                      dump_all: function () {
                          var b = current_map_name,
                              c = a();
                          (c.forEach(function (a) {
                              current_map_name = a + ".json";
                              var b = localStorage.getItem(a),
                                  c = prep_blob_for_download(b);
                              (document.getElementById("dl_link").click(),
                                  URL.revokeObjectURL(c));
                          }),
                              (current_map_name = b));
                      },
                      reset: function () {
                          (text_to_feedback_pane(
                              "loading previews for map. may take a few seconds",
                          ),
                              (function () {
                                  var c = a();
                                  return 0 == c.length
                                      ? (d3
                                            .select("#load_previews")
                                            .append("div")
                                            .text("no maps in local storage"),
                                        !1)
                                      : void (b(),
                                        c.forEach(function (a) {
                                            f(
                                                a,
                                                d3.select("#load_previews"),
                                                !0,
                                                JSON.parse(
                                                    localStorage.getItem(a),
                                                ),
                                            );
                                        }),
                                        text_to_feedback_pane("done loading!"));
                              })());
                      },
                      check_if_maps_loaded: function () {
                          0 ==
                              document.querySelectorAll("#load_previews div")
                                  .length && this.reset();
                      },
                      save_as_gist: function () {
                          // show_wait_spinner('', 'saving gist... may take a few seconds');
                          // var map_data = JSON.parse(save_and_load.get_data_to_save());
                          // if (JSON.stringify(map_data).length > 999999){
                          // 	hide_wait_spinner();
                          // 	show_feedback_modal('To big....', 'Currently not supporting saving maps bigger in size then 1mb as gist.\
                          // 	Please download file, or save in local storage');
                          // 	return false
                          // }
                          // if (map_data.gs.length == 0){
                          // 	text_to_feedback_pane('could not find any map data to save.... The map look empty. Nothing saved');
                          // 	return false
                          // }
                          // var preview = make_map_preview(map_data)
                          // description = document.querySelector('#modal_github_save_section input').value;
                          // if (!is_user_logged_in()){
                          // 	if (confirm('You are not logged in. Are you sure you want to save\
                          // 		this online as an anonymous gist? It will not be private, nor will you\
                          // 		be able to delete it yourself. Press OK to save, cancel to abort.')){
                          // 			console.log('saving....');
                          // 	}else{
                          // 		text_to_feedback_pane('aborted saving map to gist. Nothing saved!!', true);
                          // 		hide_wait_spinner();
                          // 		return false
                          // 	}
                          // }
                          // var arr_for_gist = JSON.stringify([map_data, preview, description]);
                          // $.ajax({
                          // 	type: "POST",
                          // 	headers: {'Content-Type':'application/json'},   //anders werkt request.get_json op server niet
                          // 	url: './makemap/save/gist',
                          // 	data:  arr_for_gist,
                          // 	success: show_gist_save_response,
                          // 	datatype: 'application/json'
                          // });
                      },
                      edit_as_gist: function () {
                          // var map_data = JSON.parse(save_and_load.get_data_to_save());
                          // var preview = make_map_preview(map_data)
                          // description = document.querySelector('#modal_github_save_section input').value;
                          // $.ajax({
                          // 	type: "PATCH",
                          // 	headers: {'Content-Type':'application/json'},   //anders werkt request.get_json op server niet
                          // 	url: './gist/edit/'+id_string,
                          // 	data:  JSON.stringify([map_data, preview, description]),
                          // 	success: show_gist_save_response,
                          // 	datatype: 'application/json'
                          // });
                      },
                      fork_gist: function () {
                          // var that = this
                          // $.ajax({
                          // 	type: "GET",
                          // 	headers: {'Content-Type':'application/json'},   //anders werkt request.get_json op server niet
                          // 	url: './gist/fork/' + id_string,
                          // 	//data:  JSON.stringify([map_data, preview, description]),
                          // 	success: function(resp){
                          // 		if (resp =='error'){
                          // 			text_to_feedback_pane('failed to fork');
                          // 			document.querySelector('#load_previews_gist').innerHTML = "<p>failed to fork</p>";
                          // 		}else{
                          // 			that.get_gist_from_id(resp);
                          // 		}
                          // 	},
                          // 	datatype: 'application/json'
                          // });
                      },
                      get_gists_from_user: function () {
                          // show_wait_spinner('', 'finding /loading gists');
                          // $('#load_previews_gist').load('./gist/' + user_name + '/show', add_click_event_to_gist_link);
                      },
                      get_gist_from_id: function () {
                          // show_wait_spinner('', 'finding /loading gists');
                          // $('#load_previews_gist').load('./gist/info/' + id_string, add_click_event_to_gist_link);
                      },
                      add_single_map_to_preview: f,
                  };
        })(),
        loader = (function () {
            //TODO5 pres_mode kan eruit
            //naam dekt lading niet meer... setup_existing_map
            function a(a, b) {
                //}
                function c() {
                    (Object.values(shapes_storage.borders).forEach(
                        function (a) {
                            return position_texts(a.id);
                        },
                    ),
                        Object.values(shapes_storage.borders_bound).forEach(
                            function (a) {
                                return position_texts(a.id);
                            },
                        ),
                        render());
                    var c = find_highest_id_and_prefix(
                            shapes_storage.get_all(),
                            "_",
                        ),
                        e = _slicedToArray(c, 2),
                        g = e[0],
                        i = e[1];
                    if (((get_new_id = next_id_gen("_", i + 1)), 9998 < i)) {
                        var j = get_new_id_prefix_and_num(),
                            k = _slicedToArray(j, 2),
                            l = k[0],
                            a = k[1];
                        get_new_id = next_id_gen(l, a);
                    }
                    ((last_used_gist_id = !1),
                        slide_manager.update_all_slides(),
                        !f && d && table_init(),
                        cc.clear_all(),
                        render_all(0, !1, !0),
                        hide_wait_spinner(),
                        text_to_feedback_pane("done loading map " + h.map_name),
                        to_canvas.set_canvas());
                }
                var d =
                        !(2 < arguments.length && void 0 !== arguments[2]) ||
                        arguments[2],
                    e =
                        !!(3 < arguments.length && void 0 !== arguments[3]) &&
                        arguments[3],
                    f =
                        !!(4 < arguments.length && void 0 !== arguments[4]) &&
                        arguments[4],
                    g =
                        !!(5 < arguments.length && void 0 !== arguments[5]) &&
                        arguments[5];
                if (
                    (b
                        ? document
                              .querySelector("#edit_mode_menu")
                              .classList.add("menu_hidden")
                        : f ||
                          document
                              .querySelector("#edit_mode_menu")
                              .classList.remove("menu_hidden"),
                    d && !f && slide_manager.clear_all_slide_previews(),
                    !check_if_data_is_valid(a))
                )
                    return (
                        text_to_feedback_pane(
                            "file not recognized as valid breakdown-map",
                            !0,
                        ),
                        !1
                    );
                ((currentElement = !1),
                    manage_groups.reset_all_groups(),
                    (slider = !1),
                    canvas_status.reset());
                var h; // try{
                if ("info" in a) {
                    h = a.info;
                    var i = "version" in a.info ? a.info.version : "20160101";
                    ("20180701" > i
                        ? ((shapes_storage = make_shape_storage()),
                          old_to_new(a.gs, h))
                        : ((shapes_storage = make_shape_storage(a.gs)),
                          save_and_load.set_info_on_load(h, !1, !0)),
                        add_canvas_drag_default());
                } // }catch(err){
                //     text_to_feedback_pane('map contains unknown entities. Load aborted')
                //     console.log(err)
                //     return false
                // }
                // if ('load_mathjax' in info && info['load_mathjax']){
                //     p = load_math_jax();
                //     p.then(()=> second_load());
                // }else{
                c();
            }
            return {
                load_data: a,
                load_part: function b(a) {
                    return (
                        (a = get_new_ids(a)),
                        shapes_storage.add_shapes(a),
                        a
                    );
                },
            };
        })();
    function old_to_new(a, b) {
        function c(a) {
            var b = /style_[0-9]+/,
                c = a.match(b);
            return !!c && "style_" + (parseInt(c[0].split("_")[1]) + 0);
        } // function get_font_family(class_str){
        //     let m = class_str.match(/style_[0-9]/);
        //     if (m) return  predef_styles.get_classes()[m[0]].font_family;
        // }
        // function get_font_fam_from_style(style_str){
        //     let m = style_str.match(/font-family:(.+?);/)
        //     if (m) return m[1].trim();
        // }
        // function get_font_size_from_style(style_str){
        //     let m = style_str.match(/font-size:(.+?);/)
        //     if (m) return m[1].trim();
        // }
        function e(a, b, c, d) {
            var e = find_style_in_string(b, a);
            return e
                ? e
                : (d && (a = d),
                    (a = a.trim()),
                    c && a in predef_styles.get_classes()[c])
                  ? predef_styles.get_classes()[c][a]
                  : void 0;
        }
        function f(a, b) {
            var c = find_style_in_string(a, "font-size");
            if (c) return parseInt(c);
            var d = b.match(/font[0-9]/);
            if (d) return predef_styles.font_class_to_size(d[0]); //TODO
        }
        function g(a) {
            var d =
                    1 < arguments.length && arguments[1] !== void 0
                        ? arguments[1]
                        : [0, 0],
                h = a.attrs.i_am_a;
            if ("knot" == h) {
                var k = a.attrs.id,
                    l = a.attrs.transform
                        .match(/\d+\.?\d*,\d+\.?\d*/)[0]
                        .split(",")
                        .map(function (a) {
                            return parseInt(a);
                        }),
                    m = {
                        x: l[0],
                        y: l[1],
                        iama: "knot",
                        width: 20,
                        height: 20,
                        id: a.attrs.id,
                    };
                shapes_storage.knots.push(m);
            } else if ("path_group" == h) {
                var k = a.attrs.id,
                    n = {
                        id: k,
                        from_side: parseInt(a.attrs.from_side),
                        to_side: parseInt(a.attrs.to_side),
                        type: a.attrs.type,
                        flow: a.attrs.flow,
                        pos1: parseFloat(a.attrs.pos1),
                        pos2: parseFloat(a.attrs.pos2),
                        d: a.children.filter(function (a) {
                            return "click_catcher" == a.attrs["class"];
                        })[0].attrs.d,
                        iama: "path_group",
                        fill: "black",
                        inner_width: 2,
                        outer_width: 4,
                        add_ons: {},
                    };
                if ("style" in a.attrs) {
                    if (a.attrs.style.includes("stroke-dasharray"))
                        var o = find_style_in_string(
                            a.attrs.style,
                            "stroke-dasharray",
                        );
                    (o &&
                        (n.dasharray_inner = o.split(",").map(function (a) {
                            return parseInt(a);
                        })),
                        (n.inner_width = parseInt(
                            find_style_in_string(
                                a.children[0].attrs.style,
                                "stroke-width",
                            ),
                        )),
                        (n.fill = find_style_in_string(
                            a.attrs.style,
                            "stroke",
                        )));
                }
                ("custom_flow" in a.attrs &&
                    (n.custom_flow = a.attrs.custom_flow),
                    a.children.slice(2).forEach(function (a) {
                        if (
                            "arrow_1" == a.attrs["class"] ||
                            "arrow_0" == a.attrs["class"]
                        ) {
                            var d = a.attrs,
                                g = "arrow_1" == d["class"] ? "head" : "tail";
                            ((n.add_ons[g] = {}),
                                (n.add_ons[g].figure = d.type),
                                (n.add_ons[g].width = parseInt(d.arrow_width)),
                                (n.add_ons[g].height = parseInt(
                                    d.arrow_height,
                                )));
                        }
                        if ("text_block" == a.attrs.i_am_a) {
                            var h = c(a.attrs["class"]); //|| 'style_24';
                            h && (active_style.style_class = h); ///zodat fill, stroke etc goed gevuld worden in get_default_*
                            var i = get_default_border(),
                                b = a.attrs.transform
                                    .match(/\d+\.?\d*,\d+\.?\d*/)[0]
                                    .split(",")
                                    .map(function (a) {
                                        return parseInt(a);
                                    });
                            ((i.bound = !0),
                                (i.path_id = n.id),
                                (i.x = b[0]),
                                (i.y = b[1]),
                                (i.width = parseInt(a.attrs.width)),
                                (i.height = parseInt(a.attrs.height)),
                                (i.id = a.attrs.id),
                                (i.font_family =
                                    e(
                                        "font-family",
                                        a.attrs.style,
                                        h,
                                        "font_family",
                                    ) || "Open Sans"),
                                (i.font_size = f(
                                    a.attrs.style,
                                    a.attrs["class"],
                                )),
                                (i.stroke_width = parseInt(
                                    e(
                                        "stroke-width",
                                        a.attrs.style,
                                        h,
                                        "stroke_width",
                                    ),
                                )),
                                (i.stroke =
                                    e("stroke", a.attrs.style, h) || "black"),
                                (i.text_align =
                                    e(
                                        "text-align",
                                        a.attrs.style,
                                        h,
                                        "text-align",
                                    ) || "center"));
                            var j = get_default_text(i); //attrs > width, height,pos_perc, style,
                            ((i.pos_perc = parseFloat(a.attrs.pos_perc)),
                                (j.text = a.children[1].innerText),
                                a.children[1].children &&
                                    (j.text += a.children[1].children
                                        .map(function (a) {
                                            return a.innerText;
                                        })
                                        .join(" ")),
                                (shapes_storage.borders_bound[i.id] = i),
                                (i.num_pars = 1),
                                shapes_storage.add_text(j),
                                position_texts(i.id));
                        }
                    }),
                    j.push(n));
            } else if (
                -1 !=
                    [
                        "rect_basic",
                        "cell_basic",
                        "ellipse_basic",
                        "rect_canvas",
                        "text_basic",
                    ].indexOf(h) ||
                -1 != Object.keys(poly_config).indexOf(h)
            ) {
                var p = function b(a) {
                        return "ellipse_basic" == a
                            ? "ellipse"
                            : -1 == Object.keys(poly_config).indexOf(a)
                              ? "rect"
                              : a;
                    },
                    q = function c(a, b) {
                        var d = a.attrs.style,
                            e = d
                                .match(/data:image\/png;base64,(.+?)\);/)[0]
                                .slice(0, -3);
                        add_background_image(b, e, !1);
                    },
                    r = function d(a, b) {
                        var g = get_default_text(u),
                            h = !!("class" in b) && c(b["class"]);
                        return (
                            h && (g.style_class = h),
                            h || (h = i ? i : "style_24"),
                            (active_style.style_class = h),
                            (g.text = a.innerText),
                            (g.font_family =
                                e("font-family", b.style, h, "font_family") ||
                                "Open Sans"),
                            (g.font_fam_inherited = find_style_in_string(
                                b.style,
                                "font_family",
                            )),
                            (g.font_size = f(b.style, b["class"])),
                            (g.font_size_inherited = !1),
                            g.font_size ||
                                ((g.font_size = u.font_size || 12),
                                (g.font_size_inherited = !0)),
                            (g.fill =
                                e("background-color", b.style, h, "fill") ||
                                "rgba(0,0,0,0)"),
                            (g.color =
                                e(" color", b.style, h, "color") || "black"),
                            (g.has_own_style =
                                find_style_in_string(b.style, "fill") ||
                                find_style_in_string(b.style, "color")),
                            measure_text(g),
                            g
                        );
                    },
                    k = a.attrs.id,
                    s = c(a.attrs["class"]); //|| 'style_24';
                s && (active_style.style_class = s); ///zodat fill, stroke etc goed gevuld worden in get_default_*
                var t = a.attrs.transform
                        .match(/\d+\.?\d*,\d+\.?\d*/)[0]
                        .split(",")
                        .map(function (a) {
                            return parseInt(a);
                        }),
                    u = get_default_border();
                ((u.x = t[0] + d[0]),
                    (u.y = t[1] + d[1]),
                    (u.width = parseInt(a.attrs.width)),
                    (u.height = parseInt(a.attrs.height)),
                    (u.id = k),
                    (u.iama = "border"),
                    (u.shape = p(h)),
                    (u.fixed_size = !0),
                    (u.font_family =
                        e("font-family", a.attrs.style, s, "font_family") ||
                        "Open Sans"),
                    (u.font_size = f(a.attrs.style, a.attrs["class"])),
                    (u.stroke_width = parseInt(
                        e("stroke-width", a.attrs.style, s, "stroke_width"),
                    )),
                    (u.stroke = e("stroke", a.attrs.style, s) || "black"),
                    (u.text_align =
                        e("text-align", a.attrs.style, s, "text-align") ||
                        "center"),
                    "cell_basic" == h &&
                        ((u.table = a.attrs.table), (u.vt = a.attrs.vt)));
                var b = a.children.filter(function (a) {
                        return "foreignObject" == a.element;
                    }),
                    v = 0 < b.length ? b[0].children[0].children : [];
                (v || (v = []),
                    "text_basic" == h &&
                        (v = [
                            {
                                children: [a.children[0]],
                                attrs: a.children[0].attrs,
                            },
                        ]));
                var w = 0;
                ((i = s),
                    v.forEach(function (a, b) {
                        return (
                            !!a.children &&
                            void (a.children.forEach(function (c) {
                                ((c = r(
                                    c,
                                    _.isEmpty(c.attrs) ? a.attrs : c.attrs,
                                )),
                                    (c.par_num = b),
                                    c.text &&
                                        "" != c.text &&
                                        shapes_storage.add_text(c));
                            }),
                            (w = b))
                        );
                    }),
                    (u.num_pars = w + 1),
                    (shapes_storage.borders[u.id] = u),
                    position_texts(u.id));
                try {
                    b[0].children[0].attrs["class"].includes(
                        "has_background",
                    ) && q(b[0].children[0], u);
                } catch (a) {}
                a.children
                    .filter(function (a) {
                        return "g" == a.element;
                    })
                    .forEach(function (a) {
                        return g(a, [u.x, u.y]);
                    });
            } else console.log(a);
        } //paden hier pas toevoegen: anders fouten indien pad eerder wordt toegevoeg dan beide shapes waar die mee gekoppeld is
        function h(a) {
            //index 1 = style_23; index 24 = style_0
            for (var b = a.styles.slice(1), c = 0; 24 > c; c++) {
                var d = b[23 - c],
                    e = find_style_in_string(d, "font-family"); //let font_size = find_style_in_string(s, 'font-size');
                e &&
                    (predef_styles.get_classes()["style_" + c].font_family = e); //if (font_size) predef_styles.get_classes()['style_' + (i)].font_size = font_size;
                var f = find_style_in_string(d, " color");
                f && (predef_styles.get_classes()["style_" + c].color = f);
                var g = find_style_in_string(d, "fill");
                g && (predef_styles.get_classes()["style_" + c].fill = g);
                var h = find_style_in_string(d, "stroke");
                h && (predef_styles.get_classes()["style_" + c].stroke = h);
                var j = find_style_in_string(d, "stroke-width");
                j &&
                    (predef_styles.get_classes()["style_" + c].stroke_width =
                        parseFloat(j));
                var k = find_style_in_string(d, "text-align");
                k && (predef_styles.get_classes()["style_" + c].alignment = k);
                var l = find_style_in_string(d, "padding");
                l &&
                    (predef_styles.get_classes()["style_" + c].padding =
                        parseInt(l));
            }
            for (var m, n = 38; 43 > n; n++)
                ((m = find_style_in_string(b[n], "font-size")),
                    m &&
                        predef_styles.set_font_size_of_predef(
                            n - 38,
                            parseInt(m),
                        ));
        }
        (h(b), predef_styles.load(predef_styles.get_classes()));
        var i,
            j = [];
        (a.forEach(function (a) {
            return g(a);
        }),
            Object.values(shapes_storage.borders).forEach(function (a) {
                "table" in a && (a.is_cell = !0);
            }),
            j.forEach(function (a) {
                return shapes_storage.paths.push(a);
            }),
            j.forEach(function (a) {
                if ((path.set_path_attrs(a), cpa.e1 && cpa.e2)) {
                    var b = path.find_path(!0, !0),
                        c = b[1],
                        d = get_path_pos(c.midpoints, c.cps),
                        e = _slicedToArray(d, 4),
                        f = e[0],
                        g = e[1],
                        h = e[2],
                        i = e[3];
                    ((a.x = f),
                        (a.y = g),
                        (a.width = h),
                        (a.height = i),
                        cpa.arrow_head &&
                            (cpa.path_g.add_ons.head = add_shape_to_line_end(
                                b[1],
                                1,
                                cpa.arrow_head,
                            )),
                        cpa.arrow_tail &&
                            (cpa.path_g.add_ons.tail = add_shape_to_line_end(
                                b[1],
                                0,
                                cpa.arrow_tail,
                            )));
                }
            }));
    }
    function find_style_in_string(a, b) {
        var c = new RegExp(b + ":(.+?);"),
            d = c.exec(a);
        return !!d && d[1].replace(/"/g, "").trim();
    }
    var data_ext_loaded = {};
    ((document.querySelector("#upload").onclick = function (a) {
        this.value = "";
    }),
        (document.querySelector("#upload").onchange = function (a) {
            ((data_ext_loaded = {}),
                d3.selectAll("#load_previews_ext div").remove());
            for (var b, c = !1, d = 0; d < this.files.length; d++) {
                ((b = this.files[d].name), (reader = new FileReader()));
                var e = b.split(".").slice(-1);
                if ("json" != e && "zip" != e) {
                    text_to_feedback_pane(
                        [
                            b +
                                " is not a json or zip file. Will only load json or zip files",
                        ],
                        !0,
                    );
                    continue;
                }
                ("zip" == e
                    ? (reader.readAsArrayBuffer(this.files[d]),
                      (reader.onload = (function (a) {
                          return function (b) {
                              try {
                                  unzip_blob(b.target.result, function (b) {
                                      //let json = JSON.parse(json_str)
                                      return check_if_data_is_valid(b)
                                          ? void (local_store.add_single_map_to_preview(
                                                a,
                                                d3.select("#load_previews_ext"),
                                                c,
                                                b,
                                            ),
                                            !(a in data_ext_loaded) &&
                                                (data_ext_loaded[a] = b))
                                          : (text_to_feedback_pane(
                                                "file " +
                                                    a +
                                                    " not recognized as valid breakdown-map",
                                                !0,
                                            ),
                                            !1);
                                  });
                              } catch (b) {
                                  (console.log(b),
                                      text_to_feedback_pane(
                                          "failed to load map ".concat(
                                              a,
                                              ". It does not appear to be a zipped and valid json map",
                                          ),
                                          !0,
                                          5e3,
                                      ));
                              }
                          };
                      })(b)))
                    : (reader.readAsText(this.files[d]),
                      (reader.onload = (function (a) {
                          return function (b) {
                              try {
                                  var d = JSON.parse(b.target.result);
                              } catch (b) {
                                  (console.log(b),
                                      text_to_feedback_pane(
                                          "failed to load map ".concat(
                                              a,
                                              ". It does not appear to be valid json",
                                          ),
                                          !0,
                                          5e3,
                                      ));
                              }
                              return check_if_data_is_valid(d)
                                  ? void (local_store.add_single_map_to_preview(
                                        a,
                                        d3.select("#load_previews_ext"),
                                        c,
                                        d,
                                    ),
                                    !(a in data_ext_loaded) &&
                                        (data_ext_loaded[a] = d))
                                  : (text_to_feedback_pane(
                                        "file " +
                                            a +
                                            " not recognized as valid breakdown-map",
                                        !0,
                                    ),
                                    !1);
                          };
                      })(b))),
                    (document.querySelector("#load_ext_map").style.display =
                        "block"));
            }
        }),
        (document.querySelector("#load_ext_map").onclick = function () {
            var a = document
                    .querySelector("#load_previews_ext")
                    .querySelector(":checked").value,
                b = data_ext_loaded[a];
            (loader.load_data(b),
                history.pushState({}, "", "/make"),
                close_modal("save_load_modal"));
        }),
        (document.querySelector("#modal_save_zip").onchange = function (a) {
            save_and_load.reset_save();
        }));
    ("use strict");
    ((document.querySelector(".open_modal_save").onclick = function (a) {
        //prep_modal_gist_edit();
        (open_modal("save_load_modal"),
            open_tab(a, "save"),
            save_and_load.reset_save());
    }),
        (document.querySelector(".open_modal_load").onclick = function (a) {
            //show_wait_spinner('', 'loading previews for maps in local storage');
            setTimeout(
                function () {
                    (open_modal("save_load_modal"),
                        open_tab(a, "load"),
                        (menu_status.modal_on = !0),
                        local_store.check_if_maps_loaded());
                }.bind(this),
                200,
            );
        }),
        $(".open_modal1").on("click", function () {
            open_modal("save_load_modal");
        }));
    $(".close_modal").on("click", function (a) {
        (d3.selectAll(".modal").style("display", "none"),
            close_modal(a.target.parentElement.parentElement.id));
    });
    function open_tab(a, b) {
        var c, d;
        for (
            d = document.getElementsByClassName("modal_tab"), c = 0;
            c < d.length;
            c++
        )
            d[c].style.display = "none";
        ((document.getElementById(b).style.display = "block"),
            a &&
                "A" != a.target.tagName &&
                (d3.selectAll("#save_load_modal h2").style("display", "none"),
                (document.querySelector("#modal_" + b).style.display =
                    "block")));
    }
    function close_modal(a) {
        ((document.querySelector("#" + a).style.display = "none"),
            (menu_status.modal_on = !1),
            fa_handler.opened_from_canvas(!1));
    }
    function open_modal(a) {
        ((menu_status.modal_on = !0),
            (document.querySelector("#" + a).style.display = "block"),
            "save_load_modal" == a);
    }
    function open_math_modal(a) {
        (math_jax_specs.loaded || start_math(),
            (menu_status.math_modal_on = !0),
            (document.querySelector("#math_modal").style.display = "block"),
            (document.querySelector("#math_modal textarea").value = a.raw_text),
            (math_jax_specs.shape = a));
    }
    function close_math_modal() {
        ((menu_status.math_modal_on = !1),
            (math_jax_specs.shape = !1),
            (document.querySelector("#math_modal").style.display = "none"));
    }
    ((document.querySelector("#dl_link").onclick = function () {
        ((document.getElementById("dl_vis").style.visibility = "hidden"),
            history.pushState({}, "", "/make"),
            close_modal("save_load_modal"));
    }),
        (document.querySelector("#load_local_map").onclick = function () {
            var a = local_store.load(
                document
                    .querySelector("#load_previews")
                    .querySelector(":checked").value,
                pres_mode_for_load,
            );
            a
                ? (history.pushState({}, "", "/make"),
                  close_modal("save_load_modal"))
                : text_to_feedback_pane(
                      "have you selected a map ? Map not found in local storage",
                  );
        }),
        (document.querySelector("#delete_local_maps").onclick = function () {
            var a = document
                    .querySelector("#load_previews")
                    .querySelector(":checked").value,
                b = "";
            (confirm("delete map" + a + "?")
                ? (local_store["delete"](a), (b = "deleted map " + a))
                : (b = "aborting delete of" + a),
                text_to_feedback_pane(b));
        }),
        (document.querySelector("#savebutton_local").onclick = function () {
            document.getElementById("dl_link").innerText;
            var a = document.getElementById("save_name").value;
            (local_store.save(a.split(".")[0]),
                (document.getElementById("dl_vis").style.visibility = "hidden"),
                history.pushState({}, "", "/make"),
                close_modal("save_load_modal"));
        }),
        (document.querySelector("#modal_load_tabs").onclick = function (a) {
            var b = this.parentElement.querySelectorAll(".modal_sub_tab");
            (this.querySelector(".active").classList.remove("active"),
                a.target.classList.add("active"),
                _.forEach(b, function (a) {
                    return a.classList.add("hidden");
                }),
                (i = ["a", "b", "c"].indexOf(a.target.id)),
                b[i].classList.remove("hidden"));
        }));
    var fa_handler = (function () {
        function a() {
            $.getJSON(
                window.location.origin + "/static/assets/fa_cats_to_icons.json",
                function (a) {
                    ((h = a), (f = !0), (j = h.Emoji[5]));
                },
            );
        }
        function b(a) {
            var b = parseInt(a.target.getAttribute("i"));
            ((j = h[k][b]),
                d3
                    .selectAll("#fa_show_icons i.selected")
                    .classed("selected", !1));
            var c = Array.from(
                document.querySelectorAll("#fa_show_icons .fa-" + j.icon),
            );
            1 == c.length
                ? c[0].classList.add("selected")
                : 400 == j.weight
                  ? c[1].classList.add("selected")
                  : c[0].classList.add("selected");
        }
        function c(c) {
            if (!f) var d = a();
            (document.querySelector("#fa_categories li.selected") &&
                document
                    .querySelector("#fa_categories li.selected")
                    .classList.remove("selected"),
                c.target.classList.add("selected"));
            var e = c.target.innerText,
                g = document.querySelector("#fa_show_icons");
            (d3.select(g).selectAll(".fa, .fab").remove(),
                h[e].forEach(function (a, c) {
                    var d = document.createElement("i");
                    (a.is_brand
                        ? (d.classList.add("fab"), (d.style.fontWeight = 400))
                        : (d.classList.add("fa"),
                          (d.style.fontWeight = a.weight)),
                        d.classList.add("fa-" + a.icon),
                        d.classList.add("fa-3x"),
                        d.setAttribute("i", c),
                        (d.onclick = b),
                        (d.ondblclick = function (a) {
                            (b(a),
                                l &&
                                    ((currentElement.icon = j),
                                    render(),
                                    (l = !1)),
                                close_modal("icon_modal"));
                        }),
                        g.appendChild(d));
                }),
                (k = e));
        }
        function d() {
            var a = document.createElement("ul");
            (document.querySelector("#fa_categories").appendChild(a),
                g.forEach(function (b) {
                    var d = document.createElement("li");
                    (a.appendChild(d), (d.innerText = b), (d.onclick = c));
                }));
        }
        var f = !1,
            g = [
                "Accessibility",
                "Animals",
                "Arrows",
                "Audio & Video",
                "Buildings",
                "Business",
                "Charity",
                "Chat",
                "Chess",
                "Code",
                "Communication",
                "Computers",
                "Currency",
                "Date & Time",
                "Design",
                "Editors",
                "Emoji",
                "Files",
                "Genders",
                "Hands",
                "Health",
                "Images",
                "Interfaces",
                "Logistics",
                "Maps",
                "Mathematics",
                "Medical",
                "Moving",
                "Objects",
                "Payments & Shopping",
                "Shapes",
                "Spinners",
                "Sports",
                "Status",
                "Travel",
                "Users & People",
                "Vehicles",
                "Writing",
            ],
            h = {},
            j = { icon: "flushed", code: "f579", weight: 400, is_brand: !1 },
            k = !1,
            l = !1;
        return {
            init: function b() {
                (d(), a());
            },
            get_icons_per_cat: function a() {
                return h;
            },
            load: a,
            get_selected_icon: function a() {
                return j;
            },
            opened_from_canvas: function b(a) {
                l = a;
            },
        };
    })();
    fa_handler.init();
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function is_link(a) {
        return (
            "DT" == a.tagName &&
            a.querySelector(":scope > A") &&
            a.querySelector(":scope > A").hasAttribute("ICON")
        );
    }
    function is_folder_header(a) {
        return "DT" == a.tagName && a.querySelector("DL");
    }
    function parse_link(a) {
        if (((a = a.querySelector("A")), !a)) return {};
        var b = a.getAttribute("HREF"),
            c = a.getAttribute("ICON"),
            d = a.textContent;
        return { href: b, icon: c, text: d };
    }
    function parse_bookmarks(a) {
        var b = {},
            c = document.createElement("div");
        c.innerHTML = a;
        var d = c.querySelector("DL");
        return (parse_folder(d, b), b);
    }
    var get_title_of_folder = (function () {
        var a = 0;
        return function (b) {
            return 0 < b.children.length
                ? b.children[0].innerText
                : ((a += 1), "_" + a);
        };
    })();
    function parse_folder(a, b) {
        var c =
                2 < arguments.length && arguments[2] !== void 0
                    ? arguments[2]
                    : "root",
            d = c;
        ((b[d] = { children: [] }),
            Array.from(a.children).forEach(function (a) {
                is_link(a)
                    ? b[d].children.push(parse_link(a))
                    : is_folder_header(a) &&
                      parse_folder(
                          a.querySelector("DL"),
                          b[d],
                          get_title_of_folder(a),
                      );
            }));
    }
    function add_fav_icon(a, b) {
        var c = new Image();
        ((c.src = b),
            (c.border_data = {
                x: a.x,
                y: a.y,
                width: a.width,
                height: a.height,
                border_id: a.id,
                sizing: "cover",
                has_fixed_size: !0,
            }),
            (c.onload = function () {
                ((this.border_data.img_width = this.width),
                    (this.border_data.img_height = this.height),
                    (this.border_data.border_width = this.width),
                    (this.border_data.border_height = this.height));
            }),
            (shapes_storage.images[a.id] = c));
    }
    function add_bookmark_to_map(a, c, d) {
        last_pos = [c, d];
        var e = get_new_shape_with_text(a.text),
            f = _slicedToArray(e, 2),
            g = f[0],
            b = f[1]; // if ('icon' in bookmark ){
        //     part.parent.margin_left = 16;
        //     add_fav_icon(b, bookmark.icon);
        //     //position_texts(b.id)
        //     recalc_border_width(b.id, true, true);
        //     position_texts(b.id);
        //     recalc_border_height(b.id);
        // }
        //text_paste_on_border() als nog meer
        return g;
    }
    function add_folder_name(a, c, d) {
        var e = active_style.style_class;
        active_style.style_class = "style_0";
        var f = add_bookmark_to_map({ text: d }, a, c);
        return ((active_style.style_class = e), f);
    }
    function add_path_between_folders(a, b) {
        path.make_new_connection(a, b, !1, {
            disperse: !1,
            manhattan_perc: 0.02,
            from_side: 1,
            to_side: 3,
            fixed_side: !0,
        });
    }
    function add_bookmark_folder(a, c, d, e) {
        var f =
                4 < arguments.length && void 0 !== arguments[4]
                    ? arguments[4]
                    : null,
            g = add_folder_name(c, d, e);
        (f && add_path_between_folders(f, g), (d += g.height + 40));
        var h = d,
            j = c,
            k = 0;
        if ("children" in a) {
            var l = a.children.length,
                m = parseInt(l / 3) + 1;
            a.children.forEach(function (a, e) {
                (0 == e % m && ((k = Math.max(k, h)), (h = d)),
                    (j = c + 285 * parseInt(e / m)));
                var f = add_bookmark_to_map(a, j, h);
                h += f.height + 10;
            });
        }
        return (
            (h = d),
            Object.keys(a)
                .filter(function (a) {
                    return "children" != a;
                })
                .forEach(function (b) {
                    var d = add_bookmark_folder(a[b], c + 825 + 30, h, b, g); //console.log(key, y,ny)
                    h = d;
                }),
            Math.max(k, h)
        );
    }
    function add_bookmarks_to_map(a) {
        var b = last_pos[0],
            c = last_pos[1]; //zoom_to_area
        ((active_style.line_flow = "manhattan"),
            set_zoom_and_trans(last_pos[0], last_pos[1], 2, !1, !1, !0),
            path.change_collision_detection.turn_off_temporary(),
            add_bookmark_folder(a.root, b, c, "root"),
            path.change_collision_detection.restore());
    }
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                p = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((p = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (p) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    ((document.body.onpaste = handle_paste_event),
        (document.body.ondrop = handle_paste_event),
        (document.body.ondragover = function (a) {
            a.preventDefault();
        }));
    function find_target_for_image(a) {
        return "P" == a.tagName ? a : find_g(a);
    }
    function handle_paste_event(a) {
        //functie kiest tussen text / html / pic en stuurt door naar juiste functie
        if ("math_modal_input" == document.activeElement.id) return !0;
        if ("drop" == a.type) {
            var b = shapes_storage.find_clickable_shape(
                transform.invertX(a.clientX),
                transform.invertY(a.clientY),
            ); //find_g(event.target);
            (b || (b = to_canvas.get_canvas()), set_current_element(b));
        }
        var c = "canvas" == currentElement.iama;
        if (
            (a.clientX &&
                (last_pos = [
                    transform.invertX(a.clientX),
                    transform.invertY(a.clientY),
                ]),
            "INPUT" == a.target.tagName)
        )
            return !0; //anders fout bij paste in inputs in modal / forms
        var d = "paste" == a.type ? currentElement : a.target,
            e = (
                a.clipboardData ||
                a.dataTransfer ||
                a.originalEvent.clipboardData
            ).items,
            f = !1; // use event.originalEvent.clipboard for newer chrome versions
        //dit alleen relevant ovor firefox drag file, niet voor paste clipboarddata
        // var firefox = (event.mozInputSource)? true: false;
        // if (firefox) items = event.dataTransfer.files;
        (a.preventDefault(),
            (force_plain_text = document.querySelector(
                "#form_import_force_plain_text",
            ).checked),
            c
                ? (_.map(e, function (a) {
                      return a.type;
                  }).find(function (a) {
                      return "text/html" == a;
                  })
                      ? handle_html_paste_data(e, f)
                      : _.map(e, function (a) {
                              return a.type;
                          }).find(function (a) {
                              return 0 === a.indexOf("image");
                          })
                        ? ((active_style.shape = "rect"),
                          add_active_shape_to_canvas(),
                          handle_pic_paste_event(e, d, f))
                        : _.map(e, function (a) {
                                return a.type;
                            }).find(function (a) {
                                return "text/plain" == a;
                            })
                          ? handle_text_drop_event(
                                e,
                                "text/plain",
                                f,
                                parse_text_data,
                            )
                          : _.map(e, function (a) {
                                  return a.type;
                              }).find(function (a) {
                                  return "text/csv" == a;
                              })
                            ? handle_text_drop_event(
                                  e,
                                  "text/csv",
                                  f,
                                  parse_text_data,
                              )
                            : "" ==
                                  _.map(e, function (a) {
                                      return a.type;
                                  }).find(function (a) {
                                      return "" == a;
                                  }) && handle_unknown_file(e, !1),
                  a.stopPropagation())
                : gui_cursor.cursor_on() || gui_cursor.has_selection()
                  ? _.map(e, function (a) {
                        return a.type;
                    }).find(function (a) {
                        return "text/plain" == a;
                    })
                      ? handle_text_drop_event(
                            e,
                            "text/plain",
                            f,
                            function (a) {
                                (gui_cursor.insert_text(a), render());
                            },
                        )
                      : _.map(e, function (a) {
                            return a.type;
                        }).find(function (a) {
                            return "text/csv" == a;
                        }) &&
                        handle_text_drop_event(e, "text/csv", f, function (a) {
                            (gui_cursor.insert_text(a), render());
                        })
                  : (_.map(e, function (a) {
                        return a.type;
                    }).find(function (a) {
                        return 0 === a.indexOf("image");
                    }) && handle_pic_paste_event(e, d, f),
                    _.map(e, function (a) {
                        return a.type;
                    }).find(function (a) {
                        return "text/plain" == a;
                    })
                        ? handle_text_drop_event(
                              e,
                              "text/plain",
                              f,
                              text_paste_on_border,
                          )
                        : _.map(e, function (a) {
                              return a.type;
                          }).find(function (a) {
                              return "text/csv" == a;
                          }) &&
                          handle_text_drop_event(
                              e,
                              "text/csv",
                              f,
                              text_paste_on_border,
                          )),
            render());
    }
    function handle_unknown_file(a, b) {
        var c = find_blob_of_type("", a, b);
        if (null !== c) {
            var d = new FileReader();
            ((d.onload = function (a) {
                var b = c.name.split(".").slice(-1)[0];
                "json" == b
                    ? parse_json_data(a.target.result)
                    : "xdot" == b
                      ? graphviz.make(a.target.result)
                      : text_to_feedback_pane(
                            "File extension of" + c.name + " unkown",
                        );
            }),
                d.readAsText(c));
        }
    }
    function text_paste_on_border(a) {
        var b = add_paragraph_to_shape(currentElement);
        (add_text_to_paragraph(b, a), set_current_element(currentElement));
    }
    function handle_pic_paste_event(a, b) {
        var c =
            !!(2 < arguments.length && arguments[2] !== void 0) && arguments[2];
        if (!check_if_background_img_possible(b))
            return (
                text_to_feedback_pane(
                    "cannot add background image to this. Image can only be added to a shape",
                    !0,
                ),
                !1
            );
        var d = find_blob_of_type("image", a, c);
        if (null !== d) {
            var e = new FileReader();
            ((e.onload = function (a) {
                add_background_image(currentElement, a.target.result);
            }),
                e.readAsDataURL(d));
        }
    } //ook voor paste event
    function handle_text_drop_event(a, b) {
        var c =
                !!(2 < arguments.length && arguments[2] !== void 0) &&
                arguments[2],
            d = 3 < arguments.length ? arguments[3] : void 0;
        if ("string" == a[0].kind) a[0].getAsString(d);
        else {
            var e = find_blob_of_type(b, a, c);
            if (null !== e) {
                var f = new FileReader();
                ((f.onload = function (a) {
                    d(a.target.result);
                }),
                    f.readAsText(e));
            }
        }
    }
    function find_blob_of_type(a, b) {
        for (
            var c =
                    !!(2 < arguments.length && arguments[2] !== void 0) &&
                    arguments[2],
                d = null,
                e = 0;
            e < b.length;
            e++
        )
            0 === b[e].type.indexOf(a) && (d = c ? b[e] : b[e].getAsFile());
        return d;
    }
    var splitter_for_text_primary = "\n",
        splitter_for_text_parsing = ";",
        auto_number_import = !1,
        tag_import = !1,
        delta_x_import = 15,
        delta_y_import = 15,
        write_colwise = !0,
        max_rc_before_break = 10;
    function get_placer(a) {
        var a = { left: a[0], right: a[0], top: a[1], bottom: a[1] },
            b = [];
        return {
            get_new_pos: function d(c) {
                var e;
                if (0 < c && 0 == c % max_rc_before_break) {
                    if (write_colwise) {
                        var f = Math.max.apply(
                            null,
                            b.map(function (a) {
                                return a.right;
                            }),
                        );
                        e = [f + delta_x_import, a.bottom];
                    } else {
                        var f = Math.max.apply(
                            null,
                            b.map(function (a) {
                                return a.bottom;
                            }),
                        );
                        e = [a.left, f + delta_y_import];
                    }
                    return ((b = []), e);
                }
                return (
                    (e = 0 == b.length ? a : b[b.length - 1]),
                    write_colwise
                        ? [e.left, e.bottom + delta_y_import * (0 != c)]
                        : [e.right + delta_x_import * (0 != c), e.top]
                );
            },
            store_pos: function c(a) {
                b.push(a);
            },
        };
    }
    function is_bookmarks_data(a) {
        return a.startsWith("<!DOCTYPE NETSCAPE-Bookmark-file-1>");
    }
    function parse_text_data(a) {
        function b() {
            var a = document
                .querySelector("#form_import_seperator")
                .value.toString();
            return d(a);
        }
        function c() {
            var a = document
                .querySelector("#form_import_seperator_primary")
                .value.toString();
            return d(a);
        }
        function d(a) {
            return "tab" == a
                ? "\t"
                : "enter" == a
                  ? "\n"
                  : a.match(/\\n/)
                    ? a.replace(/\\n/g, "\n")
                    : a.match(/^\\t/)
                      ? a.replace(/\\t/g, "\t")
                      : a;
        }
        if (is_bookmarks_data(a))
            return (
                console.log("bookmark_data"),
                add_bookmarks_to_map(parse_bookmarks(a)),
                !1
            );
        if (
            ((splitter_for_text_primary = c()),
            (splitter_for_text_parsing = b()),
            splitter_for_text_primary)
        ) {
            var e = a.split(splitter_for_text_primary);
            e = e.filter(function (a) {
                return !1 != a && "" != a && "" != a;
            });
        } else e = [a];
        var f,
            g = {
                left: last_pos[0],
                right: last_pos[0],
                top: last_pos[1],
                bottom: last_pos[1],
            },
            i = 100,
            j = 50,
            h = get_placer(last_pos, i, j),
            k = [];
        ((tag_import = ""),
            setTimeout(function () {
                (e.forEach(function (a, b) {
                    if (a.match(/[a-zA-Z0-9]+/)) {
                        ((f = h.get_new_pos(b)), (last_pos = f));
                        var c = get_default_border(); // if (selected_figure['my_name'] != 'text_basic' && selected_figure['my_name'] != 'icon_basic') add_extra_styles_to_new_el(g);
                        // if (selected_figure.my_name == 'text_basic'){
                        //     d3.select(g).select('text').text('');
                        // }
                        if (
                            ((shapes_storage.borders[c.id] = c),
                            splitter_for_text_parsing)
                        )
                            var d = a
                                .split(splitter_for_text_parsing)
                                .filter(function (a) {
                                    return !1 != a && "" != a && "" != a;
                                });
                        else var d = [a]; // if (auto_number_import || tag_import){
                        //     if (tag_import){
                        //         selected_figure.add_paragraph(g, tag_import + ' ' + (i+1).toString()  );
                        //     }else{
                        //         selected_figure.add_paragraph(g, (i+1).toString() );
                        //     }
                        // }
                        (d.forEach(function (a) {
                            var b = add_paragraph_to_shape(c);
                            add_text_to_paragraph(b, a);
                        }),
                            recalc_border_width(c.id, !1, !0),
                            recalc_border_height(c.id),
                            position_texts(c.id),
                            (tlbr = posit2.tlbr(c)),
                            h.store_pos(tlbr),
                            k.push(c));
                    }
                }),
                    2 < k.length &&
                        k.forEach(function (a) {
                            manage_groups.toggle_element(a);
                        }),
                    render_all(0, !1, !0));
            }, 50));
    } //http://stackoverflow.com/questions/3771824/select-range-in-contenteditable-div
    function select_text_in_paragraph(a) {
        function b(a) {
            //zoekt altijd in eerste kind verder
            for (; 3 !== a.nodeType; ) {
                var b = a.childNodes;
                if (0 == b.length) return !1;
                a = b[0];
            }
            return a;
        }
        if (0 == a.innerText.length) return !1;
        var c = a.childNodes,
            d = b(c[0]),
            e = b(c[c.length - 1]),
            f = document.createRange();
        (f.setStart(d, 0), f.setEnd(e, e.textContent.length));
        var g = window.getSelection();
        return (g.removeAllRanges(), g.addRange(f), !0);
    }
    function make_ready_for_copy(a) {
        1 == manage_groups.get_group(currentElement, !0).length
            ? ((el_to_copy = currentElement),
              (canvas_status.copy_on = !0),
              text_to_feedback_pane("click canvas to paste shape"))
            : text_to_feedback_pane(
                  "to copy group, you can just right click the canvas and then click paste",
              );
    }
    function make_ready_for_cross_window_copy() {
        var a = manage_groups.get_group(currentElement),
            b = [];
        (a.forEach(function (a) {
            b.push(a);
            var c = get_text_with_border_id(a.id);
            (c.forEach(function (a) {
                return delete a.parts;
            }),
                (b = b.concat(c)));
        }),
            0 < b.length
                ? (element_to_json_to_hook(b),
                  a.forEach(function (a) {
                      return position_texts(a.id);
                  }),
                  text_to_feedback_pane("click other canvas to copy"))
                : text_to_feedback_pane(
                      "nothing to cross tab copy: needs group",
                  ));
    }
    function copy_or_cut_from_canvas(a, b) {
        var c = document.createElement("p");
        ((c.textContent = a),
            document.querySelector("#dummy_copy_hook").appendChild(c),
            select_text_in_paragraph(c),
            document.execCommand(b),
            document.querySelector("#dummy_copy_hook").removeChild(c));
    }
    function element_to_json_to_hook(a) {
        copy_or_cut_from_canvas("validator-bn;" + JSON.stringify(a), "copy");
    }
    function copy_prepped_shape_to_canvas(a, b) {
        var c = copy_element_new(
            a,
            b,
            document.querySelector("#form_copy_with_text").checked,
        );
        return (c && gui_buttons.frame_element(c), c);
    }
    function handle_html_paste_data(a) {
        var b = [];
        if (1 == a.length) {
            var c = a[0].getAsFile(function (a) {
                    return resolve(a);
                }),
                d = new FileReader();
            ((d.onloadend = function (a) {
                is_bookmarks_data(this.result) &&
                    add_bookmarks_to_map(parse_bookmarks(this.result));
            }),
                d.readAsText(c));
        } else {
            // if (items[0].type=='text/html'){
            //     var text_item = items[1];
            //     var html_item =  items[0];
            // }else{
            //     var text_item = items[0];
            //     var html_item =  items[1];
            // }
            var e = function b(a) {
                return new Promise(function (b, c) {
                    var e = a.type;
                    a.getAsString(function (a) {
                        return b([a, e]);
                    });
                });
            };
            b = Array.from(a).map(e);
        }
        Promise.all(b)
            .then(function (a) {
                //MUSTDO testen
                if (
                    ((m = a.map(function (a) {
                        return "validator-bn" == a[0].split(";")[0];
                    })),
                    _.any(m))
                ) {
                    //const i = (m[0])? 0 : 1;
                    var b = m.indexOf(!0),
                        c = a[b][0].match(/;/).index,
                        d = a[b][0].slice(c + 1);
                    paste_bn_elements(d);
                } else
                    parse_text_data(
                        a.filter(function (a) {
                            return "text/plain" === a[1];
                        })[0][0],
                    );
            })
            ["catch"](function (a) {
                console.log(a);
            });
    }
    function paste_bn_elements(a) {
        var b = JSON.parse(a); //    if (gs.length ==1){
        //TODO1 wat hier doen ??
        // el = add_me(svg, gs[0], true, false).node();
        // ido(el).reposition_me(el, last_pos[0], last_pos[1], false);
        //  }else{
        b = loader.load_part(b);
        var c = get_bbox_of_group(b),
            d = _slicedToArray(c, 4),
            e = d[0],
            f = d[1],
            g = d[2],
            h = d[3],
            i = [e, g],
            j = last_pos[0] - i[0],
            k = last_pos[1] - i[1]; //  [(maxX + minX)/2, (maxY + minY)/2];
        (b.forEach(function (a) {
            ("border" == a.iama || "math_shape" == a.iama) &&
                (reposition_protocol(a, j, k),
                manage_groups.add(a),
                "border" == a.iama && position_texts(a.id));
        }),
            render_all(0, !1, !0));
    }
    ("use strict");
    function check_if_background_img_possible() {
        return !0; // if (el.tagName == 'P') return true;
        // el = find_g(el);
        // return (!d3.select(el).select('foreignObject').empty() && el.id != 'zoomfield')
    }
    function add_background_image(a, b) {
        var c =
            !(2 < arguments.length && arguments[2] !== void 0) || arguments[2];
        ((b =
            b || selected_background.querySelector("img").getAttribute("src")),
            "text" == a.iama && (a = find_border_by_id(a.border_id)));
        var d = new Image();
        ((d.src = b),
            (d.border_data = {
                x: a.x,
                y: a.y,
                width: a.width,
                height: a.height,
                border_id: a.id,
                sizing: "cover",
            }),
            (shapes_storage.images[a.id] = d),
            (d.onload = function () {
                (calc_image_size(a, this), c && set_current_element(a));
            }));
    }
    function calc_image_size(a, b) {
        var c =
                !!(2 < arguments.length && arguments[2] !== void 0) &&
                arguments[2],
            d = b.width / b.height,
            e = a.width / a.height; //deel van image over gehele border
        ((b.border_data.border_width = a.width),
            (b.border_data.border_height = a.height),
            d > e
                ? ((b.border_data.img_width = b.height * e),
                  (b.border_data.img_height = b.height))
                : ((b.border_data.img_width = b.width),
                  (b.border_data.img_height = b.width / e)));
    }
    function set_image_size(a, b, c) {
        var d = shapes_storage.images[a.id];
        ((d.border_data.border_width = b),
            (d.border_data.border_height = c),
            (d.border_data.img_width = d.width),
            (d.border_data.img_height = d.height),
            (d.border_data.has_fixed_size = !0));
    }
    function size_fig_to_image(a) {
        var b =
                !!(1 < arguments.length && arguments[1] !== void 0) &&
                arguments[1],
            c =
                !!(2 < arguments.length && arguments[2] !== void 0) &&
                arguments[2],
            d = shapes_storage.images[a.id],
            e = [d.width, d.height];
        if (c)
            var f = e[0],
                g = e[1];
        else {
            var i = [a.width, a.height],
                f = i[0],
                g = i[1],
                j = f / g,
                k = parseInt(e[0]) / parseInt(e[1]);
            j < k
                ? b
                    ? (f = g * k)
                    : (g = f / k)
                : b
                  ? (g = f / k)
                  : (f = g * k);
        }
        ((a.width = f),
            (a.height = g),
            calc_image_size(a, shapes_storage.images[a.id]),
            render());
    }
    ($(".background_fit_larger").on("click", function () {
        size_fig_to_image(currentElement, !0, !1);
    }),
        $(".background_fit_smaller").on("click", function () {
            size_fig_to_image(currentElement, !1, !1);
        }),
        $(".background_fit_orig").on("click", function () {
            size_fig_to_image(currentElement, !1, !0);
        }));
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    var slide_preview_dims = {
        width: 200,
        height: 125,
        class: "slide_preview",
        margin: 22,
    };
    function drag_treshold(a) {
        var b = 0;
        return {
            add: function (c, d) {
                return (
                    (b += Math.abs(c) + Math.abs(d)),
                    b > a ? [c, d] : [0, 0]
                );
            },
            reset: function () {
                b = 0;
            },
            treshold_reached: function () {
                return b > a;
            },
        };
    }
    var slide_manager = (function () {
        function a() {
            var a = Array.from(J.querySelectorAll(".slide_preview"));
            S = a.map(function (a) {
                return o(a);
            });
        }
        function b() {
            ((slider = !1),
                (canvas_status.slide_mode = !1),
                gui_buttons.reset_path_control_points(),
                cc.clear_canvas(context_single),
                cc.clear_canvas(gui_context),
                (slide_edit_mode = !1),
                set_buttons_for_slide());
        }
        function c(a) {
            var b = Math.floor(
                a / (slide_preview_dims.height + slide_preview_dims.margin),
            );
            return b;
        }
        function d(a) {
            var b = parseInt(
                    window.getComputedStyle(
                        document.querySelector("#fs_container"),
                    ).height,
                ),
                c = parseInt(J.style.top);
            b - c > a ? F(-1) : a > window.innerHeight - b - c && F(1);
        }
        function e(a, b) {
            b.parentElement.appendChild(b);
            var c = Array.from(J.querySelectorAll("g"));
            c = c.filter(function (a) {
                return a != b;
            });
            for (var d = a; d < c.length; d++)
                c[d] != b && b.parentElement.appendChild(c[d]);
        }
        function f() {
            canvas_status.slide_mode ||
                ((H = this),
                d3.selectAll(".slide_title.active").classed("active", !1),
                this.querySelector("text").classList.add("active"),
                set_buttons_for_slide());
        }
        function g(a) {
            // .on('contextmenu', function(){
            // });
            (a
                .on("mousedown", f)
                .on("click", function () {
                    if (R) {
                        var a = this.parentElement
                            .querySelector(".slide_title")
                            .textContent.match(/[0-9]+/)[0];
                        ((a = parseInt(a)), v(a));
                    }
                    d3.event.stopPropagation();
                })
                .on("dblclick", function () {
                    b();
                    var a = o(H);
                    zoom_to_area(a.xywh, !1);
                }),
                a.call(Q));
        }
        function h(a) {
            ((slide = o(a)),
                (slider = {
                    existing: !0,
                    height: slide.xywh.height,
                    iama: "slider",
                    id: slide.id,
                    width: slide.xywh.width,
                    x: slide.xywh.x,
                    y: slide.xywh.y,
                }),
                draw_slider(slider),
                (canvas_status.slide_mode = !0),
                set_buttons_for_slide());
        }
        function j(a, b) {
            a.append("text") //TODO2 waarom tekst??
                .attr("class", "slide_title")
                .attr("transform", "translate(0,-20)")
                .text("slide " + b);
        }
        function k(a, b) {
            var c = b.xywh,
                d = [transform.x, transform.y, transform.k];
            (zoom_to_area(b.xywh), render_all(0, !1, !0));
            var e = make_snapshot(
                c.x,
                c.y,
                c.width,
                c.height,
                slide_preview_dims.width,
                slide_preview_dims.height,
                canvas.node(),
            );
            if (a.select(".slide_title").empty()) {
                var f = J.querySelectorAll("g").length;
                (a.style(
                    "top",
                    (f - 1) *
                        (slide_preview_dims.height +
                            slide_preview_dims.margin) +
                        "px",
                ),
                    a.style("border-top", "1px solid black"));
            } else
                ((f = a
                    .select(".slide_title")
                    .text()
                    .match(/[0-9]+/)[0]),
                    a.selectAll("*").remove());
            (a.node().appendChild(e),
                g(a),
                j(a, f),
                view.clear_shapes_to_render(),
                set_zoom_and_trans.apply(void 0, d.concat([!1, null, !0])),
                render_all(0, !1, !0));
        }
        function l() {
            var a = Array.from(J.querySelectorAll("g"));
            a = a.filter(function (a) {
                return !a.classList.contains("moving");
            });
            for (
                var b, c = 0;
                c < a.length;
                c++ //
            )
                ((b = d3.select(a[c])),
                    b
                        .transition()
                        .ease(d3.easeExp)
                        .style(
                            "top",
                            c *
                                (slide_preview_dims.height +
                                    slide_preview_dims.margin) +
                                "px",
                        ),
                    b.select(".slide_title").remove(),
                    j(b, c + 1),
                    (o(b.node()).num = c));
        }
        function m(a) {
            return d3.select(J).select("#" + a.id);
        }
        function o(a) {
            var b = a.getAttribute("id");
            return p(b);
        }
        function p(a) {
            var b = S.filter(function (b) {
                return b.id == a;
            });
            if (1 == b.length) return b[0];
        }
        function q() {
            S = [];
        }
        function r(a, b) {
            a.forEach(function (a) {
                return (a.on_slide = b);
            });
        } //TODO9 slide waar preview bedoeld wordt naam aanpassen
        function s(a) {
            var b = [];
            return (
                S.forEach(function (c) {
                    c.shapes.has(a) && b.push(c);
                }),
                b
            );
        }
        function t(a) {
            return function (b, c) {
                //gaat gebruikt worden om shapes te vinden om te renderen in render_all.
                //Is een aparte functie, omdat deze filter toevoegt indien slide niet in bbox staat
                var d = get_items_to_render(b, c),
                    e = _slicedToArray(d, 7),
                    f = e[0],
                    g = e[1],
                    h = e[2],
                    i = e[3],
                    j = e[4],
                    k = e[5],
                    l = e[6],
                    m = "blur(15px)",
                    o = slide_manager.get_current_slide_bbox();
                return (
                    f.forEach(function (b) {
                        !bbox_is_inside_bbox(xywh_to_bbox(b), o) ||
                        a.shapes_excluded.has(b)
                            ? ((b.filter = m),
                              get_text_with_border_id(b.id).forEach(
                                  function (a) {
                                      return (a.filter = m);
                                  },
                              ))
                            : (delete b.filter,
                              get_text_with_border_id(b.id).forEach(
                                  function (a) {
                                      return delete a.filter;
                                  },
                              ));
                    }),
                    i.forEach(function (b) {
                        !bbox_is_inside_bbox(xywh_to_bbox(b), o) ||
                        a.shapes_excluded.has(
                            shapes_storage.borders[b.border_id],
                        )
                            ? (b.filter = m)
                            : delete b.filter;
                    }),
                    [f, g, h, i, j, k, l]
                );
            };
        }
        function u() {
            (Object.values(shapes_storage.borders).forEach(function (a) {
                return delete a.filter;
            }),
                _.flatten(Object.values(shapes_storage.texts)).forEach(
                    function (a) {
                        return delete a.filter;
                    },
                ),
                shapes_storage.paths.forEach(function (a) {
                    return delete a.filter;
                }));
        }
        function v(a) {
            if (a >= S.length || 0 > a) return !1;
            T = a;
            var b = S[a];
            return (
                cc.clear_canvas(gui_context),
                M && view.set_shapes_to_render(b.shapes),
                L ? zoom_to_area(b.xywh, !1, t(b)) : zoom_to_area(b.xywh, !1),
                (document.querySelector(
                    "#slides_quick_controls p",
                ).textContent = a + 1 + " / " + S.length),
                !0
            );
        }
        function w(a) {
            a
                ? ((document.querySelector(
                      "#form_slide_show_controls",
                  ).style.display = "flex"),
                  (document.querySelector(
                      "#form_slide_show_start_controls ",
                  ).style.display = "none"),
                  (document.querySelector(
                      "#slides_quick_controls",
                  ).style.display = "block"))
                : ((document.querySelector(
                      "#form_slide_show_controls",
                  ).style.display = "none"),
                  (document.querySelector(
                      "#form_slide_show_start_controls ",
                  ).style.display = "block"),
                  (document.querySelector(
                      "#slides_quick_controls",
                  ).style.display = "none"));
        }
        function x(a) {
            var b = y(a);
            return b
                ? (S.push(b),
                  cc.clear_canvas(context_single),
                  drag_slides_off(),
                  to_canvas.set_canvas(),
                  canvas.node().focus(),
                  !0)
                : (text_to_feedback_pane(
                      "no shapes found inside slider....Will not make a slide without shapes",
                  ),
                  !1); //omdat anders niet direkt weer via shift control slide toegevoegd kan worden
            //mogelijk ook opgelost door key event listenre op body te zetten in plaats van op canvas.
        } // slides={
        //     id:,
        //     shapes:set,
        //     shapes_excluded: set,
        //     xywh:{w,x,w,h}
        // }
        function y(a) {
            var b = shapes_storage.find_shapes_in_bbox(xywh_to_bbox(a));
            if (0 == b.length) return !1;
            var c = z(),
                d = d3
                    .select(J)
                    .append("g")
                    .attr("class", "slide_preview")
                    .style("position", "absolute");
            (d.attr("id", c), (a.id = c), r(b, c));
            var e = { id: c, shapes: new Set(b), shapes_excluded: new Set() },
                f = a.x,
                g = a.y,
                h = a.width,
                i = a.height;
            return (
                (e.xywh = { x: f, y: g, width: h, height: i }),
                (e.num = S.length),
                k(d, e),
                e
            );
        }
        function z() {
            return ((U += 1), "slide_" + U);
        }
        function A(a) {
            var b = p(a),
                c = m(b);
            k(c, b);
        }
        function B(a, b) {
            var c =
                    !!(2 < arguments.length && arguments[2] !== void 0) &&
                    arguments[2],
                d = p(a);
            d.shapes.forEach(function (a) {
                1 == s(a).length && delete a.on_slide;
            });
            var e = shapes_storage.find_shapes_in_bbox(xywh_to_bbox(b)); //xywh_to_bbox(slider));
            (r(e, d.id),
                (d.shapes = new Set(
                    e.filter(function (a) {
                        return !d.shapes_excluded.has(a);
                    }),
                )),
                (d.xywh = b),
                c || A(a));
        }
        function C(a) {
            var b =
                    1 < arguments.length && arguments[1] !== void 0
                        ? arguments[1]
                        : 40,
                c = get_bbox_of_group(Array.from(a.shapes)),
                d = _slicedToArray(c, 4),
                e = d[0],
                f = d[1],
                g = d[2],
                h = d[3];
            return {
                x: e - b,
                y: g - b,
                width: f - e + 2 * b,
                height: h - g + 2 * b,
            };
        }
        function D() {
            var a = p(H.id);
            ((a.shapes_excluded = new Set(
                Array.from(a.shapes_excluded)
                    .map(function (a) {
                        return shapes_storage.search_shapes_with_id(a.id);
                    })
                    .filter(function (a) {
                        return a;
                    }),
            )),
                (a.shapes = new Set(
                    Array.from(a.shapes)
                        .map(function (a) {
                            return shapes_storage.search_shapes_with_id(a.id);
                        })
                        .filter(function (a) {
                            return a;
                        }),
                )),
                zoom_to_area(a.xywh),
                a.shapes_excluded.forEach(function (a) {
                    return render_hover_highlight(
                        a,
                        "red",
                        gui_context,
                        get_scaled_margin(),
                    );
                }),
                a.shapes.forEach(function (a) {
                    return render_hover_highlight(
                        a,
                        "green",
                        gui_context,
                        get_scaled_margin(),
                    );
                }));
        }
        function E(a, b) {
            (a.shapes["delete"](b),
                a.shapes_excluded.add(b),
                delete b.on_slide);
        } //TODO5 test wat als element buiten slide region wordt aangeklikt
        //wordt ingezoomd dus niet zonder geklooi door gebruiker te doen.
        //niet zuiver, maar niet problematisch
        function F(a) {
            if (0 == a) return !1;
            n = J.querySelectorAll("canvas").length;
            var b =
                    N -
                    n * (slide_preview_dims.height + slide_preview_dims.margin),
                c = parseInt(J.style.top) || 0;
            ((c += a * -SCROLL_DELTA),
                (c = Math.min(
                    Math.max(b + 2 * slide_preview_dims.height, c),
                    N,
                )),
                (J.style.top = c + "px"));
        }
        function G(a) {
            a.shapes_excluded = new Set(
                a.shapes_excluded
                    .map(shapes_storage.search_shapes_with_id)
                    .filter(function (a) {
                        return a;
                    }),
            );
        }
        var H,
            I,
            J = document.querySelector("#fdasdf"),
            K = 0; //http://stackoverflow.com/questions/13078535/stuttering-drag-when-using-d3-behavior-drag-and-transform
        J.style.position = "absolute";
        var L,
            M,
            N = 0,
            O = !1,
            P = "remove",
            Q = d3
                .drag()
                .on("start", function () {
                    ((K = Array.from(J.querySelectorAll("g")).indexOf(this)),
                        this.classList.add("moving"),
                        (I = drag_treshold(15)));
                })
                .on("drag", function () {
                    var a = I.add(0, d3.event.dy),
                        b = _slicedToArray(a, 2),
                        e = b[0],
                        f = b[1];
                    if (0 != f && !canvas_status.slide_mode) {
                        var g = parseInt(this.style.top) + f;
                        (d(g), (this.style.top = g + "px"));
                        var h = c(g);
                        h != K && ((K = h), l());
                    }
                })
                .on("end", function () {
                    if (
                        (this.classList.remove("moving"),
                        I.treshold_reached() && !canvas_status.slide_mode)
                    ) {
                        var b = c(parseInt(this.style.top)) + 1;
                        (e(b, this), l(), R && a());
                    }
                    (f.call(this), set_buttons_for_slide());
                }),
            R = !1,
            S = [],
            T = 0,
            U = 0;
        return {
            set_slide_update_action: function b(a) {
                //"update" or "remove"  "message"
                P = a;
            },
            shrink_wrap_around_figures: function b(a) {
                var c,
                    d =
                        1 < arguments.length && arguments[1] !== void 0
                            ? arguments[1]
                            : [5, 5, 5, 5],
                    e = shapes_storage.find_shapes_in_bbox(xywh_to_bbox(a));
                if (a.existing) {
                    var f = p(a.id);
                    c = find_boundaries_based_on_inside_figs(
                        e.filter(function (a) {
                            return !f.shapes_excluded.has(a);
                        }),
                    );
                } else c = find_boundaries_based_on_inside_figs(e);
                var g = c.top - d[0],
                    i = c.left - d[2],
                    j = c.right - c.left + d[1] + d[3],
                    k = c.bottom - c.top + d[0] + d[2];
                ((a.x = i), (a.y = g), (a.width = j), (a.height = k), render());
            },
            get_current_slide_bbox: function a() {
                return xywh_to_bbox(S[T].xywh);
            },
            get_slides_as_arr: function a() {
                return S;
            },
            handle_object_of_slide_has_moved: function b(a) {
                function c(a, b) {
                    return (
                        a.x > b.x ||
                        a.y > b.y ||
                        a.x + a.width < b.x + b.width ||
                        a.y + a.height < b.y + b.height
                    );
                }
                var d = s(a);
                d.forEach(function (b) {
                    var d = C(b, 5);
                    if (c(b.xywh, d)) {
                        //slide_move_update_action
                        var e = function a() {
                                return B(b.id, d, !slides_mode);
                            },
                            f = function a() {
                                return B(b.id, b.xywh, !slides_mode);
                            };
                        "message" == P
                            ? slide_update_messager.add_message(b, a, e, f)
                            : "update" == P
                              ? e()
                              : f();
                    } //TODO1 wat te doen na meerdere drags van verschillende shapes.
                    //geeft hele rits aan update messages, volgorde van klikken maakt uit voor hoe slide uiteindelijk eruit ziet.
                });
            },
            handle_exclusion_mode_click: function b(a) {
                var c = p(H.id);
                (c.shapes.has(a)
                    ? E(c, a)
                    : c.shapes_excluded.add(a)
                      ? (c.shapes_excluded["delete"](a),
                        c.shapes.add(a),
                        (a.on_slide = c.id))
                      : console.log("to be implemented"),
                    A(c.id),
                    cc.clear_canvas(gui_context),
                    D());
            },
            setup_menu: function a() {
                ((N = document
                    .querySelector("#fs_container")
                    .getBoundingClientRect().bottom),
                    (J.style.top = N + "px"));
            },
            get_slider: o,
            add_slide: x,
            update_slide_by_bbox: B,
            update_slide_snapshot: A,
            delete_slide: function b(a) {
                (d3.select("#" + a.id).remove(),
                    (H = !1),
                    (S = S.filter(function (b) {
                        return b.id != a.id;
                    })),
                    l());
            },
            delete_slide_from_preview: function a() {
                (H.id == slider.id && b(), this.delete_slide(o(H)));
            },
            save_slides: function a() {
                var b = [];
                return (
                    S.forEach(function (a) {
                        var c = {
                            id: a.id,
                            xywh: a.xywh,
                            shapes: Array.from(a.shapes).map(function (a) {
                                return a.id;
                            }),
                            shapes_excluded: Array.from(a.shapes_excluded).map(
                                function (a) {
                                    return a.id;
                                },
                            ),
                        };
                        b.push(c);
                    }),
                    b
                );
            },
            load_slides: function b(a) {
                //bij laden wordt gefiltered bij shapes_excluded, omdat mogelijk voor saven die shapes zijn verwijderd
                //Er is geen functionaliteit om bij verwijderen shape die in een excluded set is deze ook te verwijderen
                //uit die set.
                (this.remove_all_slides(),
                    a.forEach(function (a) {
                        var b = JSON.parse(JSON.stringify(a));
                        ((b.shapes = new Set(
                            b.shapes
                                .map(shapes_storage.search_shapes_with_id)
                                .filter(function (a) {
                                    return a;
                                }),
                        )),
                            G(b));
                        var c = d3
                            .select(J)
                            .append("g")
                            .attr("class", "slide_preview")
                            .style("position", "absolute");
                        (c.attr("id", b.id), S.push(b));
                    }),
                    l(),
                    (U = Math.max.apply(
                        void 0,
                        S.map(function (a) {
                            return parseInt(a.id.split("_")[1]);
                        }),
                    )));
            },
            update_all_slides: function a() {
                S.forEach(function (a) {
                    return A(a.id);
                });
            },
            hide_slider: function a() {
                (cc.clear_canvas(context_single), (slider = !1));
            },
            show_slider: function b(a) {
                h(a);
            },
            toggle_slider_visibility: function c(a) {
                var d = a || H;
                if (slider) return (b(), !1);
                ((canvas_status.slide_mode = !0),
                    set_buttons_for_slide(),
                    h(d));
                var e = slider,
                    f = e.x,
                    g = e.y,
                    i = e.width,
                    j = e.height;
                return (
                    zoom_to_area({
                        x: f - 100,
                        y: g - 100,
                        width: i + 200,
                        height: j + 200,
                    }),
                    draw_slider_resize_points(),
                    !0
                );
            },
            start_slide_show: function b() {
                ids_with_filter_to_clear = [];
                var c = document.querySelector("#form_slide_show_filter");
                ((L = "fade" == c[c.selectedIndex].innerText),
                    (M = "hide" == c[c.selectedIndex].innerText),
                    a(),
                    (R = !0),
                    w(!0),
                    (T = 0),
                    v(0));
            },
            end_slide_show: function b(a) {
                (view.clear_shapes_to_render(),
                    u(),
                    cc.clear_all(),
                    render_all(0, !1, !0),
                    (R = !1),
                    w(!1),
                    _.forEach(
                        document.querySelectorAll('g[i_am_a="slide"]'),
                        function (a) {
                            (a.classList.remove("blank"),
                                a.classList.remove("displayed"),
                                a.classList.add("hidden"));
                        },
                    ),
                    O &&
                        ((O = !1),
                        toggle_slide_edit_menu(void 0, !0),
                        document
                            .querySelector("#sidebar")
                            .classList.remove("menu_hidden")),
                    this.setup_menu());
            },
            next_slide: function a() {
                v(T + 1) || text_to_feedback_pane("no more slides");
            },
            prev_slide: function a() {
                v(T - 1) || text_to_feedback_pane("first slide reached");
            },
            slide_show_on: function a() {
                return R;
            },
            scroll_slides: F,
            clear_all_slide_previews: function a() {
                d3.select(J).selectAll("svg").remove();
            },
            move_slide_in_order: function c(a, b) {
                ((b = b || H), e(a, H), l());
            },
            remove_all_slides: function b(a) {
                (q(),
                    (T = 0),
                    d3.select(J).selectAll(".slide_preview").remove());
            },
            show_all_sliders: function b(a) {
                S.forEach(function (a) {
                    return draw_slider(
                        [a.x, a.y],
                        [a.x + a.width, a.y + a.height],
                    );
                });
            },
            remove_slider: b,
            show_excluded_included: D,
            get_last_clicked_slide_preview: function a() {
                return H;
            },
        };
    })();
    function set_buttons_for_slide() {
        var a, b, c, d, e, f, g, h;
        (slider && slider.existing
            ? ((c = !0), (d = !0), (e = !0))
            : slider && !slider.existing
              ? ((b = !0), (d = !0), (e = !0))
              : ((a = !0),
                slide_manager.get_last_clicked_slide_preview() &&
                    ((h = !0),
                    (g = !0),
                    (f = !0),
                    (document.querySelector("#form_slide_num").innerText =
                        "for slide " +
                        (slide_manager.get_slider(
                            slide_manager.get_last_clicked_slide_preview(),
                        ).num +
                            1)))),
            set_slides_buttons(a, b, c, d, e, f, g, h));
    }
    function set_slides_buttons(a, b, c, d, e, f, g, h) {
        //true is zichtbaar
        (d3.selectAll(".form_add_slide").classed("hidden", !a),
            d3.selectAll(".form_make_slide").classed("hidden", !b),
            d3.selectAll(".form_cancel_slide").classed("hidden", !e),
            d3.selectAll(".form_delete_slide").classed("hidden", !f),
            d3.selectAll(".form_toggle_slider").classed("hidden", !g),
            d3.selectAll(".form_slide_exclusion_mode").classed("hidden", !h),
            d3.selectAll(".form_update_slide").classed("hidden", !c),
            d3.selectAll(".form_wrap_slide").classed("hidden", !d));
    } //Buttons op form en contextmenu slider:
    ($(".form_add_slide").on("click", function (a) {
        (drag_slides_on(), set_slides_buttons(!1, !1, !1, !1, !0));
    }),
        $(".form_make_slide").on("click", make_slide_handler),
        $(".form_cancel_slide").on("click", function (a) {
            (slide_manager.remove_slider(), set_buttons_for_slide());
        }),
        $(".form_delete_slide").on("click", function () {
            (slide_manager.delete_slide_from_preview(),
                set_buttons_for_slide());
        }),
        $(".form_toggle_slider").on("click", function (a) {
            slide_manager.toggle_slider_visibility();
        }),
        $(".form_slide_exclusion_mode").on("click", function (a) {
            (enter_slide_exclusion_mode(),
                slide_manager.show_excluded_included());
        }),
        $(".form_update_slide").on("click", function () {
            if (slider && slider.existing) {
                var a = slider,
                    b = a.x,
                    c = a.y,
                    d = a.width,
                    e = a.height;
                (slide_manager.update_slide_by_bbox(slider.id, {
                    x: b,
                    y: c,
                    width: d,
                    height: e,
                }),
                    slider_off());
            } else text_to_feedback_pane("select a slider to update first");
            set_buttons_for_slide();
        }),
        $(".form_wrap_slide").on("click", function () {
            if (
                (slide_manager.shrink_wrap_around_figures(slider),
                slider.existing)
            ) {
                var a = slider,
                    b = a.x,
                    c = a.y,
                    d = a.width,
                    e = a.height;
                (slide_manager.update_slide_by_bbox(slider.id, {
                    x: b,
                    y: c,
                    width: d,
                    height: e,
                }),
                    slider_off());
            } else (slide_manager.add_slide(slider), slider_off());
            set_buttons_for_slide();
        }));
    function make_slide_handler(a) {
        slide_manager.add_slide(slider) &&
            ((slider.existing = !0), set_buttons_for_slide(), slider_off());
    }
    function slider_off() {
        (slide_manager.remove_slider(), to_canvas.set_canvas());
    }
    ((document.querySelector("#form_slide_show_start").onclick = function (a) {
        slide_manager.start_slide_show();
    }),
        $(".form_slide_show_next").on("click", slide_manager.next_slide),
        $(".form_slide_show_prev").on("click", slide_manager.prev_slide),
        $(".form_slide_show_stop").on("click", function () {
            slide_manager.end_slide_show();
        }),
        (document.querySelector("#slides_menu").onclick =
            slide_manager.setup_menu));
    function scale_to_viewport(a, b, c, d) {
        var e = Math.max(a / c, b / d);
        return e;
    } //document.querySelector('#button_update_all_slides').onclick  = function(e){slide_manager.update_all_slides()};
    document.querySelector("#form_remove_all_slides").onclick =
        slide_manager.remove_all_slides; // document.querySelector('#form_show_all_sliders').onclick = slide_manager.show_all_sliders
    function find_boundaries_based_on_inside_figs(c) {
        function d(a, b) {
            return (
                (a.top = Math.min(a.top, b.top)),
                (a.bottom = Math.max(a.bottom, b.bottom)),
                (a.left = Math.min(a.left, b.left)),
                (a.right = Math.max(a.right, b.right)),
                a
            );
        }
        var e = _.map(c, function (a) {
                return xywh_to_bbox(a);
            }),
            a = _.reduce(e, d, {
                top: 1 / 0,
                bottom: -Infinity,
                left: 1 / 0,
                right: -Infinity,
            });
        return a;
    }
    function enter_slide_exclusion_mode() {
        (slide_manager.remove_slider(),
            (canvas_status.slide_exclusion_mode = !0),
            canvas.on(".click", null),
            canvas.on(".dblclick", null),
            add_canvas_slide_exclusion_mode_click(),
            show_temp_button(
                "click shapes to add or remove from slide. When done, click button",
                "done",
                exit_slide_exclusion_mode,
            ));
    }
    function exit_slide_exclusion_mode() {
        ((canvas_status.slide_exclusion_mode = !1),
            canvas.on(".click", null),
            canvas.on(".dblclick", null),
            add_canvas_default_click(),
            cc.clear_canvas(gui_context),
            (document.querySelector("#fs_temp_button").style.display = "none"));
    }
    document.querySelector("#fdasdf").onwheel = function (a) {
        slide_manager.scroll_slides(Math.sign(a.deltaY));
    };
    function handle_slide_show_key_events(a) {
        return (
            "keyup" != a.type &&
            void (37 == a.keyCode || 40 == a.keyCode
                ? slide_manager.prev_slide()
                : (39 == a.keyCode || 38 == a.keyCode) &&
                  slide_manager.next_slide())
        );
    }
    var slide_update_messager = make_messenger(
        document.querySelector("#form_slide_update_messages"),
        add_slide_update_message,
    );
    function add_slide_update_message(a, b, c, d) {
        this.show_hook();
        var e = this.get_title("slide ".concat(a.id, ", shape ").concat(b.id)),
            f = this.get_button(c, "update"),
            g = this.get_button(d, "remove"),
            h = document.createElement("div");
        (h.classList.add("slide_message"),
            h.appendChild(e),
            h.appendChild(f),
            h.appendChild(g),
            this.hook.appendChild(h));
    }
    var align_update_messager = make_messenger(
        document.querySelector("#form_align_update_messages"),
        align_update_message,
    );
    function align_update_message(a, b) {
        this.show_hook();
        var c = this.get_title("Reset shapes to original position ?"),
            d = this.get_button(a, "reset"),
            e = this.get_button(b, "keep"),
            f = document.createElement("div");
        (f.classList.add("slide_message"),
            f.appendChild(c),
            f.appendChild(d),
            f.appendChild(e),
            this.hook.appendChild(f));
    }
    function make_messenger(a, b) {
        var c = {
            show_hook: function b() {
                a.style.display = "inherit";
            },
            update_hook_after_message_click: function b() {
                0 == a.querySelectorAll(".slide_message").length &&
                    (a.style.display = "none");
            },
            get_title: function b(a) {
                var c = document.createElement("p");
                return ((c.innerText = a), c);
            },
            get_button: function d(a, c) {
                var e = document.createElement("button");
                e.innerText = c;
                var b = this;
                return (
                    (e.onclick = function (c) {
                        (a(),
                            this.parentElement.remove(),
                            b.update_hook_after_message_click());
                    }),
                    e
                );
            },
            count: function b() {
                return a.querySelectorAll("div").length;
            },
            hook: a,
        };
        return { add_message: b.bind(c), message_count: c.count };
    }
    $("#form_slide_update_action").on("change", function (a) {
        var b = this.querySelector(
            "input[name=update_slide_action]:checked",
        ).value;
        slide_manager.set_slide_update_action(b);
    });
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    var roughen_all = !1,
        roughing = (function () {
            function a(a) {
                return a.split(" ").map(function (a) {
                    return parseFloat(a);
                });
            }
            function b(a) {
                (delete a.rough,
                    delete a.rough_pars,
                    delete a.rough_ds,
                    delete a.redraw_data);
            }
            function c(a) {
                //let c = (g.style_class)? predef_styles.get_classes()[g.style_class]: g;
                if ("path_group" == a.iama)
                    var b = a.inner_width,
                        c = a.fill,
                        d = "rgba(0,0,0,0)";
                else
                    var b = a.stroke_width,
                        c = a.stroke,
                        d = a.fill;
                return {
                    strokeWidth: b, //strokeOpacity: parseFloat(s.strokeOpacity),
                    stroke: c,
                    fill: d,
                };
            }
            function e(a) {
                var b = c(a),
                    d = "rough_pars" in a;
                return (
                    d
                        ? ((b.roughness = a.rough_pars.roughness),
                          (b.hachureGap = a.rough_pars.hachureGap),
                          (b.hachureAngle = a.rough_pars.hachureAngle))
                        : ((b.roughness = l),
                          (b.hachureGap = n),
                          (b.hachureAngle = m)),
                    (0 == parseInt(b.hachureGap) || (o && !d)) &&
                        (b.fillStyle = "solid"),
                    b
                );
            }
            function f() {
                return {
                    roughness: l,
                    gap: n,
                    angle: m,
                    roughen_all: roughen_all,
                    fill_is_solid: o,
                };
            }
            function g(a) {
                d3.selectAll("#form_roughness button").classed("onoff-on", !1);
                var b = [1, 2, 4, 7].indexOf(a);
                return (
                    -1 != b &&
                    void document
                        .querySelectorAll("#form_roughness button")
                        [b].classList.add("onoff-on")
                );
            } // plus_minus_generator(  document.getElementById('form_hachure_angle'), function(e){
            //     let val = e.value %180;
            //     e.value = val
            //     angle = parseFloat(val);}, 10, 0);
            // plus_minus_generator(  document.getElementById('form_hachure_gap'), function(e){
            //     let val = Math.min(Math.max(e.value, 3), 25);
            //     e.value = val
            //     gap = parseFloat(val);}, 1, 0);
            // plus_minus_generator(  document.getElementById('form_rough_bow'), function(e){
            //     bow = parseFloat(e.value);}, 1, 0);
            // function math_jax_init(el, rough_c, specs){
            //     //el.shape.items.forEach
            //     el.items.paths.forEach(path => path.redraw_data = rough_c.path(path[1],  specs) )
            //     el.redraw_data = true
            // }
            // function math_jax_draw(el, rough_c){
            //     rough_canvas.draw(el.redraw_data)
            // }
            var i = rough.canvas(canvas.node()),
                j = rough.canvas(canvas_single.node()),
                k = !1,
                l = 1,
                m = 0,
                n = 0,
                o = !0; //parseInt(document.querySelector('#form_hachure_angle input').value);
            //parseInt(document.querySelector('#form_hachure_gap input').value);
            //var bow = parseFloat(document.querySelector('#form_rough_bow input').value);
            return (
                (document.querySelector("#form_make_rough").onclick = function (
                    a,
                ) {
                    return "canvas" == currentElement.iama
                        ? (text_to_feedback_pane("select a shape first"), !1)
                        : void (manage_groups
                              .get_group(currentElement)
                              .forEach(function (a) {
                                  (b(a), (a.rough = !0));
                              }),
                          render());
                }),
                (document.querySelector("#form_undo_rough").onclick = function (
                    a,
                ) {
                    return "canvas" == currentElement.iama
                        ? (text_to_feedback_pane("select a shape first"), !1)
                        : void (manage_groups
                              .get_group(currentElement)
                              .forEach(function (a) {
                                  b(a);
                              }),
                          render());
                }),
                (document.querySelector("#form_roughen_all").onchange =
                    function (a) {
                        roughen_all = this.checked;
                    }),
                $("#form_roughness button").on("click", function (a) {
                    ((l = parseFloat(this.getAttribute("roughness"))), g(l));
                }),
                {
                    get_specs: e,
                    get_current_settings: f,
                    load_settings: function b(a) {
                        (g(a.roughness),
                            (document.querySelector(
                                "#form_hachure_angle input",
                            ).value = a.angle),
                            (document.querySelector(
                                "#form_hachure_gap input",
                            ).value = parseInt(a.gap)),
                            (document.querySelector(
                                "#form_roughen_all",
                            ).checked = a.roughen_all),
                            (o = a.fill_is_solid),
                            (l = a.roughness),
                            (m = a.angle),
                            (n = a.gap),
                            (roughen_all = a.roughen_all));
                    },
                    draw: function c(a, b) {
                        var f,
                            g =
                                !(
                                    2 < arguments.length &&
                                    void 0 !== arguments[2]
                                ) || arguments[2];
                        if (
                            ((f = k ? k : "draw_canvas" == b.canvas.id ? i : j),
                            a.redraw_data)
                        )
                            return (
                                b.save(),
                                b.translate(
                                    a.x - a.redraw_data.origin[0],
                                    a.y - a.redraw_data.origin[1],
                                ),
                                f.draw(a.redraw_data.rough_data),
                                b.restore(),
                                !0
                            );
                        var l,
                            m = e(a);
                        if (((a.rough_pars = m), "path_group" == a.iama))
                            l = f.path(a.d, m);
                        else if ("drawing" == a.iama && "line" == a.type) {
                            var n = path_to_array(a.d).map(function (b) {
                                    var c = b.x,
                                        d = b.y;
                                    return { x: a.x + c, y: a.y + d };
                                }),
                                o = line_generator_linear(n);
                            l = f.path(o, m);
                        } else if ("ellipse" == a.shape)
                            l = f.ellipse(
                                a.x + a.width / 2,
                                a.y + a.height / 2,
                                a.width,
                                a.height,
                                m,
                            );
                        else if ("rect" == a.shape)
                            l = f.rectangle(a.x, a.y, a.width, a.height, m);
                        else {
                            var d = a.width,
                                p = a.height,
                                h = get_poly_config(a),
                                q = h.points.map(function (b) {
                                    var c = _slicedToArray(b, 2),
                                        e = c[0],
                                        f = c[1];
                                    return [a.x + e * d, a.y + f * p];
                                }),
                                r =
                                    line_generator_linear(
                                        q.map(function (a) {
                                            return { x: a[0], y: a[1] };
                                        }),
                                    ) + "z";
                            l = f.path(r, m);
                        }
                        g &&
                            l &&
                            (a.redraw_data = {
                                rough_data: l,
                                origin: [a.x, a.y],
                            });
                    },
                    hook: i,
                    set_for_export: function b(a) {
                        k = rough.canvas(a);
                    },
                    set_default: function a() {
                        k = !1;
                    }, // math_jax_draw,
                }
            );
        })();
    ("use strict");
    var infinity = (function () {
        function a(a) {
            for (var b = ["L0", "L1", "L2", "L3"], c = 0; c < b.length; c++)
                if (a <= f[b[c]].valid_to_zoom_level)
                    return [f[b[c]].scale_for_figure, b[c]];
            return [1, "L1"];
        }
        function b(a) {
            return "L0" == a ? 4 : "L1" == a ? 2 : "L2" == a ? 2 : 1;
        }
        function c(a) {
            return "level" in a
                ? a.level
                : "text" == a.iama
                  ? shapes_storage.borders[a.border_id].level
                  : "L1";
        }
        function d() {
            if (!e) return "L1";
            var b = transform.k,
                c = a(b);
            return c[1];
        }
        var e = !0,
            f = {
                L0: { valid_to_zoom_level: 0.4 },
                L1: { valid_to_zoom_level: 1.5 },
                L2: { valid_to_zoom_level: 3.5 },
                L3: { valid_to_zoom_level: 100 },
            },
            g = { L0: 8, L1: 4, L2: 2, L3: 1 },
            h = {
                L0: predef_styles.font_sizes.map(function (a) {
                    return 2 * a;
                }),
                L1: predef_styles.font_sizes.map(function (a) {
                    return a;
                }),
                L2: predef_styles.font_sizes.map(function (a) {
                    return parseInt(0.5 * a);
                }),
                L3: predef_styles.font_sizes.map(function (a) {
                    return parseInt(0.2 * a);
                }),
            },
            i = { L0: 2, L1: 1, L2: 0.5, L3: 0.25 };
        return {
            get_mdd: function a() {
                return g[d()];
            },
            get_level: d,
            get_font_sizes_of_level: function b(a) {
                return h[a];
            },
            get_font_size: function b(a) {
                var c =
                    1 < arguments.length && void 0 !== arguments[1]
                        ? arguments[1]
                        : 3;
                return (e || (a = "L1"), h[a][c]);
            },
            get_border_width: function c(a, b) {
                e || (a = "L1");
                var d = predef_styles.get_classes()[b].stroke_width * i[a];
                return round_to(d, 1);
            },
            get_standard_scaling: function b(a) {
                var c =
                        !!(1 < arguments.length && arguments[1] !== void 0) &&
                        arguments[1],
                    f =
                        2 < arguments.length && arguments[2] !== void 0
                            ? arguments[2]
                            : 0;
                (!c && e && (c = d()), e || (c = "L1"));
                var g = a * i[c];
                return round_to(g, f);
            },
            turn_scaling_on: function a() {
                return (e = !0);
            },
            turn_scaling_off: function a() {
                return (e = !1);
            },
            change_shape_level: function d(a, c) {
                ("text" == a.iama && (a = find_border_by_id(a.border_id)),
                    manage_groups.get_group(a).forEach(function (a) {
                        var d = a.level;
                        if (d != c) {
                            a.level = c;
                            var e = predef_styles.is_font_class(a.font_size, d);
                            (-1 != e &&
                                (change_font_size_of_el(a, h[c][e]),
                                (a.padding = b(c)),
                                resize_if_wanted_after_font_change(a)),
                                (a.stroke_width = round_to(
                                    (a.stroke_width * i[c]) / i[d],
                                    1,
                                )));
                        }
                    }));
            },
            get_level_of_item: c,
            get_alpha: function b(a) {
                var c = /\d+\.*\d*/g,
                    d = a.match(c);
                if (!d || 4 != d.length) return a;
                d = d.map(function (a) {
                    return parseFloat(a);
                });
                var e = Math.max(0, Math.min(1, transform.k - 1));
                return ((d[3] = e), "rgba(" + d.join(",") + ")");
            },
        };
    })();
    ((document.querySelector("#form_toggle_infinity").onclick = function () {
        (is_toggle_button_on(this)
            ? infinity.turn_scaling_off()
            : infinity.turn_scaling_on(),
            toggle_button(this));
    }),
        $("#form_set_infinity_level button").on("click", function (a) {
            //$(`#form_set_infinity_level button[value="${this.value}"]`).toggleClass('onoff-on', true);
            ($("#form_set_infinity_level")
                .find("button")
                .toggleClass("onoff-on", !1),
                this.classList.add("onoff-on"),
                infinity.change_shape_level(currentElement, this.value),
                set_current_element(currentElement));
        }));
    ("use strict");
    var merged = (function () {
        function a(a) {
            var b =
                1 < arguments.length && void 0 !== arguments[1]
                    ? arguments[1]
                    : [];
            return !(a.id in c) && ((c[a.id] = b), !0);
        }
        function b(a) {
            Object.keys(c).forEach(function (b) {
                -1 != c[b].indexOf(a) &&
                    ((c[b] = c[b].filter(function (b) {
                        return b != a;
                    })),
                    0 == c[b].length && delete c[b],
                    all_children["delete"](a));
            });
        }
        var c = {};
        return (
            (all_children = new Set()),
            {
                is_parent: function (a) {
                    return a.id in c;
                },
                get_children: function (a) {
                    return c[a.id];
                },
                get_parent: function (a) {
                    var b = !1;
                    return (
                        Object.keys(c).forEach(function (d) {
                            -1 != c[d].indexOf(a) &&
                                (b = shapes_storage.borders[d]);
                        }),
                        b
                    );
                },
                add_child: function (a, b) {
                    return all_children.has(b)
                        ? (text_to_feedback_pane(
                              "cannot add a child that already is a child of another shape",
                          ),
                          !1)
                        : -1 == Object.keys(c).indexOf(b.id)
                          ? -1 == c[a.id].indexOf(b)
                              ? (c[a.id].push(b),
                                all_children.add(b),
                                shapes_storage.move_to_top(b),
                                !0)
                              : void 0
                          : (text_to_feedback_pane(
                                "a shape cannot be a parent and a child at the same time... Unmerge first.",
                            ),
                            !1);
                },
                remove_child: b,
                is_child: function (a) {
                    return all_children.has(a);
                },
                create_new_group: a,
                save: function () {
                    var a = {};
                    return (
                        Object.keys(c).forEach(function (b) {
                            a[b] = c[b]
                                .filter(function (a) {
                                    return a;
                                })
                                .map(function (a) {
                                    return a.id;
                                });
                        }),
                        JSON.stringify(a)
                    );
                },
                load: function (a) {
                    all_children = new Set();
                    var b = JSON.parse(a),
                        d = shapes_storage.borders; //shapes_storage.to_dict()
                    Object.keys(b).forEach(function (a) {
                        ((c[a] = b[a]
                            .map(function (a) {
                                return d[a];
                            })
                            .filter(function (a) {
                                return a;
                            })),
                            c[a].forEach(function (a) {
                                return all_children.add(a);
                            }));
                    });
                },
                remove_group: function (a) {
                    (c[a.id].forEach(b), delete c[a.id]);
                },
            }
        );
    })();
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    var no_table = !0,
        tables = {},
        table_with_pos = [];
    function make_cell(a, b, d, e, f, g) {
        var c = get_default_border();
        return (
            (c.x = b[0]),
            (c.y = b[1]),
            (c.width = d),
            (c.height = e),
            (c.vt = f + "_" + g),
            (c.table = a),
            (c.is_cell = !0),
            (c.fixed_size = !0),
            (shapes_storage.borders[c.id] = c),
            c
        );
    }
    function make_table(a) {
        var b = [],
            d = get_table_dims(),
            e = d.w,
            f = d.h,
            c = _slicedToArray(a, 2),
            g = c[0],
            h = c[1],
            i = get_id_for_table();
        ((no_table = !0),
            _.range(d.nrows).forEach(function (a) {
                var j = [];
                (_.range(d.ncols).forEach(function (b) {
                    var c = [g + b * (e + d.cm), h + a * (f + d.rm)],
                        k = make_cell(i, c, e, f, a, b);
                    j.push(k);
                }),
                    b.push(j));
            }),
            (tables[i] = b));
    }
    function get_table_dims() {
        if (cmm.status())
            var a = parseInt(document.querySelector("#cm_num_rows").value),
                b = parseInt(document.querySelector("#cm_num_cols").value);
        else
            var a = parseInt(document.querySelector("#form_num_rows").value),
                b = parseInt(document.querySelector("#form_num_cols").value);
        var c = parseInt(document.querySelector("#form_cell_height").value),
            d = parseInt(document.querySelector("#form_cell_width").value),
            e = parseInt(document.querySelector("#form_row_margin").value),
            f = parseInt(document.querySelector("#form_col_margin").value);
        return { nrows: a, ncols: b, w: d, h: c, rm: e, cm: f };
    }
    function get_r_c_id_from_cell(a) {
        var b = a.vt.split("_").map(function (a) {
                return parseInt(a);
            }),
            d = _slicedToArray(b, 2),
            e = d[0],
            f = d[1],
            c = a.table;
        return [parseInt(e), parseInt(f), c];
    }
    function get_table_row(a) {
        var b = get_r_c_id_from_cell(a),
            d = _slicedToArray(b, 3),
            e = d[0],
            f = d[1],
            c = d[2];
        return tables[c][e];
    }
    function get_table_col(a) {
        var b = get_r_c_id_from_cell(a),
            d = _slicedToArray(b, 3),
            e = d[0],
            f = d[1],
            c = d[2];
        return tables[c].map(function (a) {
            return a[f];
        });
    }
    function get_num_rc_from_table(a) {
        return [tables[a].length, tables[a][0].length];
    }
    function add_rc_to_group(a) {
        ((els = manage_groups.get_group(currentElement, !0)),
            manage_groups.reset(!1));
        els.forEach(function (b) {
            a(b).forEach(function (a) {
                return manage_groups.add(a);
            });
        });
        render_all(0, !1, !0);
    }
    function add_rc_to_table(e, f, g, i, j) {
        var k = get_num_rc_from_table(e),
            a = k,
            b = _slicedToArray(a, 2),
            d = b[0],
            l = b[1];
        ((k = k[0 == j ? 1 : 0]), (no_table = !0));
        var m = [];
        return (
            _.range(k).forEach(function (j) {
                var c = g(d, l, j),
                    k = _slicedToArray(c, 2),
                    n = k[0],
                    o = k[1],
                    p = Object.values(shapes_storage.borders).filter(
                        function (a) {
                            return (
                                a.is_cell &&
                                a.table == e &&
                                a.vt == "".concat(n, "_").concat(o)
                            );
                        },
                    ); //var el = document.querySelector(`g[table="${table_id}"][vt="${a}_${b}"]`);
                if (0 == p.length)
                    var q = find_dummy_pos(tables[e], n, o),
                        r = _slicedToArray(q, 4),
                        s = r[0],
                        t = r[1],
                        u = r[2],
                        z = r[3];
                else {
                    p = p[0];
                    var A = posit2.get_top_left(p),
                        B = _slicedToArray(A, 2),
                        s = B[0],
                        t = B[1],
                        C = posit2.get_w_h(p),
                        D = _slicedToArray(C, 2),
                        u = D[0],
                        z = D[1];
                }
                var E = i(d, l, j),
                    F = _slicedToArray(E, 2),
                    n = F[0],
                    o = F[1],
                    G = make_cell(e, f(s, t, u, z), u, z, n, o);
                m.push(G);
            }),
            m
        );
    } // function table_update(hook){
    //     var arr = Array.from(hook.querySelectorAll('g[table]'));
    //     s = Array.from(new Set(arr.map(d=> d.getAttribute('table'))));
    //     s.forEach(id=>{
    //         var new_id = get_id_for_table();
    //         d3.select(hook).selectAll(`g[table=${id}]`).attr('table', new_id)
    //         reconstruct_table(new_id);
    //     });
    // }
    function reconstruct_table(a) {
        var b = Object.values(shapes_storage.borders).filter(function (b) {
                return b.table == a;
            }),
            c = b
                .map(function (a) {
                    return a.vt.split("_");
                })
                .reduce(
                    function (c, a) {
                        return (
                            c[0].push(parseInt(a[0])),
                            c[1].push(parseInt(a[1])),
                            c
                        );
                    },
                    [[], []],
                ),
            d = _slicedToArray(c, 2),
            e = d[0],
            f = d[1]; //var cells = Array.from(document.querySelectorAll(`g[table=${table_id}]`));
        ((max_r = Math.max.apply(void 0, e) + 1),
            (max_c = Math.max.apply(void 0, f) + 1));
        var g = [];
        (_.range(max_r).forEach(function (e) {
            var d = [];
            (_.range(max_c).forEach(function (f) {
                var c = b.filter(function (b) {
                    return b.table == a && b.vt == e + "_" + f;
                }); //var el = document.querySelector(`g[table="${table_id}"][vt="${r}_${c}"]`) || make_table_dummy_node(r,c,table_id);
                ((c = 0 == c.length ? make_table_dummy_node(e, f, a) : c[0]),
                    d.push(c));
            }),
                g.push(d));
        }),
            (tables[a] = g));
    }
    function make_table_dummy_node(a, b, c) {
        return { me: "dummy_cell", table: c, vt: a + "_" + b };
    }
    function find_dummy_pos(a, b, e) {
        function c(a, b) {
            for (var c, e = b.length, f = 1; f < b.length; f++)
                if (((c = b[(a + f) % e]), "dummy_cell" != c.iama && c != d))
                    return c;
            return !1;
        }
        var d =
                !!(3 < arguments.length && arguments[3] !== void 0) &&
                arguments[3],
            f = c(
                b,
                a.map(function (a) {
                    return a[e];
                }),
            ),
            g = c(e, a[b]),
            i = (j = l = k = 0),
            i = posit2.get_top_left(f)[0],
            j = posit2.get_top_left(g)[1],
            k = posit2.get_w_h(g)[1],
            l = posit2.get_w_h(f)[0]; //uitgesloten dat hele rij is verwijderd (ook als maar 1 kolom of rij)
        //x van andere in zelfde kolom, y andere in zelfde rij, h andere in zelfde rij, w andere in zelfde kolom
        return [i, j, l, k];
    }
    function get_cell_pos(a) {
        var b =
            !!(1 < arguments.length && arguments[1] !== void 0) && arguments[1];
        if ("dummy_cell" == a.iama) {
            var d = get_r_c_id_from_cell(a),
                e = _slicedToArray(d, 3),
                f = e[0],
                g = e[1],
                c = e[2],
                i = find_dummy_pos(tables[c], f, g, a),
                j = _slicedToArray(i, 4),
                k = j[0],
                l = j[1],
                m = j[2],
                n = j[3];
            return b ? [k, l, m, n] : [k, l];
        }
        var o = posit2.get_top_left(a),
            p = _slicedToArray(o, 2),
            k = p[0],
            l = p[1];
        if (b) {
            var q = posit2.get_w_h(a),
                r = _slicedToArray(q, 2),
                m = r[0],
                n = r[1];
            return [k, l, m, n];
        }
        return [k, l];
    }
    function get_rows_cols_of_grouped_cells(a) {
        var b = manage_groups.get_group(a, !0).map(function (a) {
                var b = get_r_c_id_from_cell(a);
                return ((b[2] = a), b);
            }),
            c = _.groupBy(b, function (a) {
                return a[0];
            }),
            d = _.groupBy(b, function (a) {
                return a[1];
            });
        return [c, d];
    }
    function table_to_cols(a) {
        var b = tables[a],
            c = _.range(b[0].length).map(function () {
                return [];
            });
        return (
            b.forEach(function (a) {
                a.forEach(function (a, b) {
                    return c[b].push(a);
                });
            }),
            c
        );
    }
    function set_borders_of_group_of_cells(a, b) {
        cells = manage_groups.get_group(currentElement, !0);
        var c = get_rows_cols_of_grouped_cells(b),
            d = _slicedToArray(c, 2),
            e = d[0],
            f = d[1];
        ((max_col = Math.max.apply(null, Object.keys(f))),
            (max_row = Math.max.apply(null, Object.keys(e))),
            (min_col = Math.min.apply(null, Object.keys(f))),
            (min_row = Math.min.apply(null, Object.keys(e))));
        var g = e[min_row].map(function (a) {
                return a[2];
            }),
            h = e[max_row].map(function (a) {
                return a[2];
            }),
            i = f[max_col].map(function (a) {
                return a[2];
            }),
            j = f[min_col].map(function (a) {
                return a[2];
            });
        cells.forEach(function (a) {
            var c = (d = e = f = !1),
                c = -1 != g.indexOf(a),
                d = -1 != i.indexOf(a),
                e = -1 != h.indexOf(a),
                f = -1 != j.indexOf(a);
            ido(a).calc_border(a, [c, d, e, f]);
        });
    }
    function make_table_from_existing_shapes() {
        var a = manage_groups.get_current_group(),
            b = a.filter(function (a) {
                return "border" == a.iama;
            }); //var rects = els.filter(d=> d.iama == 'rect_basic');
        //var rects = els.filter(d=> !d.classList.contains('i_am_grouped'));
        if (2 > b.length)
            return (
                text_to_feedback_pane([
                    "can only make tables from rect basic",
                    "you can morph shape to rect basic from the shape menu",
                ]),
                !1
            );
        var c = place_existing(b);
        return !!c && (manage_groups.reset(), !0);
    }
    function place_existing(a) {
        var b =
                !!(1 < arguments.length && arguments[1] !== void 0) &&
                arguments[1],
            c = parseInt(document.querySelector("#form_col_margin").value),
            d = parseInt(document.querySelector("#form_row_margin").value),
            e = get_placer_to_table(a, c, d);
        return e.make_table(b);
    } // document.querySelector('#form_row_margin').onclick = document.querySelector('#form_col_margin').onclick=function(e){
    //     var table_id =currentElement.table;
    //     var rects = get_shapes_in_table(table_id);
    //     var res = place_existing(rects, table_id);
    //     render_all(0,false,true);
    // }
    function get_shapes_in_table(a) {
        var b = [];
        return (
            tables[a].forEach(function (a) {
                b = b.concat(a);
            }),
            b.filter(function (a) {
                return "dummy_cell" != a.iama;
            })
        );
    }
    function unmake_table(a) {
        var b = tables[a];
        (b.forEach(function (a) {
            a.forEach(function (a) {
                (delete a.table, delete a.vt, delete a.is_cell);
            });
        }),
            delete tables[a]);
    }
    function set_row_height(a) {
        var b = get_table_row(a),
            c = Math.max.apply(
                void 0,
                b.map(function (a) {
                    return a.height;
                }),
            );
        b.forEach(function (a) {
            "dummy_cell" != a.iama && resize_shape(a, 0, c - a.height);
        });
    }
    function set_col_width(a) {
        var b = get_table_col(a),
            c = Math.max.apply(
                void 0,
                b.map(function (a) {
                    return a.width;
                }),
            );
        b.forEach(function (a) {
            "dummy_cell" != a.iama && resize_shape(a, c - a.width, 0);
        });
    }
    function resize_cell(a, b, c) {
        !!(4 < arguments.length && arguments[4] !== void 0) && arguments[4];
        if ("dummy_cell" != a.iama) {
            var d = resize_shape(a, b, c);
            if (!d) return !1;
        }
        if (
            !d3.event ||
            (d3.event.sourceEvent && !d3.event.sourceEvent.shiftKey)
        ) {
            var e = get_my_table(a),
                f = find_my_neighbours(e, a),
                g = _slicedToArray(f, 4),
                h = g[0],
                i = g[1],
                j = g[2],
                k = g[3];
            (i && repos_cell(i, 0, c, !0, !1, !1),
                j && repos_cell(j, b, 0, !0, !1, !1));
        }
    }
    function repos_cell(a, b, c, d) {
        var e =
            !!(5 < arguments.length && void 0 !== arguments[5]) && arguments[5];
        if (
            ((my_els = []),
            repos_shape(a, b, c),
            !d3.event || (d3.event && !d3.event.sourceEvent.shiftKey))
        ) {
            var f = get_my_table(a),
                g = find_my_neighbours(f, a),
                h = _slicedToArray(g, 4),
                i = h[0],
                j = h[1],
                k = h[2],
                l = h[3];
            (e
                ? (i && "up" == e && 0 != b && repos_cell(i, b, 0, d, !1, "up"),
                  j &&
                      "down" == e &&
                      0 != b &&
                      repos_cell(j, b, 0, d, !1, "down"),
                  k &&
                      "right" == e &&
                      0 != c &&
                      repos_cell(k, 0, c, d, !1, "right"),
                  l &&
                      "left" == e &&
                      0 != c &&
                      repos_cell(l, 0, c, d, !1, "left"))
                : (i && 0 != b && repos_cell(i, b, 0, d, !1, "up"),
                  j && 0 != b && repos_cell(j, b, 0, d, !1, "down"),
                  k && 0 != c && repos_cell(k, 0, c, d, !1, "right"),
                  l && 0 != c && repos_cell(l, 0, c, d, !1, "left")),
                0 != b && k && repos_cell(k, b, 0, d, !1, "right"),
                0 != c && j && repos_cell(j, 0, c, d, !1, "down"));
        }
    }
    function get_my_table(a) {
        var b = a.table;
        return tables[b];
    }
    function find_my_neighbours(a, b) {
        var d = b.vt.split("_").map(function (a) {
                return parseInt(a);
            }),
            f = _slicedToArray(d, 2),
            g = f[0],
            h = f[1],
            c = !!(0 < g) && a[g - 1][h],
            i = !!(g < a.length - 1) && a[g + 1][h],
            j = a[0].length,
            k = !!(0 < h) && a[g][h - 1],
            l = !!(h < j - 1) && a[g][h + 1];
        return [c, i, l, k];
    } // $('#cm_table_drag_toggle').on('click', function(e){
    //     var table_id = currentElement.getAttribute('table')
    //     if (!table_id) return false
    //     tables[table_id].forEach(row=>{
    //         row.forEach(cell=> toggle_draggability_of_element(cell));
    //     });
    // });
    // $('.cm_table_align_row').on('click', function(e){
    //     var [r,c,table_id] = get_r_c_id_from_cell(currentElement)
    //     tables[table_id].forEach(row=>{
    //         align_figs(row[c], row, 'both', true);
    //     });
    //     render_all(0,false,true);
    // })
    // $('.cm_table_align_col').on('click', function(e){
    //     var [r,c,table_id] = get_r_c_id_from_cell(currentElement);
    //     var cols = table_to_cols(table_id);
    //     cols.forEach(col=>{
    //         align_figs(col[r], col, 'vert', true);
    //     })
    //     render_all(0,false,true);
    // })
    // $('.cm_table_even_size_row').on('click', function(e){
    //     set_row_height(currentElement);
    //     render_all(0,false,true);
    // });
    // $('.cm_table_even_size_col').on('click', function(e){
    //     set_col_width(currentElement);
    //     render_all(0,false,true);
    // });
    // $('.cm_table_even_size_all').on('click', function(e){
    //     get_table_row(currentElement).forEach(cell=>{
    //         set_col_width(cell);
    //     });
    //     get_table_col(currentElement).forEach(cell=>{
    //         set_row_height(cell);
    //     });
    // });
    // $('.cm_table_unmake').on('click', function(e){
    //     unmake_table(currentElement['table']);
    //     gui_buttons.frame_element(currentElement);
    //     text_to_feedback_pane('removed table')
    // })
    // document.querySelector('#form_table_make').onclick = document.querySelector('#cm_table_make').onclick  =function(){
    // 	if (!last_pos && !last_map_pos) {
    // 		text_to_feedback_pane('click map first at position where you want to add table, then press button again')
    // 		return false
    // 	}
    //     make_table( to_discrete_position(last_pos||last_map_pos));
    //     render_all(0,false,true);
    // }
    // $('.form_table_make').on('click', function(e){
    //     if (manage_groups.get_current_group().length>0){
    //         if (make_table_from_existing_shapes()) text_to_feedback_pane('Done making table!')
    //     }else{
    //         text_to_feedback_pane('no group active. Select rectangles to add to table')
    //     }
    // })
    // $('.cm_table_add_row').on('click', function(e){
    //     var table_id = currentElement.table;
    //     var m = get_table_dims().rm
    //     var arr = add_rc_to_table(table_id,  (x,y,w,h)=>[x, y+h+m],
    //          (rn,cn,i)=>[rn-1,i], (rn,cn,i)=>[rn,i], 0)
    //     tables[table_id].push(arr)
    //     render_all(0,false,true);
    // });
    // $('.cm_table_add_col').on('click', function(e){
    //     var table_id = currentElement.table;
    //     var m = get_table_dims().cm
    //     var arr = add_rc_to_table(table_id, (x,y,w,h)=>[x+w+m, y],
    //          (rn,cn,i)=>[i, cn-1], (rn,cn,i)=>[i, cn], 1);
    //     var table = tables[table_id];
    //     table.forEach((c,i)=>c.push(arr[i]));
    //     render_all(0,false,true);
    // });
    // $('.cm_table_remove_row').on('click', function(e){
    //     var [r,c, table_id] = get_r_c_id_from_cell(currentElement);
    //     var els = get_table_row(currentElement);
    //     els.forEach(el=>el.remove());
    //     tables[table_id].forEach((v,i)=>{
    //         if (i> r){
    //             v.forEach((cell,j)=> {
    //                 cell.vt = (i-1) + '_' + j;
    //             })
    //         }
    //     })
    //     tables[table_id].splice(r, 1);
    //     render_all(0,false,true);
    // });
    // $('.cm_table_remove_col').on('click', function(e    ){
    //     var [r,c, table_id] = get_r_c_id_from_cell(currentElement);
    //     var els = get_table_col(currentElement);
    //     els.forEach(el=>el.remove());
    //     tables[table_id].forEach((r,i)=>{
    //         r.forEach((cell,j)=> {
    //             if (j> c){
    //                 cell.vt = i + '_' + (j-1);
    //             }
    //         })
    //     })
    //     tables[table_id].forEach(r=> r.splice(c,1));
    //     render_all(0,false,true);
    // });
    // $('.cm_table_style_copy_col').on('click', function(e ){
    //     var [r,c, table_id] = get_r_c_id_from_cell(currentElement);
    //     var els = get_table_col(currentElement);
    //     copied_styles=false;
    //     copied_styles_for_table ={'col': els.map(el=>get_styles_for_copy(el))};
    //     render_all(0,false,true);
    // });
    // $('.cm_table_style_copy_row').on('click', function(e ){
    //     var [r,c, table_id] = get_r_c_id_from_cell(currentElement);
    //     var els = get_table_row(currentElement);
    //     copied_styles=false;
    //     copied_styles_for_table ={'row': els.map(el=>get_styles_for_copy(el))};
    //     render_all(0,false,true);
    // });
    // $('.cm_table_select_row').on('click', function(e){
    //    add_rc_to_group(get_table_row);
    // });
    // $('.cm_table_select_col').on('click', function(e){
    //    add_rc_to_group(get_table_col);
    // });
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    shuffle_shapes = (function () {
        function a(a) {
            ((d = b(a)), (e = []));
            var c = get_bbox_of_group(d),
                f = _slicedToArray(c, 4),
                g = f[0],
                h = f[1],
                i = f[2],
                j = f[3];
            return (e.push({ x: g, y: i, w: h - g, h: j - i }), [g, h, i, j]);
        }
        function b(a) {
            var c = {};
            return (
                a.forEach(function (a) {
                    var b = posit2.get_w_h(a),
                        d = _slicedToArray(b, 2),
                        e = d[0],
                        f = d[1];
                    c[a.id] = e * f;
                }),
                a.sort(function (d, a) {
                    return c[a.id] - c[d.id];
                })
            );
        }
        function c(c, a) {
            return Math.floor(Math.random() * (a - c)) + c;
        }
        var d = [],
            e = [];
        return {
            // place_shapes: function(shapes_to_place){
            //     init(shapes_to_place);
            //     shapes.forEach(shape=>{
            //         var [w,h] = posit2.get_w_h(shape);
            //         var bounding_rect = get_empty_rect(w, h);
            //         if (!bounding_rect){
            //             console.log('failed repos for all....')
            //             return false;
            //         }
            //         var [x,y] = place_shape(shape, w, h, bounding_rect);
            //         add_new_empty_rects(bounding_rect, x, y, w, h);
            //     });
            // },
            place_shapes: function c(b) {
                var d = 25,
                    e = a(b),
                    f = _slicedToArray(e, 4);
                ((minX = f[0]), (maxX = f[1]), (minY = f[2]), (maxY = f[3]));
                var g = get_placer_fill_area(
                    minX,
                    minY,
                    maxX - minX,
                    maxY - minY,
                );
                b = _.shuffle(b);
                b.forEach(function (a) {
                    g.position_shape(a);
                });
            },
        };
    })();
    function get_placer_fill_area(a, b, c, d) {
        function e(c) {
            var d,
                e,
                g = posit2.get_w_h(c),
                o = _slicedToArray(g, 2),
                p = o[0],
                q = o[1],
                h = k + p < i + 25,
                r = l + q < j + 25; //console.log(last_x + w  , end_x + marge)
            (h && f
                ? ((d = k + 25),
                  (e = l),
                  (k = d + p),
                  (m = Math.max(m, k)),
                  (n = Math.max(n, l + q)))
                : r && !f
                  ? ((d = k),
                    (e = l + 25),
                    (l = e + q),
                    (m = Math.max(m, k + p)),
                    (n = Math.max(n, l)))
                  : !h && f
                    ? ((d = a),
                      (e = n + 25),
                      (k = d + p),
                      (l = e),
                      (m = Math.max(m, k)),
                      (n = Math.max(n, l)))
                    : !r &&
                      !f &&
                      ((d = m + 25),
                      (e = b),
                      (k = d),
                      (l = e + q),
                      (m = Math.max(m, k)),
                      (n = Math.max(n, l))),
                ido(c).reposition_me(c, d + 25, e + 25));
        }
        var f =
                !(4 < arguments.length && arguments[4] !== void 0) ||
                arguments[4],
            g = 25,
            h = 15,
            i = a + c,
            j = b + d; //vult gebied gevormd door argumenten functie. Moet vantevoren bekend zijn dat gebied groot genoeg is
        //niet gegarandeerd dat precies past als vormen verschillende groottes
        //of als delta tussen vormen anders
        ((a -= g), (b -= g)); //gebruikt om nieuwe positie in huidige rij / kolom
        var k = a,
            l = b,
            m = a,
            n = b; //absolute max gebruikte x en y in area
        return { position_shape: e };
    }
    function get_placer_to_table(a) {
        function b(a) {
            ((pos = a.map(function (a) {
                return posit2.tlbr(a);
            })),
                (ids = a.map(function (a) {
                    return a.id;
                })));
            var b = [];
            return (
                ids.forEach(function (a, c) {
                    ((pos[c].id = a), b.push(pos[c]));
                }),
                b
            );
        }
        function c(a) {
            var b =
                    1 < arguments.length && arguments[1] !== void 0
                        ? arguments[1]
                        : "bottom",
                c =
                    2 < arguments.length && arguments[2] !== void 0
                        ? arguments[2]
                        : "top",
                d = 3 < arguments.length ? arguments[3] : void 0,
                e = a[s][b];
            ibefore = s;
            do s += 1;
            while (s < t && d(a[s][c], e));
            return a.slice(ibefore, s);
        }
        function d(b, d, e, f, g) {
            s = 0;
            var h = [],
                i = _.sortBy(b, function (a) {
                    return a[e];
                });
            for (f && i.reverse(); s < a.length; ) h.push(c(i, d, e, g));
            return h;
        }
        function e(a, b) {
            for (var c = 0; c < b.length; c++) if (b[c].includes(a)) return c;
            return !1;
        }
        function f(a, b, c, e) {
            return (
                a.forEach(function (a) {
                    var f = b - a[c];
                    a[e] += f;
                }),
                Math.max.apply(
                    null,
                    a.map(function (a) {
                        return a[e];
                    }),
                )
            );
        }
        function g(a, b, c, e, h, j) {
            (0 == c &&
                (j = Math.min.apply(
                    null,
                    b[0].map(function (a) {
                        return a[e];
                    }),
                )),
                a.push(j),
                (new_max = f(b[c], j, e, h)),
                (c += 1),
                c < b.length && g(a, b, c, e, h, new_max));
        }
        function h(b, c) {
            var d = {};
            return (
                a.forEach(function (a) {
                    return (d[a.id] = [e(a.id, b), e(a.id, c)]);
                }),
                d
            );
        }
        function j(a) {
            var b = {};
            return (
                Object.values(a).forEach(function (a) {
                    a in b ? (b[a] += 1) : (b[a] = 1);
                }),
                b
            );
        }
        function k(a) {
            return Object.values(a).reduce(function (c, a) {
                return c + (1 == a ? 0 : a);
            }, 0);
        }
        function l(b) {
            var d = _slicedToArray(b, 4),
                f = d[0],
                h = d[1],
                c = d[2],
                i = d[3],
                j = [],
                k = [];
            (g(j, f, 0, "top", "bottom"), g(k, h, 0, "left", "right"));
            var l,
                m,
                n,
                o,
                p = {};
            a.forEach(function (a) {
                ((l = e(a.id, c)),
                    (m = e(a.id, i)),
                    (n = j[l] + l * r),
                    (o = k[m] + m * q),
                    (a.fixed_size = !0),
                    repos_shape(a, o - a.x, n - a.y));
            });
        }
        function m() {
            var e,
                f,
                g,
                i,
                l = b(a),
                m = d(l, "bottom", "top", !1, function (c, a) {
                    return c < a;
                }),
                n = d(l, "top", "bottom", !0, function (c, a) {
                    return c > a;
                }),
                o = d(l, "right", "left", !1, function (c, a) {
                    return c < a;
                }),
                p = d(l, "left", "right", !0, function (c, a) {
                    return c > a;
                }),
                q = m.map(function (a) {
                    return a.map(function (a) {
                        return a.id;
                    });
                }),
                s = o.map(function (a) {
                    return a.map(function (a) {
                        return a.id;
                    });
                }),
                t = n.map(function (a) {
                    return a.map(function (a) {
                        return a.id;
                    });
                }),
                u = p.map(function (a) {
                    return a.map(function (a) {
                        return a.id;
                    });
                }),
                v = h(q, s),
                w = h(t, u),
                x = h(q, u),
                y = h(t, s),
                z = [v, w, x, y].map(function (a) {
                    return j(a);
                }),
                A = z.map(function (a) {
                    return k(a);
                }),
                B = ["ab", "cd", "ad", "cb"],
                C = Math.min.apply(null, A),
                B = B[A.indexOf(C)];
            return (
                "cd" == B
                    ? ((e = n.reverse()),
                      (f = p.reverse()),
                      (g = t.reverse()),
                      (i = u.reverse()))
                    : "ad" == B
                      ? ((e = m), (f = p.reverse()), (g = q), (i = u.reverse()))
                      : "cb" == B
                        ? ((e = n.reverse()),
                          (f = o),
                          (g = t.reverse()),
                          (i = s))
                        : "ab" == B && ((e = m), (f = o), (g = q), (i = s)),
                [[e, f, g, i], C]
            );
        }
        function o(b, c) {
            var e = {};
            return (
                a.forEach(function (a) {
                    return (e[a.id] = [0, 0]);
                }),
                b.forEach(function (a, b) {
                    return a.forEach(function (a) {
                        return (e[a][0] = b);
                    });
                }),
                c.forEach(function (a, b) {
                    return a.forEach(function (a) {
                        return (e[a][1] = b);
                    });
                }),
                e
            );
        }
        function p(a) {
            var b = Object.values(a).map(function (a) {
                return a.toString();
            });
            return (
                (pos_to_ids = {}),
                Object.keys(a).forEach(function (b) {
                    var c = a[b].toString();
                    (c in pos_to_ids || (pos_to_ids[c] = []),
                        pos_to_ids[c].push(b));
                }),
                pos_to_ids
            );
        }
        var q =
                1 < arguments.length && arguments[1] !== void 0
                    ? arguments[1]
                    : 5,
            r =
                2 < arguments.length && arguments[2] !== void 0
                    ? arguments[2]
                    : 5,
            s = 0;
        a = a.filter(function (a) {
            return "path_group" != a.iama;
        });
        var t = a.length;
        return {
            place: function a() {
                var b = m();
                (l(b[0]),
                    0 != b[1] &&
                        text_to_feedback_pane("some shapes overlaying"));
            },
            make_table: function b() {
                var d =
                        !!(0 < arguments.length && void 0 !== arguments[0]) &&
                        arguments[0],
                    f = m(),
                    g = _slicedToArray(f, 2),
                    h = _slicedToArray(g[0], 4),
                    i = h[0],
                    j = h[1],
                    c = h[2],
                    k = h[3],
                    n = g[1];
                if (0 != n) {
                    text_to_feedback_pane([
                        "failed. Positions overlapping. cannot make table",
                        "Some cells will be overlapping after making a table",
                        "move shapes that overlap and try again",
                        "or use align > table first to make a layout to actually                    see overlapping shapes",
                    ]); //TODO: werkt niet
                    var q = p(o(c, k));
                    return (
                        Object.keys(q).forEach(function (a) {
                            if (1 < q[a].length) {
                                var b = q[a].map(function (a) {
                                    return document.getElementById(a);
                                });
                                add_rect_around_group(b);
                            }
                        }),
                        !1
                    );
                }
                l([i, j, c, k]);
                var r = i.length,
                    s = j.length,
                    t = _.range(r).map(function (a) {
                        return Array(s).fill(0);
                    });
                return (
                    d || (d = get_id_for_table()),
                    a.forEach(function (a) {
                        ((rn = e(a.id, c)),
                            (cn = e(a.id, k)),
                            (t[rn][cn] = a),
                            (a.is_cell = !0),
                            (a.vt = rn + "_" + cn),
                            (a.table = d));
                    }),
                    (t = t.map(function (a, b) {
                        return a.map(function (a, e) {
                            return a ? a : make_table_dummy_node(b, e, d);
                        });
                    })),
                    (tables[d] = t),
                    !0
                );
            },
        };
    }
    function init_study_one_by_one(a) {
        function b() {
            a.forEach(function (a) {
                x[a.id] = [3, 0, 0];
            });
        }
        function c(a) {
            var b =
                !(1 < arguments.length && arguments[1] !== void 0) ||
                arguments[1];
            ((x[a][0] = b
                ? Math.max(x[a][0] - 1, 0)
                : Math.min(x[a][0] + 1, 5)),
                (x[a][1] = 0),
                Object.keys(x)
                    .filter(function (b) {
                        return b != a;
                    })
                    .forEach(function (a) {
                        x[a][1] += 1;
                    }));
        }
        function d() {
            var a = _.range(0, 6).map(function (a) {
                return [];
            });
            return (
                Object.keys(x).forEach(function (b) {
                    var c = [b, x[b]];
                    a[x[b][0]].push(c);
                }),
                a
            );
        }
        function e(a) {
            for (
                var b = 0, c = 5;
                0 <= c && ((b += a[c].length), !(b > n));
                c--
            );
            return c;
        }
        function f(a, b) {
            for (var c, d = [], e = 1, f = a; f <= 5; f++)
                ((c = []),
                    (c = b[f].map(function (a) {
                        return [a[0], Math.pow(v, a[1][1]) * e];
                    })),
                    (e *= 2),
                    (d = d.concat(c)));
            return d;
        }
        function g() {
            //  var test = norm_scores.map(d=> [document.getElementById(d[0]).querySelector('p').innerText,
            //     round_to(d[1],2), round_to(scores[d[0]][0],2),  round_to(scores[d[0]][1],2) ]  );
            //  text_to_help_pane(test);
            for (
                var a = d(),
                    b = e(a),
                    g = f(b, a),
                    j = h(g),
                    k = Math.random(),
                    l = 0,
                    m = 0;
                m < j.length;
                m++
            )
                if (((l += j[m][1]), l > k)) return j[m][0];
            return !1;
        }
        function h(a) {
            var b = a.reduce(function (c, a) {
                return c + a[1];
            }, 0);
            return a.map(function (a) {
                return [a[0], a[1] / b];
            });
        }
        function j() {
            var a = Object.keys(x);
            return (
                a
                    .map(function (a) {
                        return x[a][0];
                    })
                    .reduce(function (c, a) {
                        return c + a;
                    }) / a.length
            );
        }
        function k(a) {
            return _.shuffle(a);
        }
        function l() {
            document.querySelector("#input_menu").style.display = "block";
        }
        function m() {
            document.querySelector("#input_menu").style.display = "none";
        }
        function o(a) {
            var b = "<p>Correct answer: ";
            return (
                a.forEach(function (a) {
                    ((cl = a.added
                        ? "added"
                        : a.removed
                          ? "removed"
                          : "correct"),
                        a.removed ||
                            (b += "<span class="
                                .concat(cl, ">")
                                .concat(a.value, "</span>")));
                }),
                (b += "</p>"),
                (b += "<p>Your anser:"),
                a.forEach(function (a) {
                    ((cl = a.added
                        ? "added"
                        : a.removed
                          ? "removed"
                          : "correct"),
                        a.added ||
                            (b += "<span class="
                                .concat(cl, ">")
                                .concat(a.value, "</span>")));
                }),
                (b += "</p>"),
                b
            );
        }
        function p(a) {
            //res = start / true / false
            var b = (check = minus = !1);
            ("start" == a && (b = !0),
                !0 === a && (check = !0),
                a || (minus = !0),
                document
                    .querySelector("#flash_card_check_res_icon")
                    .classList.toggle("fa-square-o", b),
                document
                    .querySelector("#flash_card_check_res_icon")
                    .classList.toggle("fa-check-square-o", check),
                document
                    .querySelector("#flash_card_check_res_icon")
                    .classList.toggle("fa-minus-square-o", minus));
        }
        var q =
                !(1 < arguments.length && arguments[1] !== void 0) ||
                arguments[1],
            r =
                !(2 < arguments.length && arguments[2] !== void 0) ||
                arguments[2],
            s = 3,
            t = 5,
            u = 2,
            v = 1.03;
        a = a.filter(function (a) {
            return a.classList.contains("flippable");
        });
        var w = a.length;
        if (2 > a.length)
            return (
                text_to_feedback_pane(
                    "need more cards to study. Could not find any at all or just one...",
                ),
                !1
            );
        var n = Math.max(Math.min(w, 5), parseInt(w / 5)),
            x = {};
        if (q && r) b();
        else var y = k(a);
        var z = -1;
        ((document.querySelector("#form_one_by_one_controls").style.display =
            "flex"),
            q ? l() : m());
        var A =
            toggle_zoom.filters[
                document.querySelector("#form_study_filter").value
            ];
        return {
            next: function a() {
                if (
                    (q &&
                        ((document.querySelector(
                            "#flash_card_val_to_check",
                        ).value = ""),
                        (document.querySelector(
                            "#flash_card_checked_res",
                        ).innerHTML = ""),
                        p("start")),
                    r)
                ) {
                    var b = g();
                    if (b) var c = document.querySelector("#" + b);
                    (toggle_zoom.fade_callback(),
                        toggle_zoom.center_on_shape(
                            c,
                            A,
                            c,
                            !1,
                            !1,
                            !1,
                            0.2 * window.innerHeight,
                        ),
                        set_current_element(c),
                        A[1](currentElement));
                } else
                    ((z += 1),
                        z < w
                            ? (toggle_zoom.fade_callback(),
                              toggle_zoom.center_on_shape(
                                  y[z],
                                  A,
                                  y[z],
                                  !1,
                                  !1,
                                  !1,
                                  0.2 * window.innerHeight,
                              ),
                              set_current_element(y[z]),
                              A[1](currentElement))
                            : (text_to_feedback_pane(
                                  "studied all available flashcards! Restarting",
                              ),
                              this.reset()));
            },
            reset: function b() {
                ((y = k(a)), (z = -1), this.next());
            },
            flip: function a() {
                var b = currentElement; //items[i];
                (ido(b).flip_shape(b),
                    reverse &&
                        setTimeout(function () {
                            ido(b).flip_shape(b);
                        }, reverse));
            },
            get_group: function b() {
                return a;
            },
            check_answer: function a() {
                var b = document.querySelector(
                        "#flash_card_val_to_check",
                    ).value,
                    d =
                        currentElement.querySelector(
                            "article.collapsed",
                        ).textContent;
                ((diff = o(JsDiff.diffChars(b, d))),
                    (document.querySelector(
                        "#flash_card_checked_res",
                    ).innerHTML = diff),
                    this.flip(),
                    p(b == d),
                    r && c(currentElement.id, b == d));
            },
        };
    } // document.querySelector('#flash_card_check').onclick = function(e){
    //     study_one_by_one.check_answer();
    // }
    // document.querySelector('#flash_card_next').onclick = function(e){
    //     study_one_by_one.next();
    // }
    // document.querySelector('#flash_card_val_to_check').onkeydown = function(e){
    //     if (e.keyCode == 13) study_one_by_one.check_answer();
    //     if (e.keyCode == 9) {
    //         study_one_by_one.next();
    //         e.preventDefault();
    //     }
    //     e.stopPropagation();
    // }
    ("use strict");
    var gridlines = (function () {
        // document.querySelector('#form_grid_lines_extra').onclick = function(){
        // 	var dx = parseInt(document.querySelector('#form_grid_lines_dx_extra input').value)
        // 	var dy = parseInt(document.querySelector('#form_grid_lines_dy_extra input').value)
        // 	make_gridlines(dx, dy);
        // }
        function a() {
            var a =
                !(0 < arguments.length && void 0 !== arguments[0]) ||
                arguments[0];
            a && b(d, e);
        }
        function b(a, b) {
            var c = parseInt(-transform.x / transform.k / a) * a,
                d = parseInt(-transform.y / transform.k / b) * b,
                e = canvas_width / transform.k,
                g = canvas_height / transform.k;
            if (
                (grid_context.clearRect(0, 0, canvas_width, canvas_height),
                grid_context.save(),
                grid_context.translate(transform.x, transform.y),
                grid_context.scale(transform.k, transform.k),
                grid_context.beginPath(),
                0 < a)
            )
                for (var h = c; h < c + e; h += a)
                    (grid_context.moveTo(h, d), grid_context.lineTo(h, d + g));
            if (0 < b)
                for (var h = d; h < d + g; h += b)
                    (grid_context.moveTo(c, h), grid_context.lineTo(c + e, h));
            (grid_context.closePath(),
                (grid_context.strokeStyle = "black"),
                (grid_context.lineWidth = f),
                grid_context.stroke(),
                grid_context.restore(),
                cc.set_has_ink(grid_context));
        }
        var c = !1,
            d = 25,
            e = 25,
            f = 1 / 4;
        return (
            plus_minus_generator(
                document.getElementById("form_grid_lines_width"),
                function (a) {
                    var b = Math.max(0, a.value / 20);
                    ((a.value = 20 * b), (f = b));
                },
                1,
                0,
            ),
            plus_minus_generator(
                document.getElementById("form_grid_lines_dx"),
                function (a) {
                    a.value = Math.max(0, a.value);
                },
            ),
            plus_minus_generator(
                document.getElementById("form_grid_lines_dy"),
                function (a) {
                    a.value = Math.max(0, a.value);
                },
            ),
            (document.querySelector("#form_toggle_grid_lines").onclick =
                function () {
                    if (is_toggle_button_on(this))
                        (cc.clear_canvas(grid_context), (c = !1));
                    else {
                        //grid_canvas.node().style.display ='inherit'
                        var b = parseInt(
                                document.querySelector(
                                    "#form_grid_lines_dx input",
                                ).value,
                            ),
                            f = parseInt(
                                document.querySelector(
                                    "#form_grid_lines_dy input",
                                ).value,
                            );
                        if (!b && !f)
                            return (
                                text_to_feedback_pane(
                                    "you have to set delta x or delta y to a value bigger then zero",
                                    !0,
                                ),
                                !1
                            );
                        ((d = b), (e = f), a(), (c = !0));
                    }
                    toggle_button(this);
                }),
            {
                make: a,
                on: function a() {
                    return c;
                },
            }
        );
    })();
    ("use strict");
    var _help_mapper;
    function _typeof(a) {
        "@babel/helpers - typeof";
        return (
            (_typeof =
                "function" == typeof Symbol &&
                "symbol" == typeof Symbol.iterator
                    ? function (a) {
                          return typeof a;
                      }
                    : function (a) {
                          return a &&
                              "function" == typeof Symbol &&
                              a.constructor === Symbol &&
                              a !== Symbol.prototype
                              ? "symbol"
                              : typeof a;
                      }),
            _typeof(a)
        );
    }
    function _defineProperty(a, b, c) {
        return (
            (b = _toPropertyKey(b)) in a
                ? Object.defineProperty(a, b, {
                      value: c,
                      enumerable: !0,
                      configurable: !0,
                      writable: !0,
                  })
                : (a[b] = c),
            a
        );
    }
    function _toPropertyKey(a) {
        var b = _toPrimitive(a, "string");
        return "symbol" == _typeof(b) ? b : b + "";
    }
    function _toPrimitive(a, b) {
        if ("object" != _typeof(a) || !a) return a;
        var c = a[Symbol.toPrimitive];
        if (void 0 !== c) {
            var d = c.call(a, b || "default");
            if ("object" != _typeof(d)) return d;
            throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === b ? String : Number)(a);
    }
    var formulaText =
            "the formula must have the variable x, and can contain any of the following operators: \n\t+ - / *  sin, cos, tan, ceil, floor, log, sqrt, abs (use as sin(x) or sin(2) )\n\t, 'pow, min and max  are special, because they takes two arguments: x^2 => pow(x,2)",
        axis_help = [
            "About axis",
            "You can color the axis using the color menu",
            "Or use the border menu to make the axis thicker or thinner",
            "In the font menu, you can choose a font and size for text",
            "In the graph menu, you can change the ticks, and the ranges",
            "By using the arrow keys \tyou can position the axis",
        ],
        help_mapper =
            ((_help_mapper = {
                //sign in/out
                "sign in/out": [
                    "Sign in with your github account to save and load and edit maps from and to your github profile",
                ], //options
                // 'hide menu':
                // 	['Hide the menu', 'To show again, press button on the left of the screen',
                // 	'Quick key: F10'   ],
                //  'hide help':
                // 	['Hide the help menu', 'To show again, press show menu on the right of the screen',
                // 	'Quick key: shift F10'   ],
                "toggle view mode": [
                    "Enter view mode if you want to just view the map",
                    "You will not be able to alter or add any shapes or text",
                    "It is meant to make it easier to read, and zoom and pan the map",
                ],
                "to slides": [
                    "takes you to the slide menu where you can make presentations from your notes",
                    "Quick key: F9",
                ],
                "to tutorial": [
                    "opens a new map with the basics of breakdown Notes explained",
                ],
                "hot keys": [
                    " opens a new map where all the hot keys / keyboard shortcuts are explained",
                ],
                "study mode": [
                    "when there are flashcards on the map, switching to study mode will make it\t\t easier to flip a flashcard. Also some of the gui-elements are hidden, so you focus\t\t on stuying.",
                    "In the one-by-one mode, you can choose to show only one card at a time.",
                    "Just click the start button to activate it",
                    "Click the card to flip it, and the map to show the next one",
                    'If the "check" box is on, you can type\t\t in an answer and have Breakdown Notes check it',
                ],
                "Study mode": [
                    "when there are flashcards on the map, switching to study mode will make it\t\t easier to flip a flashcard. Also some of the gui-elements are hidden, so you focus\t\t on stuying.",
                    "You also have an option to type in an answer and have Breakdown Notes check it",
                ], //Export
                Export: ["Go here to export as png"],
                "add region": ["to start exporting, first press this button"],
                "keep standard ratio": [
                    "uncheck this box to set your own export region. Check it to have the export region set to the standard paper size (A4)",
                ],
                "No background": [
                    "If checked, when exporting, the background (the canvas) will be left blank, and only the shapes, texts and paths \t\tetc will be printed",
                    "If you uncheck, the background for the image will be set to the background color of the canvas",
                ],
                "Choose print size": [
                    "Choose the format to print the image to. This will be the ouput size of the image",
                ],
                scale: [
                    "With scale, you can increase or decrease the output size of the image that will be exported",
                    "See the output format below \t\tfor an estimation of the output size",
                ], //Shapes
                Shapes: [
                    "Choose a shape to add to the canvas. Choose by clicking it, and then double click the canvas to add it",
                ], //Colors
                Colors: [
                    "Lets you choose a quick style for a figure.",
                    "Click an element on the canvas, then on a predefined style.",
                    "You can also choose a custom color using the color picker. There you can also choose a color for \t\tthe border of an element",
                    "You can change any of the predefined styles by right clicking it. A menu will pop up from where you can change the style",
                    "This will change all the shapes with this particular style.",
                ],
                "Custom color": [
                    "Set your own color, for the fill, the border or the text of shapes",
                ],
                fill: ["color the interior of an object"],
                text: ["color the text of a paragraph"],
                stroke: [
                    "color the stroke, or border of an object",
                    "only works if the border is bigger\t\tthen 0: see border controls menu to change",
                ], //Sketch
                Sketch: [
                    "use this to make a shape look like it has been drawn by hand",
                ], //Import
                Import: [
                    "Settings to control what happens when importing (copy paste or drag and drop) text or html",
                ],
                "new shape when": [
                    "Enter one or more characters to split on, for instance . (a point)",
                    "For every time this character (or these characters) are encountered in the imported text, a new shape will be added",
                    "Can be empty",
                    "use ",
                ],
                "new paragraph when": [
                    "Enter one or more characters to split on, for instance . (a point)",
                    "For every time this character (or these characters) are encountered in the imported text, a new paragraph will be added",
                    "Can be empty",
                ], //fonts
                //font input??
                Font: [
                    "Choose a font",
                    "Can choose a font for figure or paragraph",
                    "Fonts in a paragraph will overrule the figure-font, so multiple fonts per figure possible",
                    "Multiple fonts per paragraph are impossible",
                ],
                "Font size": [
                    "Predefined font sizes (from extra large to extra small",
                    "You can choose a size for a shape or paragraph",
                    "Paragraph will overrule shape font, so multiple sizes for one shape are possible",
                    "Multiple fonts sizes in one paragraph is not possible",
                ], //twee keer zelfde hulp, andere titel in contextmenu dan in vaste menu.
                "font size": [
                    "Predefined font sizes (from extra large to extra small",
                    "You can choose a size for a shape or paragraph",
                    "Paragraph will overrule shape font, so multiple sizes for one shape are possible",
                    "Multiple fonts sizes in one paragraph is not possible",
                ],
                Quick: [
                    "Predefined font sizes (from extra large to very small",
                    "Can choose a size for figure or paragraph",
                    "Paragraph will overrule figure-font, so multiple sizes per figure possible",
                    "Multiple fonts sizes per paragraph impossible",
                    "Does not work for or icon figure",
                ],
                Specific: [
                    "Choose a specific font size",
                    "For paragraph and figure",
                    "Paragraph font size will \t\toverrule figure font size",
                ],
                "max width": [
                    "controls how wide a shape will get before it ads a line break",
                ], //Figure controls
                flip: [
                    "Press to add a backside to an element. After that you can add text to the backside and the frontside of a shape",
                    "You can flip an element using the flip-button just below a shape.",
                    'This button is only visible when an element is "flippable"',
                ],
                paths: [
                    "Updates paths on selected figure",
                    "When multiple paths are attached \t\tto the same side, will recalculate which path goes where, or put all paths on a side on the same position",
                ],
                "toggle sticky": [
                    "if on, elements positioned on / within the boundaries of the sticky figure, will be \t\t\tmoved simultaneous with the sticky when repositioned",
                ],
                top: [
                    "moves the active shape on top of other elements on top of it",
                ],
                bottom: ["moves elements below the active shape on top of it"],
                "copy with text": [
                    "When on, will copy shapes with all paragraphs text and styling",
                    "When off, will only\t\tcopy shape",
                ],
                shape: [
                    "First select the shape you want copied, then press the shape copy button, and finally press\t\tthe position on the canvas where you want the copied shape placed",
                    "quick key: control C",
                ],
                style: [
                    "First select the shape with the style you want copied, then press the style copy button, and finally \t\tclick the shape / paragraph or path you want the style copied onto",
                ],
                "even out paragraphs": [
                    "Set the margin between the paragraphs so that all the paragraphs are evenly\t\tdistributed over the shape",
                ],
                "inside padding": [
                    "controls the distance between the border of a shape and the paragraphs inside it",
                ], //
                //background Controls
                resize: [
                    "if checked, when you change anything font related (size, family etc), the shape will automatically \t\t be resized so the text will fit inside it",
                ],
                "height only": [
                    "if resize is checked, will only make the shape bigger or smaller in height. The width of the shape \t\t wil stay the same",
                ],
                Sizing: [
                    "With sizing you control whether the displayed part image is larger then the shape is, or smaller",
                    "Choosing contain will fit the whole image inside the shape. This might leave part of the shape uncovered",
                    "When choosing cover, the whole image will cover the shape, but part of the image might be invisible",
                ],
                "Fit image": [
                    "With fit image, the image and the shape its in will be sized equally: this means the shape will be totaly covered\t\t and the image precisely contained in the shape",
                    "By clicking larger, the shape will be increased in size etc.",
                ], //paragraph controls
                "Text-align": [
                    "to align text in a figure",
                    "Works on figure and paragraphs in figure",
                    "Paragraph overrules figure alignment",
                    "Not for text or icon",
                ],
                Margin: [
                    "Set the distance of the border of the paragraph to other paragraphs and the figure \t\tit is contained in",
                ],
                Padding: [
                    "Sets the distance of the text in a paragraph to the border of the paragraph \t\tit is contained in",
                ],
                "to flip side": [
                    "Moves the current paragraph to the flip side of this shape",
                    "Afterwards, you can flip a shape with the triangle to the right of the shape\t  which will appear once you select the shape",
                ],
                "set to shape width": [
                    "When you click the button, the current paragraph will take on the whole width of the shape it is in",
                    "You will only notice an effect, if the paragraph fill is different from the fill of the shape.",
                ], //Zoom and positioning
                "Show plumb lines on move": [
                    "when off, the red plumb lines will not be shown while moving a shape by dragging",
                    "On slower computers, this will increase the frame rate",
                    "When using arrow keys to move a shape, the plumbs will always be shown",
                ],
                "Toggle glow": [
                    "when off, the greenish glow will no longer appear while hovering some shapes",
                    "on slower computers, this will increate the frame rate",
                ],
                "Zoom and pan": [
                    "when on (green) allows to zoom with scroll mouse button and pan with mouse",
                ],
                "Auto resize on input": [
                    "If on, the shape you are typing text in will automatically resize so that the text will fit neatly\t\tinside the shape.",
                ], // 'zoom to group':
                // 	['when on zooms to the selected figure on the canvas'],
                "Fine position move": [
                    "When on, moves the figure while pressing arrow key \t\tone pixel, when off, moves multiple pixels",
                    "When dragging with the mouse, you can also hold the alt key to only change 1 px",
                ],
                "Fine position resize": [
                    "When on, resizes the figure while holding control and pressing arrow key \t\tone pixel, when off, resizes multiple pixels",
                    "When dragging with the mouse, you can also hold the alt key to only change 1 px",
                ],
                "Catcher width": [
                    "Set the width of the catcher. The catcher is the greenish border that appears around\t\tmost shapes and lets you drag, select and touch a shape more easily",
                ],
                "Grid delta": [
                    "set the minimum interval you want to drag before an elements moves or resizes",
                    "An element when added to the canvas will always be in interval steps",
                    "the width/height not always",
                ],
                "Snap to Grid": [
                    "will snap an element to the grid (after you have changed the grid interval)",
                    "Button for position and size (width and hight together)",
                    "If button is transparant\t\tposition and/or size already on interval",
                ],
                "Show lines": ["when on, shows gridlines"],
                "Delta x": [
                    "adjust the distance between the gridlines",
                    "Turn gridlines off and on again\t\tfor change to take effect",
                ],
                "Delta y": [
                    "adjust the distance between the gridlines",
                    "Turn gridlines off and on again\t\tfor change to take effect",
                ], //Drawing
                "draw mode": [
                    "By entering the drawing mode, you can use the canvas as a basic sketch book. You will be able to draw\t\t lines by dragging the mouse, or using a pen for your touchscreen (when available)",
                    "Enter the drawing mode by toggling the draw mode button, or by holding shift and then press control",
                    "Exxit the draw mode, by toggling the draw button, or by pressing escape",
                ],
                "pencil size": [
                    "choose a size for your pencil.",
                    "To change the size of another drawing, click the drawing and use \t\t the border controls menu",
                ],
                "Recognize paths": [
                    "When on, if you start drawing a line from a shape and end your line on another shape \t\t, it will be made into a path between these shapes",
                ],
                "Recognize shapes": [
                    "When on, if you end drawing a line in the same position as where you started, it will \t\tbe made into a shape to which you can add text and which you can move and resize",
                ], //Levels
                Levels: [
                    "With levels you can add structure to your notes and diagrams: the size is decided by the zoom level",
                    "If you are zoomed in, the shapes you add will be small, if you are zoomed out, the shapes will be big.",
                ],
                "Use levels": [
                    "If on, then shapes and the text inside will be scaled dependent on the current zoom level of the map",
                    "If off, all shapes will have the same size",
                ],
                "Set level": [
                    "Use this button to assign a shape to a level",
                    "Paths will be assigned based of the levels of the \t\tshapes the path is connecting",
                ], //Border Controls
                Width: [
                    "sets the width of the border of the selected figure",
                    "for paragraphs, and figures, sets \t\t\tthe width of the border, for textfigures and icons: sets the width of the outline \t\t\tfor paths: set the width of the path",
                    "paragraph borders are not coloured by default so you must choose a color also",
                ],
                Radius: [
                    "only for rectangles",
                    "sets how round the corners are",
                ],
                "Dots 'n dashes": [
                    "lets you style the border, path or text/icon-figures by setting gaps in the stroke / border",
                    "first value = dash, second value = gap, third value = dash etc",
                    "for instance giving value 5 will show dashes of 5 px, 5 1  will show dash of 5px, gap of 1px",
                ], //Path Controls
                From: [
                    "choose on which side the path starts",
                    "will persist after choice, also when \t\tconflicting with other figure",
                    "use reset to undo",
                ],
                To: [
                    "choose on which side the path ends",
                    "will persist after choice, also when \t\tconflicting with other figure",
                    "use reset to undo",
                ],
                reset: [
                    "resets path choices, for chosen direction and also for manually adjusted \t\tcontrol points",
                ],
                Flow: ["set the flow of the selected path"],
                Style: ["set the style of the selected path"],
                "Add arrow": ["add an arrow on any or both sides of the path"],
                "Show control points": [
                    "By dragging the control points, you can change the flow of the path",
                    "After dragging a control point, the path will keep the flow. Press reset to change back.",
                ],
                "Add control point": [
                    "By adding more control points to a line, you can make the path flow in more complex ways",
                ],
                "Set free": [
                    'By setting the control points "free" you can move the points one by one.',
                    "Normally some of the control points move together so that the flow of the path stays smooth",
                    "This is only relevant for path to which you have added control points.",
                ], //Path Labelling
                "As text-path": [
                    "switch from text block to text path",
                    "text block is text in a rectangle, text path is text along the path",
                ],
                "To top": [
                    "Copy text path or text block to the top of all other figures",
                    "Usefull when multiple path intersect and the one with a text label is not on top",
                ], //Group Elements
                "Group Shapes": [
                    "With groupings you can select multiple elements at the same time, so you can \t\tmove them together, or change the style together",
                ],
                "Paste current group": [
                    "Will copy all the elements in the active group centered around the last \t\tclicked position on the canvas",
                ],
                Subset: [
                    "To help with selecting shapes or paragraph that have a particular feature (like color, stroke width)",
                    "First select a shape that has the feature you want to group on, then press the button describing the feature",
                ],
                "Resize all in group": [
                    "Press any of the buttons to change the width and/or height of the shapes in the group, to the width\t and /or height of the current active shape.",
                ],
                "disperse group": [
                    "you can use the buttons to increase or decrease the space between the shapes in the active group, either \tvertically (vert) or horizontally(hor)",
                ], //Merge Elements
                "Merge Shapes": [
                    "lets you group two or more elements into one",
                ],
                "Merge all covered elements": [
                    "will merge / group elements together. children need to be inside parent, then select \t\tparent and click button",
                    "Moving parent will now also move children. Children are still moveable",
                ],
                "Merge by dragging": [
                    "will merge / group elements together. children need to be inside parent, then select \t\tparent and click button",
                    "Moving parent will now also move children. Children are still moveable",
                ],
                "Undo Merge": [
                    "will ungroup an previously merged/grouped element.",
                ], //Align Elements
                "Align Shapes": [
                    "lets you position elements on the same position hor / vert, or the same size width /height",
                    "works on grouped elements, or on hierarchical elements (without need for grouping",
                ],
                Line: [
                    "Place shapes in one line (the same column or row). Or give shapes the same size",
                ],
                Table: ["Align shapes in a table (multiple rows and columns)"],
                Align: [
                    "Align all the element in the active group (permanent, temporary or hierarchical",
                    "You can align vertically, horizontally, or both",
                    "When aligning horizantally \t\tfor figures next to each other, they will get the same distance from each other",
                    "The distance is the distance between the selected figure (if in the group) and the next figure \t\tint the group",
                ],
                Resize: [
                    "Similar to alignment, only will change the size of the figures in the group \t\t(width, height or both) based of the selected figure (if in the group)",
                ], //Hierarchy
                Hierarchy: [
                    "With hierarchies, you can connect elements as children.",
                    "Advantage is that these elements are easier aligned and that part of the connections will partly overlap",
                    "Click Add child button once to add a knot, then click to add children",
                    "You can add existing elements to a\t\thierarchy by clicking the knot and drag the connect button onto the shape you want to add to the hierarchy",
                ],
                "Add child": [
                    "Add a child element on a particular side of the selected figure",
                ],
                Orientation: [
                    "Change the orientation of the selected figure from horizontal to vertical \t\tand vice versa.",
                    "The active shape needs to be a child element for it to work.",
                ],
                Mirror: [
                    "Put the selected child figure on the other side of the shared path of the \t\t   path",
                ],
            }),
            _defineProperty(
                _defineProperty(
                    _defineProperty(
                        _defineProperty(
                            _defineProperty(
                                _defineProperty(
                                    _defineProperty(
                                        _defineProperty(
                                            _defineProperty(
                                                _defineProperty(
                                                    _help_mapper,
                                                    "Margin",
                                                    [
                                                        "Set the distance between the child elements for the selected group",
                                                    ],
                                                ),
                                                "Mark element as child",
                                                [
                                                    " Will add a non-child figure that has a connection to a figure that already has \t\ta child group, to this child group",
                                                    "If there are multiple child groups on the parent element, will add to the child group on the \t\tsame side as the figure thats is going to be marked as child. Random otherwise",
                                                ],
                                            ),
                                            "Select child group",
                                            [
                                                "group all the element for simultaneous moving / styling",
                                            ],
                                        ),
                                        "update slides",
                                        [
                                            "Update all the slide previews.",
                                            "Handy when you have moved about shapes of slides on the canvas a lot",
                                        ],
                                    ),
                                    "Choose filter",
                                    [
                                        "With the filter you control what happens with the content that is not on a slide when, zooming into a slide.",
                                        "Choosing none will still show these elements, Fade will fade these elements, and hide will hide elements not on the slide",
                                    ],
                                ),
                                "Hide shapes",
                                [
                                    "You can hide shapes that are inside the slider on the slide",
                                    "First either make or show a slider on the map.",
                                    "Then group the shapes you want to hide (control right click the shapes",
                                    "Then click the slider and click this button",
                                ],
                            ),
                            "Update settings",
                            [
                                "Controls what happens when a shape that is moved outside of the slide it is on",
                            ],
                        ),
                        "always update",
                        [
                            "When the shape is moved outside of the slides current area, the area is increased to include the moved shape",
                        ],
                    ),
                    "always remove",
                    [
                        "When the shape is moved outside of the slides current area, the shape will be removed from the slide",
                    ],
                ),
                "ask",
                [
                    "When the shape is moved outside of the slides current area, you are asked wether you want to update the slide, or remove the shape \t\tfrom the slide",
                ],
            ),
            _defineProperty(
                _defineProperty(
                    _defineProperty(
                        _defineProperty(
                            _defineProperty(
                                _defineProperty(
                                    _defineProperty(
                                        _defineProperty(
                                            _defineProperty(
                                                _defineProperty(
                                                    _help_mapper,
                                                    "copy style",
                                                    [
                                                        "Will copy the styles of a paragraph or shape.",
                                                        "After clicking this button,\t\t   click the shape you want to style.",
                                                        "Styles includes colors, font size and family, alignment\t\t   but not underlining, bolds and italics.",
                                                    ],
                                                ),
                                                "done",
                                                [
                                                    'Pressing this button will also use "linebreaks / enters /new-lines" to the text',
                                                    "You can also just click the canvas, but then it will be without line breaks",
                                                ],
                                            ),
                                            "To line",
                                            [
                                                "Make this line out of straight segments in stead of curvy segments",
                                            ],
                                        ),
                                        "Push",
                                        [
                                            "pushes the current selected shapes into a group",
                                            "This enables you to reactive the\t\t group by holding shift and clicking one of the shapes in the group",
                                        ],
                                    ),
                                    "Deactivate",
                                    [
                                        "Use this to deactivate the current group",
                                    ],
                                ),
                                "Paste",
                                [
                                    "copy and paste the current group to the last clicked position",
                                ],
                            ),
                            "Fuse",
                            [
                                "Will add the paragraphs in all the shapes in the current group into one shape",
                                "will delete the remaining empty shapes",
                            ],
                        ),
                        "Add subcanvas",
                        [
                            "Will place the shapes in the current group onto a subcanvas",
                        ],
                    ),
                    "shuffle",
                    [
                        "Will shuffle the cards over the map",
                        "If you have a group selected, will only flip the selected cards",
                    ],
                ),
                "flip all",
                [
                    "Will flip all the flashcards over.",
                    "If you have a group selected, will only flip the selected cards",
                ],
            ),
            _defineProperty(
                _defineProperty(
                    _defineProperty(
                        _defineProperty(
                            _defineProperty(
                                _defineProperty(
                                    _defineProperty(
                                        _defineProperty(
                                            _defineProperty(
                                                _defineProperty(
                                                    _help_mapper,
                                                    "flash time",
                                                    [
                                                        "Amount of time after which a card will be flipped back after being flipped",
                                                    ],
                                                ),
                                                "one by one",
                                                [
                                                    "Will zoom in to each card",
                                                    "Clicking the map will show the next card",
                                                    'if "check" is on, an inputbox will appear in which you can type an answer',
                                                ],
                                            ),
                                            "check",
                                            [
                                                "When checked, will display an input field where you can type in an answer",
                                                "After typing in your answer, it will check the result",
                                                "The result is checked against the text on the\t\t flipside of the card",
                                                "Pressing enter from the input field will check, pressing tab from the input field\t\t will move on the the next card",
                                            ],
                                        ),
                                        "scored",
                                        [
                                            "When off, will choose next card randomly from cards that have not been shown yet",
                                            "When on, will show cards you have answered incorrectly, or that have not been shown yet with a higher probability",
                                        ],
                                    ),
                                    "start",
                                    ["start studying flashcards one by one"],
                                ),
                                "stop",
                                [
                                    "Stop studying flashcards one by one",
                                    "To exit study mode, press exit mode in the study tab of this menu \t\tor study mode from the options menu",
                                ],
                            ),
                            "double click for text",
                            [
                                "alter the shape so you can add text to it by double clicking, just like other shapes (rectangles, ellipses)",
                                "This might not work, or might not work properly if the shape is simply a line, because then \t\tthere is no room to add text",
                            ],
                        ),
                        "add function",
                        [
                            "enter the formula to add a line",
                            "the formula must have the variable x, and can contain any of the following operators: \n\t+ - / *  sin, cos, tan, ceil, floor, log, sqrt, abs (use as sin(x) or sin(2) )\n\t, 'pow, min and max  are special, because they takes two arguments: x^2 => pow(x,2)",
                        ],
                    ),
                    "ticks x/y",
                    [
                        "suggest a number or ticks for an axis",
                        "The exact number \t\tmight be different because ticks will only added at intervals that make some sense",
                    ],
                ),
                "min/max x",
                ["change the range of the x axis"],
            ),
            _defineProperty(
                _defineProperty(
                    _defineProperty(
                        _defineProperty(_help_mapper, "min/max y", [
                            "change the range of the y axis",
                        ]),
                        "Grid",
                        [
                            "Add a grid to the plot",
                            "the grid lines will be places at each tick",
                        ],
                    ),
                    "Crossed Axis",
                    [
                        "When checked, will cross the axis at zero (when in the range)",
                    ],
                ),
                "even scale",
                [
                    "changes x axis so that one tick on the x-scale is just as long \t\ton the y-scale",
                ],
            ));
    function display_help_for_button(a, b) {
        var c = a.innerText;
        return (
            c in help_mapper &&
                (slides_mode
                    ? text_to_help_pane_slides(help_mapper[c], !1, !0)
                    : text_to_help_pane(help_mapper[c], !1, !0),
                b.preventDefault()),
            a.closest("#context-menu") && b.preventDefault(),
            !1
        );
    }
    for (
        var el,
            els = Array.from(
                document.querySelectorAll("button, label, legend"),
            ).filter(function (a) {
                return !a.classList.contains("no-help");
            }),
            i = 0;
        i < els.length;
        i++
    )
        ((el = els[i]),
            el.innerText.trim() in help_mapper &&
                ((el.style.cursor = "help"),
                el.setAttribute("title", "right click for help"),
                (el.oncontextmenu = function (a) {
                    display_help_for_button(this, a);
                })));
    var basic_fig_help = [
            "<span class=hh1>Resize or connect</span> by using yellow-green buttons",
            "Start typing to<span class=hh1>add text</span>",
            "To <span class=hh1>move</span>, click, hold and drag the shape. Or use the arrow keys",
            "<span class=hh1>Delete</span> a shape with the delete or backspace key",
            "Right click for <span class=hh1>quick controls </span>",
            "To <span class=hh1>copy</span>, press Control C, then click canvas",
            "Press shift tab to select an existing paragraph in the shape",
            "Drag image file onto shape to <span class=hh1>add background</span>",
            "Press control v to add image from clipboard",
            "Press shift plus arrow \tkey to <span class=hh1>select closest neighbouring shape</span> in the direction of the arrow",
            "Use arrow keys to move shape",
            "Use control plus arrow key to resize shape",
            "Hold alt when moving to move the shape one pixel at a time",
            "Hold shift and click to activate group shape is in. Click again to cycle through multiple groups (if these are present)",
        ],
        help_text = {
            slidePreview: [
                "Drag up or down to order slide",
                "Scroll to move all slide preview up or down",
                "Right click to activate slider on canvas",
                "After reactivating you can update slide content by right clicking the slider on the canvas",
            ],
            polygon: ["About polygons"].concat(
                basic_fig_help.concat([
                    "Some polygons (for example the arrow) have\tan extra button to alter the shape of the polygon somewhat. You can use it to make the arrow thicker or thinner, or\t the arrowhead longer or shorter",
                ]),
            ),
            drawing_lineto: [
                "About lines",
                "Double click to show (or hide) control points",
                "Drag control points to change the shape of the line",
                "use the resize button to resizes the line",
                "Extend the line from either side by dragging the line-end-points to a new position",
                "You can add arrows to the line from the Arrows menu on the left",
            ],
            slide: [
                "About Slides",
                "Move and resize slide over area you want to show",
                "Right click and press make slide when done",
                "To remove, right click and press remove",
            ],
            rect: ["About rectangles"].concat(basic_fig_help.concat([])),
            ellipse: ["About ellipses"].concat(basic_fig_help.concat([])), // text_basic: ['About text', 'To change text: double click on text', 'Bind to path by positioning text over path and right click',
            //      'Use font size to make bigger or smaller', 'See fonts, colors in menu for more controls'],
            text_path: [
                "About text paths",
                "Click hold and drag in x dimension to position on path",
                "Right click for choosing font style and sizes",
                "To change text: double click on text",
                "If upside down, keep dragging past end of path.",
            ],
            text_block: [
                "About text paths",
                "Click hold and drag in x dimension to position on path",
                "Right click for choosing font style and sizes",
                "To change text: double click on text",
            ],
            path_addon: [
                "Change the size of the arrow from the contextmenu, or arrow menu",
                "You can remove the arrow, or change the shape by pressing an arrow arrows menu",
                "The style of the arrow is derived from the style of the path. You cannot set this on the arrow directly",
            ],
            icon: [
                "About icons",
                "Change icon by double clicking",
                "Use font size to make bigger or smaller",
                "See fonts, colors in menu for more controls",
            ],
            svg: [
                "About the canvas",
                "<span class=hh1>Add shape</span> by double clicking the canvas, or click the canvas and just start typing",
                "Scroll to <span class=hh1>zoom</span> in or out",
                "Click hold and drag to <span class=hh1>pan</span>",
                "Use arrow keys to move canvas in the direction of the arrow",
                "Hold shift while pressing an arrow key to zoom in or out",
                'Add <span class=hh1>gridlines</span> in "Zoom and Positioning menu"', // 'Press control and then shift (while holding control), then click hold and drag to <span class=hh1>select multiple shapes</span>',
                // 'Right click to reset selection or <span class=hh1>copy selection</span>', 'Control click single shape to add or remove from selection',
            ],
            svg_slide: [
                "Add a slide by first clicking shift control, then click and drag the area on the canvas you want to \t\tdisplay on the slide",
                'If you are happy with the position, right click the slide and press "make slide"',
            ],
            P: [
                "About paragraphs",
                "Start typing to <span class=hh1>add text</span>",
                "Press enter <span class=hh1>to add</span> another paragraph",
                "For <span class=hh1>styling</span>: right-click paragraph",
                "use up and down arrow to select other paragraphs",
                "Press shift tab to select shape the paragraph is in",
                "Use colors, font and paragraph controls in menu for more features",
                "<span class=hh1>Remove</span> by press shift delete",
                "<span class=hh1>Move</span> a paragraph inside of the shape by dragging the arrow before the paragraph (or set the margin in the           paragraph control menu",
                "Move a paragraph onto another shape, or onto the canvas, by holding control while dragging the arrow in front of the paragraph",
            ],
            path_group: [
                "About paths",
                "To <span class=hh1>remove</span>, press delete",
                "Press control s to copy style",
                "Right click to choose the side of the shape the path lands on or to <span class=hh1>add arrow</span>",
                "Double click to show control points which will allow you to\t\t<span class=hh1>change the flow</span> of the path and the landing position on the shape",
                "Add a <span class=hh1>text label</span> by simply typing when the path is the active shape",
            ],
            print_region: [
                "Place the print region over the area you want to export.",
                "You can adjust the size by dragging the corners of the print region\t\t(if you have not choosen a fixed size).",
                "Zooming in and out on the canvas is a second way to control what is visible inside the\t\tprint region.",
                "Zooming in will also increase the pixel size of the resulting image en vice versa.",
            ],
            knot: ["dasf"],
            knot_hierarchy: [
                "About this hierarchical knot.",
                "By connecting shapes to this knot, they become part\t\tof the hierarchy.",
                "They can be aligned similarly, and the flow of the path will be similar",
                "You cannot alter the path between a knot and a child as much as a normal path",
                "To change sides, you can only mirror the shape (click shape, see hierarchy menu and klik mirror element), or\t\tchange the orientation (horizontal or vertical)",
            ],
            rect_canvas: [
                "about sub canvasses:",
                " this canvas behaves a bit like a layer.",
                "you can add things to it.",
                "If you move the canvas, everything on the canvas moves with it",
                "Hold shift while dragging\t\tto only move the canvas and not the elements on it",
                "You cannot add paragraphs to a canvas",
            ],
            cell_basic: [
                "about cells /tables:",
                "This shape is a cell that is part of a table",
                "To add text, double click it",
                "When resizing or moving a cell, any cell that is part of the same table will also move if it is placed to the right or below\t\t of the cell you are moving",
                "Right click for regular context menu",
                "shift right click (or control right click for firefox) \t\t to show table context menu",
                'Activate "Caps Lock" to more or resize only one cell in table',
                'See also "Table (edit)" menu on left for more options',
            ],
            end_point: [
                "move endpoint by dragging",
                "hold shift while dragging to keep path attached to the shape",
            ],
            cubic_point: [
                "drag to alter shape of path",
                "hold shift to only move one point at a time",
            ],
            graph_basic: [
                "About plots",
                "You can make simple graphs",
                "Add a line from the context menu or the graph menu",
                "the formula must have the variable x, and can contain any of the following operators: \n\t+ - / *  sin, cos, tan, ceil, floor, log, sqrt, abs (use as sin(x) or sin(2) )\n\t, 'pow, min and max  are special, because they takes two arguments: x^2 => pow(x,2)",
                "From the menus you can \t\talso add gridlines, or make the axes crossed",
            ],
            axes_board: [
                "About boards",
                "You can use this board sorting and ordering other shapes",
                "Any shape you drag onto the board, will stick to it",
                "Look in the menu's to add or gridlines, or numbers to the axes",
            ],
            math_basic: [
                "about math text",
                "Double click the this shape to enter your formula",
                'Your formula should be entered in "Tex" format',
                "Check out the blog (from our homepage) to read more about Tex",
                "Press delete or backspace to delete",
                "You can move it by dragging or using the keyboard arrow keys",
                'Chang the colors or font size using the "Border Controls" and "Colors" Menu',
            ],
            x_axis: axis_help,
            y_axis: axis_help,
            line_for_graph: [
                "About lines on a plot",
                "You can color the line using the color menu",
                "Or use the border menu to make the line thicker or thinner",
                "To delete a line, click the del or backspace key",
            ],
        };
    to_canvas.set_canvas();
    ("use strict");
    function _toConsumableArray(a) {
        return (
            _arrayWithoutHoles(a) ||
            _iterableToArray(a) ||
            _unsupportedIterableToArray(a) ||
            _nonIterableSpread()
        );
    }
    function _nonIterableSpread() {
        throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _iterableToArray(a) {
        if (
            ("undefined" != typeof Symbol && null != a[Symbol.iterator]) ||
            null != a["@@iterator"]
        )
            return Array.from(a);
    }
    function _arrayWithoutHoles(a) {
        if (Array.isArray(a)) return _arrayLikeToArray(a);
    }
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function change_path_side(a, b, c) {
        var d = manage_groups.get_group(currentElement, !0);
        (d.forEach(function (b) {
            //fixed_path_side(el, dir, undefined);
            // if (path_is_from){
            // 	toggle_path_from_and_to(dir, parseInt(el['to_side']));
            // }else{
            // 	toggle_path_from_and_to(parseInt(el['from_side']), dir);
            // }
            (c(b, a), path.remake_path(void 0), toggle_path_reset_button(b));
        }),
            render(),
            gui_buttons.frame_element(currentElement));
    }
    ($(".form_disp_go").on("click", function () {
        (manage_groups.get_group(currentElement, !0).forEach(function (a) {
            [0, 1, 2, 3].forEach(function (b) {
                disperse_path_over_side(a, b, MARGIN_DIV);
            });
        }),
            render());
    }),
        $(".form_no_disp").on("click", function () {
            ([0, 1, 2, 3].forEach(function (a) {
                disperse_path_over_side(currentElement, a, 0.5);
            }),
                render());
        }),
        $(".swap_menu").on("click", toggle_slide_edit_menu),
        (document.querySelector("#form_toggle_advanced_options").onclick =
            toggle_advanced_options));
    function toggle_advanced_options() {
        ((minimal_menu = !minimal_menu),
            toggle_button_to_status(
                document.querySelector("#form_toggle_advanced_options"),
                !minimal_menu,
            ),
            display_fs_for_shape(currentElement));
    }
    function toggle_button_to_status(a, b) {
        var c = is_toggle_button_on(a); //div.querySelector('.toggle-button-selected');
        ((c && !b) || (!c && b)) && toggle_button(a);
    }
    function is_toggle_button_on(a) {
        return a
            .querySelector(".toggle-button")
            .classList.contains("toggle-button-selected");
    }
    function toggle_button(a) {
        var b =
            !!(1 < arguments.length && void 0 !== arguments[1]) && arguments[1];
        if (
            ("DIV" != a.tagName || a.classList.contains("toggle-button")
                ? "LABEL" == a.tagName
                    ? (a = a.parentElement.querySelector(".toggle-button"))
                    : "BUTTON" == a.tagName && (a = a.parentElement)
                : (a = a.querySelector(".toggle-button")),
            a.classList.contains("toggle-button"))
        ) {
            a.classList.toggle("toggle-button-selected");
            var c = !!a.classList.contains("toggle-button-selected");
            if (b) {
                var d = c ? [1, 0] : [0, 1],
                    e = _slicedToArray(d, 2),
                    f = e[0],
                    g = e[1];
                (a.parentElement
                    .querySelectorAll("label")
                    [f].classList.add("selected"),
                    a.parentElement
                        .querySelectorAll("label")
                        [g].classList.remove("selected"));
            }
            return c;
        }
    }
    ($(".copy_styles").on("click", function () {
        (style_copier.setup_style_copy(),
            text_to_feedback_pane(
                "click another ".concat(me, " to copy style to it"),
            ));
    }),
        $(".form_copy").on("click", make_ready_for_copy),
        (document.querySelector("#form_fill_what").onclick = function (a) {
            (set_button_class(this, a.target),
                (active_style.fill_what = a.target.value),
                set_color_picker(part_to_chunk(currentElement)));
        }),
        $(".form_path_style2 select").on("change", function () {
            (manage_groups.get_group(currentElement, !0).forEach(
                function (a) {
                    set_current_element(a);
                    change_path_flow_and_style(
                        !1,
                        active_style.line_flow,
                        this.value,
                    );
                }.bind(this),
            ),
                render(),
                gui_buttons.frame_element(currentElement));
        }),
        $(".form_group_cov").on("click", merge_covered_shapes));
    function merge_covered_shapes(a) {
        a = a.iama ? a : currentElement;
        var b = {
            top: a.y,
            left: a.x,
            bottom: a.y + a.height,
            right: a.x + a.width,
        };
        merged.is_parent(a) || merged.create_new_group(a);
        for (
            var c,
                d = Object.values(shapes_storage.borders)
                    .concat(shapes_storage.drawings)
                    .concat(shapes_storage.icons)
                    .concat(shapes_storage.math_shapes),
                e = d.filter(function (a) {
                    return (
                        is_inside(a.x, a.y, b) &&
                        is_inside(a.x + a.width, a.y + a.height, b)
                    );
                }),
                f = 0,
                g = 0;
            g < e.length;
            g++
        )
            ((c = merged.add_child(a, e[g])), c && (f += 1));
        (0 == f
            ? text_to_feedback_pane("no shapes found to merge")
            : text_to_feedback_pane(f + " shapes merged"),
            set_current_element(a));
    }
    ($(".form_ungroup_all_children").on("click", function () {
        merged.is_parent(currentElement) && merged.remove_group(currentElement);
    }),
        (document.querySelector("#form_ungroup").onclick = function () {
            merged.remove_child(currentElement);
        }),
        (document.querySelector("#cm_delete_button").onclick = function () {
            delete_shape(currentElement);
        }),
        (document.querySelector("#cm_zoom_button").onclick = function () {
            if (for_group) {
                var a = get_bbox_of_group(manage_groups.get_current_group()),
                    b = _slicedToArray(a, 4),
                    c = b[0],
                    d = b[1],
                    e = b[2],
                    f = b[3];
                (zoom_to_area({ x: c, y: e, width: d - c, height: f - e }, !0),
                    manage_groups.deactivate_group());
            } else {
                var h =
                    "text" == currentElement.iama
                        ? find_border_by_id(currentElement.border_id)
                        : currentElement;
                zoom_to_area(h, !0, !1, get_max_scale_for_zoom(h.level));
            }
        }));
    function get_max_scale_for_zoom(a) {
        return "L0" == a ? 2 : "L1" == a ? 3 : "L2" == a ? 6 : 8;
    }
    function rescale_canvasses() {
        // const button = document.querySelector('#toggle_canvas_width');
        // button.style.left = (canvas_width -20) + 'px';
        // button.style.top = (canvas_height -20)+ 'px';
        //niet meer nodig als marge niet wordt aangepast.
        // ['#draw_canvas',  '#draw_canvas_single', '#gui_canvas', '#hover_canvas', '#cursor_canvas', '#grid_canvas'].forEach(id=>{
        // 	document.querySelector(id).style.top =  CANVAS_MARGIN+'px';
        // 	document.querySelector(id).style.left = CANVAS_MARGIN+'px';
        // 	canvas_offset_x =  CANVAS_MARGIN;
        // 	canvas_offset_y =  CANVAS_MARGIN;
        // });
        (form_hidden
            ? setup_canvasses(
                  window.innerWidth - 2 * CANVAS_MARGIN,
                  window.innerHeight - 2 * CANVAS_MARGIN,
              )
            : setup_canvasses.apply(
                  void 0,
                  _toConsumableArray(calc_canvas_width()),
              ),
            render_all(),
            render_single());
    } // document.querySelector('#toggle_canvas_width').style.left = (canvas_width - 20) + 'px';
    // document.querySelector('#toggle_canvas_width').style.top = (canvas_height -20)+ 'px';
    document.querySelector("#form_grid_snap").onclick = snap_to_grid;
    function snap_to_grid() {
        ((el = currentElement),
            manage_groups.get_group(el, !1).forEach(function (a) {
                var b = el.x % grid_step,
                    c = el.y % grid_step;
                find_sticky_and_reposition(a, -b, -c, !0);
            }),
            set_current_element(el));
    }
    ((document.querySelector("#form_grid_size").onclick = function () {
        (manage_groups.get_group(currentElement, !1).forEach(function (a) {
            var b = a.width,
                c = a.height,
                d = 0 == b % grid_step ? 0 : grid_step - (b % grid_step),
                e = 0 == c % grid_step ? 0 : grid_step - (c % grid_step);
            resize_protocol(a, d, e, !0);
        }),
            set_current_element(currentElement));
    }),
        plus_minus_generator(
            document.getElementById("form_grid_step"),
            function (a) {
                var b = grid_step;
                ((grid_step = isNaN(parseInt(a.value))
                    ? 4
                    : Math.max(1, parseInt(a.value))),
                    (a.value = grid_step));
                var c = parseInt(
                    document.querySelector("#form_grid_lines_dx input").value,
                );
                document.querySelector("#form_grid_lines_dx input").value =
                    Math.floor(c / b) * grid_step;
                var d = parseInt(
                    document.querySelector("#form_grid_lines_dy input").value,
                );
                ((document.querySelector("#form_grid_lines_dy input").value =
                    Math.floor(d / b) * grid_step),
                    plus_minus_generator(
                        document.getElementById("form_grid_lines_dx"),
                        function (a) {
                            a.value = Math.max(0, a.value);
                        },
                        grid_step,
                    ),
                    plus_minus_generator(
                        document.getElementById("form_grid_lines_dy"),
                        function (a) {
                            a.value = Math.max(0, a.value);
                        },
                        grid_step,
                    ));
            },
        ),
        $(".button-new-map").on("click", function () {
            window.open(document.location.origin + "/make/new");
        }),
        (document.querySelector("#button_tut_restart").onclick = function () {
            quick_tut.start();
        }),
        $(".button_to_hotkeys").on("click", function () {
            var a = document.location.origin + "/make/load/hotkeys";
            window.open(a, "_blank");
        }),
        $(".form_path_reset").on("click", function () {
            (toggle_path_reset_button(currentElement),
                delete currentElement.custom_flow,
                delete currentElement.offset_from,
                delete currentElement.offset_to,
                delete currentElement.fixed_side,
                delete currentElement.from_side,
                delete currentElement.to_side,
                path.set_path_attrs(currentElement),
                (cpa.pos1 = 0.5),
                (cpa.pos2 = 0.5),
                path.remake_path(),
                render());
        }),
        make_font_selector(document.querySelector("#form_fonts_list")),
        make_font_selector(document.querySelector("#cm_fonts_list")),
        make_font_selector(document.querySelector("#cm_fonts_list_par")),
        make_font_selector(document.querySelector("#cm_fonts_list_path")),
        (document.querySelector("#form_collision_detection").onclick =
            function () {
                (is_toggle_button_on(this)
                    ? path.change_collision_detection.turn_off()
                    : path.change_collision_detection.turn_on(),
                    toggle_button(this));
            }),
        plus_minus_generator(
            document.getElementById("form_paragraph_padding_top"),
            function (a) {
                ((part_to_chunk(currentElement).margin_top = parseInt(a.value)),
                    position_texts(currentElement.border_id),
                    render());
            },
            1,
            1,
        ),
        plus_minus_generator(
            document.getElementById("form_paragraph_padding_left"),
            function (a) {
                ((part_to_chunk(currentElement).margin_left = parseInt(
                    a.value,
                )),
                    position_texts(currentElement.border_id),
                    render());
            },
            1,
            1,
        ),
        (document.querySelector("#form_toggle_plumb_lines").onclick =
            function () {
                ((canvas_status.plumbs_on = !is_toggle_button_on(this)),
                    toggle_button(this));
            }),
        (document.querySelector("#form_view_mode").onclick = function () {
            (view_mode_on(), to_canvas.set_canvas());
        }),
        (document.querySelector("#view_mode_button").onclick = function () {
            view_mode_off();
        }),
        (document.querySelector("#form_view_mode").onclick = function () {
            view_mode_on();
        }),
        (document.querySelector("#math_modal_closer").onclick =
            close_math_modal));
    ("use strict");
    var quick_tut = (function () {
        function a() {
            !!(0 < arguments.length && arguments[0] !== void 0) && arguments[0];
            (c(),
                cmm.off(),
                (document.querySelector("#tut_frame").style.display = "none"));
        }
        function b(a) {
            return {
                top: transform.applyY(a.top),
                left: transform.applyX(a.left),
                bottom: transform.applyY(a.bottom),
                right: transform.applyX(a.right),
            };
        }
        function c() {
            ["left_arrow", "right_arrow", "up_arrow", "down_arrow"].forEach(
                function (a) {
                    document.querySelector("#" + a).style.display = "none";
                },
            );
        }
        function d(a) {
            ((i.innerText = g[a][l]), c());
            var b = g[a];
            if (
                ("actions" in b &&
                    b.actions.forEach(function (a) {
                        return a();
                    }),
                "arrow" in g[a])
            ) {
                var d = document.querySelector("#" + b.arrow);
                if (
                    ((d.style.display = "block"),
                    (d.style.position = "absolute"),
                    "string" == typeof b.pos)
                )
                    var e = document.querySelector("#" + b.pos),
                        f = e.getBoundingClientRect();
                else var f = b.pos();
                k[b.arrow](f, d);
            }
        }
        function e(a) {
            j.innerText = "step ".concat(a, " of 19");
        }
        var f,
            g = [
                {
                    text: "Welcome. This is a quick introduction into the basic controls for Breakdown Notes. Use the buttons to continue, move back or exit",
                },
                {
                    text: "Check the help menu to see what shape is active and what actions are possible",
                    pos: "fs_help",
                    arrow: "right_arrow",
                    actions: [
                        function () {
                            return display_help(to_canvas.get_canvas());
                        },
                        function () {
                            return toggle_field_set(
                                document.querySelector("#fs_help"),
                            );
                        },
                    ],
                },
                {
                    text: "You start out on an empty canvas. Reading the help learns that you can add shapes here by double clicking ....",
                    pos: function () {
                        return document.querySelector(
                            "#fs_help p:nth-child(2)",
                        );
                    },
                    arrow: "right_arrow",
                    actions: [],
                },
                {
                    text: "..and that you can zoom in or out the canvas, among other things",
                    pos: function () {
                        return document.querySelector(
                            "#fs_help p:nth-child(3)",
                        );
                    },
                    arrow: "right_arrow",
                },
                {
                    text: "The menu on the left contains many options, for instance for saving and loading, fonts, colors and shapes",
                    pos: "fs_maps",
                    arrow: "right_arrow",
                    actions: [],
                },
                {
                    text: "Menu items with this color offer controls specific to the shape that is active.  Dependend on the shape that is\t\t     active, some items may disappear",
                    pos: "fs_border",
                    arrow: "right_arrow",
                    actions: [
                        function () {
                            ((last_pos = [
                                -transform.x / transform.k + 250,
                                -transform.y / transform.k + 250,
                            ]),
                                add_active_shape_to_canvas(),
                                display_fs_for_shape(currentElement));
                        },
                    ],
                },
                {
                    text: "Just click a menu item to fully expand it, and click it again to hide it. Scroll while hovering the menu to move it up or down",
                    actions: [
                        function () {
                            (close_other_fieldsets(),
                                toggle_field_set(
                                    document.querySelector("#fs_buttons"),
                                ));
                        },
                    ], //   pos: 'fs_maps',
                    //   arrow: 'left_arrow'
                },
                {
                    text: "In the Options menu you can also choose to show advanced options. But you probably do not need these when you are just starting out",
                    pos: "form_toggle_advanced_options",
                    arrow: "right_arrow",
                },
                {
                    text: "Let's look at a shape. You can add it by simple double clicking the canvas. Notice the green control buttons.",
                    pos: function () {
                        var a = to_bbox(currentElement);
                        return ((a.top += 40), (a.right += 50), b(a));
                    },
                    arrow: "left_arrow",
                    actions: [
                        function () {
                            (display_fs_for_shape(currentElement),
                                gui_buttons.frame_element(currentElement));
                        },
                    ],
                },
                {
                    text: "This button is for resizing the shape:  just click, hold and drag",
                    pos: function () {
                        var a = to_bbox(currentElement);
                        return (
                            (a.top += currentElement.height),
                            (a.right += 50),
                            b(a)
                        );
                    },
                    arrow: "left_arrow", //actions:[()=>pick_me(g.node())]
                },
                {
                    text: "And to connect: click, hold and drag onto another shape ",
                    pos: function () {
                        var a = to_bbox(currentElement);
                        return (
                            (a.top += currentElement.height),
                            (a.right += 10),
                            b(a)
                        );
                    },
                    arrow: "right_arrow", //actions:[()=>pick_me(g.node())]
                },
                {
                    text: "To move a shape, click hold and drag its greenish border or an empty part of it. The border will appear when hovering the shape with your mouse", // pos: 'gui_connect',
                    // arrow: 'right_arrow',
                    actions: [
                        function () {
                            return render_hover_highlight(
                                currentElement,
                                "rgba(154,205,50,0.5)",
                                hover_context,
                                get_scaled_margin(),
                            );
                        },
                    ],
                },
                {
                    text: "You can see which element is active by the green controls or green border and the red lines. Any commands, like choosing fonts or colors\t\t  will have effect on the active element", // pos: 'gui_connect',
                    // arrow: 'right_arrow',
                    actions: [],
                },
                {
                    text: "To add text to a shape, make sure its active and then just start typing. Notice the paragraph is now the activate shape and the help menu\t\t    is listing controls for paragraphs.",
                    actions: [
                        function () {
                            var a = add_paragraph_to_shape(currentElement);
                            (add_text_to_paragraph(a, "This is a paragraph"),
                                measure_text(a));
                            var b = a.parent;
                            (position_texts(a.parent.border_id),
                                set_current_element(b.parts[0]),
                                gui_buttons.frame_element(currentElement),
                                render_all(0, !1, !0));
                        },
                    ],
                    pos: function () {
                        return currentElement;
                    },
                    arrow: "right_arrow",
                },
                {
                    text: "To add a shape and paragraph in one go, you can also just click the canvas once and start typing, or press tab from within a paragraph and continue typing",
                },
                {
                    text: "Right click shapes and element to show the quick controls",
                    pos: "context-menu",
                    arrow: "down_arrow",
                    actions: [
                        function () {
                            return cmm.position_and_display(
                                150,
                                150,
                                "#cm-par",
                            );
                        },
                    ],
                },
                {
                    text: "Right click buttons and labels in menus to get additional help. This for instance is help about how to group shapes together.",
                    actions: [
                        function () {
                            (cmm.off(),
                                text_to_help_pane(
                                    help_mapper["Group Shapes"],
                                    !0,
                                    !0,
                                ));
                        },
                    ],
                    pos: "fs_help",
                    arrow: "right_arrow",
                },
                {
                    text: "Save and load your map from the save load new menu.",
                    pos: "fs_maps",
                    arrow: "right_arrow",
                },
                {
                    text: "Export to pgn  using the export menu. Remember, right click buttons and labels for help",
                    pos: "fs_export",
                    arrow: "right_arrow",
                },
                {
                    text: "That's it! Hope you enjoy making notes and maps with Breakdown Notes.",
                },
            ],
            h = 0,
            i = document.querySelector("#lesson"),
            j = document.querySelector("#tut_progress");
        document.querySelector("#close_tut").onclick = a;
        var k = {
                left_arrow: function (a, b) {
                    ((b.style.left = a.right + "px"),
                        (b.style.top = a.top + "px"));
                },
                right_arrow: function (a, b) {
                    ((b.style.left = a.left - f + "px"),
                        (b.style.top = a.top + "px"));
                },
                down_arrow: function (a, b) {
                    ((b.style.left = a.left + "px"),
                        (b.style.top = a.top - arrow_height + "px"));
                },
                up_arrow: function (a, b) {
                    ((b.style.left = a.left + "px"),
                        (b.style.top = a.bottom + arrow_height + "px"));
                },
            },
            l = "text";
        return {
            forward: function () {
                h < g.length - 1 && ((h += 1), e(h), d(h));
            },
            backward: function () {
                0 < h && ((h -= 1), d(h), e(h));
            },
            start: function () {
                //make_progress_bar();
                ((h = 0),
                    d(h),
                    e(h),
                    (arrow_height = parseInt(
                        window.getComputedStyle(document.querySelector(".anim"))
                            .height,
                    )),
                    (f = parseInt(
                        window.getComputedStyle(document.querySelector(".anim"))
                            .width,
                    )),
                    c(),
                    (document.querySelector("#step_forward").onclick =
                        this.forward),
                    (document.querySelector("#step_back").onclick =
                        this.backward),
                    (document.querySelector("#tut_frame").style.display =
                        "block"),
                    set_val_to_cookie("tut_seen", "true"));
            },
            end: function () {
                a();
            },
            check_cookie_for_tutorial: function () {
                return find_val_in_cookie("tut_seen");
            },
        };
    })();
    function set_val_to_cookie(a, b, c) {
        var e = new Date();
        e.setTime(e.getTime() + 1e3 * (60 * (60 * (24 * c))));
        var d = "expires=" + e.toUTCString();
        document.cookie = "".concat(a, "=").concat(b, ";").concat(d);
    }
    function find_val_in_cookie(a) {
        var b = document.cookie,
            c = b.split(";").map(function (a) {
                return a.split("=").map(function (a) {
                    return a.trim();
                });
            }),
            d = c.find(function (b) {
                return b[0] == a;
            });
        return !!d && d[1];
    } //TODO1 legend text in oude map mooier
    ("use strict");
    var options = {
        shouldSort: !0,
        threshold: 0.3,
        location: 0,
        distance: 600,
        maxPatternLength: 32,
        minMatchCharLength: 2,
        keys: ["text"],
    };
    function build_initial_index() {
        var a = new Fuse(
            _.flatten(Object.values(shapes_storage.texts)).map(function (a) {
                var b = a.border_id,
                    c = a.text,
                    d = a.font_size;
                return { border_id: b, text: c, font_size: d };
            }),
            options,
        );
        return a;
    }
    function show_search_form() {
        ((document.querySelector("#search_form").style.display = "block"),
            (document.querySelector("#search_form_search_value").value = ""),
            (document.querySelector("#search_results").innerHTML = ""),
            document.querySelector("#search_form_search_value").focus(),
            (document.querySelector("#search_form_search_value").onkeydown =
                function (a) {
                    (27 == a.keyCode && hide_search_form(),
                        "Enter" == a.key && find_search_results(this.value),
                        (key_pressed = []),
                        a.stopPropagation());
                }),
            (document.querySelector("#search_form").onkeydown = function (a) {
                (27 == a.keyCode && hide_search_form(), (key_pressed = []));
            }),
            (canvas_status.search_form = !0));
    }
    function hide_search_form() {
        ((document.querySelector("#search_form").style.display = "none"),
            (canvas_status.search_form = !1));
    }
    function find_search_results(a) {
        var b = build_initial_index();
        res = b.search(a);
        var c = document.querySelector("#search_results");
        ((c.innerText = ""),
            0 == res.length && (c.innerText = "No results found"),
            (res = res.sort(function (c, a) {
                return a.font_size - c.font_size;
            })),
            res.forEach(function (b) {
                var d = find_border_by_id(b.border_id),
                    e = make_search_result_paragraph(a, b.text);
                ((e.onclick = function () {
                    zoom_to_area(d, !1, !1, get_max_scale_for_zoom(d.level));
                }),
                    c.appendChild(e));
            }));
    }
    function make_search_result_paragraph(a, b) {
        var c = a.split(" ").map(function (a) {
                return a.toLowerCase();
            }),
            d = b.split(" ").map(function (a) {
                return a.toLowerCase();
            }),
            e = document.createElement("p");
        return (
            d.forEach(function (a) {
                if (
                    _.any(
                        c.map(function (b) {
                            return a.includes(b);
                        }),
                    )
                ) {
                    var d = document.createElement("b");
                    (d.classList.add("search_form_found_word"),
                        (d.innerText = a + " "),
                        e.appendChild(d));
                } else {
                    var b = document.createElement("span");
                    ((b.innerText = a + " "), e.appendChild(b));
                }
            }),
            e
        );
    }
    ((document.querySelector("#search_form_close").onclick = hide_search_form),
        (document.querySelector("#search_form_search").onclick = function () {
            find_search_results(
                document.querySelector("#search_form_search_value").value,
            );
        }));
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    var printer = (function () {
        //portrait, w,h
        //PDF unit: 72px == 1 inch
        //CANVAS: 96dpi
        function a(a) {
            var b =
                    !!(1 < arguments.length && void 0 !== arguments[1]) &&
                    arguments[1],
                c = 100 / transform.k,
                d = a.width,
                e = a.height,
                f = a.width / a.height; //als geen scaling wordt toegepast, blijft slider niet op vaste positie liggen.
            //let bbox = view.get_view_bbox();
            // > A0[1] / A0[0];
            return (
                b
                    ? f > 1 / Math.sqrt(2)
                        ? ((a.height -= c),
                          (a.width = a.height / Math.sqrt(2)),
                          (a.y += c / 2),
                          (a.x += (d - a.width) / 2))
                        : ((a.width -= c),
                          (a.height = a.width * Math.sqrt(2)),
                          (a.x += c / 2),
                          (a.y += (e - a.height) / 2))
                    : f > Math.sqrt(2)
                      ? ((a.height -= c),
                        (a.width = a.height * Math.sqrt(2)),
                        (a.y += c / 2),
                        (a.x += (d - a.width) / 2))
                      : ((a.width -= c),
                        (a.height = a.width / Math.sqrt(2)),
                        (a.x += c / 2),
                        (a.y += (e - a.height) / 2)),
                a
            );
        }
        function b() {
            var b =
                !!(0 < arguments.length && arguments[0] !== void 0) &&
                arguments[0];
            if (n) {
                var d = a(view.get_view_bbox(), c()); //{...rect} //geeft fout bij babel transpilation
                (draw_slider(d),
                    (slider = JSON.parse(JSON.stringify(d))),
                    (slider.iama = "slider"));
            } else
                (slider ||
                    ((slider = {
                        x: -transform.x / transform.k + 100,
                        y: -transform.y / transform.k + 100,
                        width: 400,
                        height: 400,
                        iama: "slider",
                    }),
                    h(1)),
                    draw_slider(slider),
                    g(slider.width, slider.height));
            n || b || draw_slider_resize_points();
        }
        function c() {
            return (
                "portrait" == document.querySelector(".cm-print-layout").value
            );
        }
        function d() {
            if (n) {
                var a = document.querySelector("#form_print_size"),
                    b = _slicedToArray(sizes[a[a.selectedIndex].value], 2),
                    d = b[0],
                    e = b[1];
                return c() ? [d, e] : [e, d];
            }
            return [o, p];
        }
        function e(a) {
            //https://stackoverflow.com/questions/695151/data-protocol-url-size-limitations
            for (
                var b = a.split(","),
                    c = b[0].match(/:(.*?);/)[1],
                    d = atob(b[1]),
                    e = d.length,
                    f = new Uint8Array(e);
                e--;

            )
                f[e] = d.charCodeAt(e);
            return new Blob([f], { type: c });
        }
        function f(a) {
            //https://stackoverflow.com/questions/695151/data-protocol-url-size-limitations
            var b = e(a),
                c = window.URL.createObjectURL(b);
            window.open(c, "_blank");
        }
        function g(a, b) {
            ((document.querySelector(
                "#form_print_result_print_size",
            ).innerText = ""
                .concat(round_to(a, 0), " x ")
                .concat(round_to(b, 0))),
                2e7 < a * b &&
                    text_to_feedback_pane(
                        "Your image will be large. Processing a size this big might take a long time             or even crash your browser.",
                    ));
        }
        function h(a) {
            q = a;
            var b = round_to(slider.width * q, 0),
                c = round_to(slider.height * q, 0);
            ((o = b), (p = c), g(b, c));
        }
        function i(a, b) {
            return n ? b / a.width : b / a.width;
        }
        function j() {
            return (
                !document.querySelector("#form_printer_no_background")
                    .checked &&
                (grid_canvas.node().style.backgroundColor ||
                    window.getComputedStyle(document.body).backgroundColor)
            );
        }
        function k() {
            to_canvas.set_canvas();
            var a = new PDFDocument({ autoFirstPage: !1 }),
                b = get_canvas_proxy_for_pdfkit(a);
            roughing.set_for_export(b);
            var c = a.pipe(blobStream());
            return (
                (render_to_pdf = !0),
                (always_reset = !0),
                (no_wobble = !0),
                c.on("finish", function () {
                    var a = c.toBlob("application/pdf"); //tobloburl??
                    if (400 < a.size) {
                        var b = window.URL.createObjectURL(a);
                        window.open(b, "_blank");
                    }
                }),
                [a, b, c]
            );
        }
        function l(a) {
            ((render_to_pdf = !1),
                (always_reset = !1),
                (no_wobble = !1),
                a.end(),
                roughing.set_default());
        }
        function m() {
            var a = d(),
                b = _slicedToArray(a, 2),
                c = b[0],
                e = b[1];
            ((c *= 72 / 96), (e *= 72 / 96));
            var f = i(slider, c, e),
                g = {
                    x: round_to(-slider.x * f, 0),
                    y: round_to(-slider.y * f, 0),
                    k: f,
                };
            return [c, e, g];
        }
        ((A0 = [3179, 4494]),
            (A1 = [2245, 3179]),
            (A2 = [1587, 2245]),
            (A3 = [1123, 1587]),
            (A4 = [794, 1123]),
            (A5 = [559, 794]),
            (A6 = [397, 559]),
            (sizes = {
                A0: A0,
                A1: A1,
                A2: A2,
                A3: A3,
                A4: A4,
                A5: A5,
                A6: A6,
            }));
        var n = !0,
            o = 0,
            p = 0,
            q = 1;
        return {
            change_goal_w_h: function c(a, b) {
                ((o = a), (p = b), g(a, b));
            },
            change_scale: h,
            get_background_color: j,
            set_fixed_A_ratio: function b(a) {
                return (n = a);
            },
            is_fixed_A_ratio: function a() {
                return n;
            },
            draw_print_region: b,
            print: function a() {
                var b = document.querySelector("#form_print_to_image");
                0 == b.selectedIndex
                    ? this.print_to_image()
                    : this.export_to_pdf();
            },
            print_to_image: function a() {
                cc.clear_canvas(context_single);
                var b = d(),
                    c = _slicedToArray(b, 2),
                    e = c[0],
                    g = c[1];
                no_wobble = !0;
                var h = document.createElement("canvas");
                ((h.style.backgroundColor = "white"),
                    roughing.set_for_export(h));
                var k = h.getContext("2d");
                scale_canvas(h, k, e, g);
                var l = i(slider, e, g),
                    m = {
                        x: round_to(-slider.x * l, 0),
                        y: round_to(-slider.y * l, 0),
                        k: l,
                    };
                (document.body.appendChild(h),
                    render_for_pic(k, slider, m, j()));
                var n = h.toDataURL();
                (f(n), h.remove(), roughing.set_default(), (no_wobble = !1));
            },
            export_to_pdf: function a() {
                var b = m(),
                    c = _slicedToArray(b, 3),
                    d = c[0],
                    e = c[1],
                    f = c[2];
                (show_wait_spinner("exporting to pdf", "This may take a while"),
                    load_pdf_script().then(function (a) {
                        var b = k(),
                            c = _slicedToArray(b, 3),
                            g = c[0],
                            h = c[1],
                            i = c[2];
                        prep_fonts()
                            .then(function () {
                                (g.addPage({ size: [d, e] }),
                                    render_for_pic(h, slider, f, !1),
                                    l(g),
                                    hide_wait_spinner());
                            })
                            ["catch"](function (a) {
                                (l(g),
                                    hide_wait_spinner(),
                                    text_to_feedback_pane([a], !0, 4e3));
                            });
                    }));
            }, // slides_to_multipage_pdf: function(){
            //     const [doc, wrapped_doc, stream] = start_pdf_export();
            //     const slides_to_print = slide_manager.get_slides_as_arr();
            //     var [w,h] = A4;
            //     const margins= {top:100,bottom:100,left:100,right:100}
            //     show_wait_spinner('exporting to pdf', 'This may take a while')
            //     try{
            //         prep_fonts().then(function(){
            //             slides_to_print.forEach(slide=>{
            //                 doc.addPage({size:[w,h], layout:'portrait'});
            //                 const scale = get_scale_(slide.xywh.width +margins.left+margins.right,
            //                                             slide.xywh.height +margins.top+margins.bottom, w, h);
            //                 const trans = {
            //                     x: round_to(-(slide.xywh.x-margins.left) * scale, 0),
            //                     y: round_to(-(slide.xywh.y-margins.top ) * scale, 0),
            //                     k: scale,
            //                 }
            //                 render_for_pic( wrapped_doc, slide.xywh, trans, false);
            //             });
            //             end_pdf_export(doc);
            //             hide_wait_spinner();
            //         })
            //     }catch(err){
            //         end_pdf_export(doc);
            //         hide_wait_spinner();
            //     }
            // },
        };
    })();
    function get_scale_(a, b, c, d) {
        var e = a / b,
            f = c / d,
            g = 1;
        return ((g = f > e ? d / b : c / a), g);
    }
    ((document.querySelector("#form_print_add_print_region").onclick =
        function (a) {
            (canvas_status.export_mode || drag_export_on(),
                printer.draw_print_region());
        }),
        (document.querySelector(".cm-print-layout").onchange =
            printer.draw_print_region),
        (document.querySelector("#form_remove_print_region").onclick =
            function () {
                drag_export_off();
            }),
        (document.querySelector(".cm-print-print").onclick = function () {
            printer.print();
        }));
    function add_export_scale_events() {
        function a(a) {
            a.value;
            var b = Math.max(0.1, a.value);
            printer.change_scale(b);
        }
        var b = 2,
            c = document.getElementById("form_print_output_scale"),
            d = c.querySelector(".plus"),
            e = c.querySelector(".minus"),
            f = c.querySelector("input"),
            g = function b(a) {
                return 1 > a ? 0.1 : 0.25;
            };
        ((d.onmousedown = function () {
            var b = parseFloat(f.value);
            ((f.value = round_to(b + g(b + 0.01), 2)), a(f));
        }),
            (e.onmousedown = function () {
                var b = parseFloat(f.value);
                ((f.value = round_to(b - g(b - 0.01), 2)), a(f));
            }),
            (f.onchange = function () {
                a(f);
            }));
    }
    (add_export_scale_events(),
        (document.querySelector("#form_print_A_ratio").onchange = function () {
            var a = document.querySelector("#form_print_A_ratio").checked;
            (printer.set_fixed_A_ratio(a),
                set_form_print_ratio_choice(),
                a
                    ? text_to_feedback_pane(
                          "drag and zoom the map so that the part of the map you want to print is inside the blue export area",
                          !1,
                          4e3,
                      )
                    : text_to_feedback_pane(
                          "you can resize and drag the blue export region over the part of the map you want to export",
                          !1,
                          4e3,
                      ));
        }));
    function set_form_print_ratio_choice() {
        return (
            !!canvas_status.export_mode &&
            void (printer.is_fixed_A_ratio()
                ? ($(".form_print_output_size_A_scale").css("display", "flex"),
                  (document.querySelector(
                      "#form_print_output_size_custom",
                  ).style.display = "none"))
                : ($(".form_print_output_size_A_scale").css("display", "none"),
                  (document.querySelector(
                      "#form_print_output_size_custom",
                  ).style.display = "inherit")),
            printer.draw_print_region())
        );
    } //TODO4 escape > close modal als aanwezig
    //TODO2 shape verwijderen die merged is in parent wordt niet goed verwijderd
    //TODO2 shapes undo van een merged element moet ook text herpositionering
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function _toConsumableArray(a) {
        return (
            _arrayWithoutHoles(a) ||
            _iterableToArray(a) ||
            _unsupportedIterableToArray(a) ||
            _nonIterableSpread()
        );
    }
    function _nonIterableSpread() {
        throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _iterableToArray(a) {
        if (
            ("undefined" != typeof Symbol && null != a[Symbol.iterator]) ||
            null != a["@@iterator"]
        )
            return Array.from(a);
    }
    function _arrayWithoutHoles(a) {
        if (Array.isArray(a)) return _arrayLikeToArray(a);
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    var font_cache = {},
        font_to_file = {
            Acme: { regular: "Acme-Regular.ttf" },
            Aleo: {
                regular: "Aleo-Regular.ttf",
                bold: "Aleo-Bold.ttf",
                italic: "Aleo-Italic.ttf",
                bolditalic: "Aleo-BoldItalic.ttf",
            },
            "Amatic SC": {
                regular: "AmaticSC-Regular.ttf",
                bold: "AmaticSC-Bold.ttf",
            },
            Arimo: {
                regular: "Arimo-Regular.ttf",
                bold: "Arimo-Bold.ttf",
                italic: "Arimo-Italic.ttf",
                bolditalic: "Arimo-BoldItalic.ttf",
            },
            Athiti: { regular: "Athiti-Regular.ttf", bold: "Athiti-Bold.ttf" },
            Audiowide: { regular: "Audiowide-Regular.ttf" },
            Cabin: {
                regular: "Cabin-Regular.ttf",
                bold: "Cabin-Bold.ttf",
                italic: "Cabin-Italic.ttf",
                bolditalic: "Cabin-BoldItalic.ttf",
            },
            Caveat: { regular: "Caveat-Regular.ttf", bold: "Caveat-Bold.ttf" },
            Cinzel: { regular: "Cinzel-Regular.ttf", bold: "Cinzel-Bold.ttf" },
            Comfortaa: {
                regular: "Comfortaa-Regular.ttf",
                bold: "Comfortaa-Bold.ttf",
            },
            Exo: {
                regular: "Exo-Regular.ttf",
                bold: "Exo-Bold.ttf",
                italic: "Exo-Italic.ttf",
                bolditalic: "Exo-BoldItalic.ttf",
            },
            "Font Awesome 5 Free": { regular: "fa-regular-400.ttf" },
            "Font Awesome 5 Brands": { regular: "fa-brands-400.ttf" },
            Handlee: { regular: "Handlee-Regular.ttf" },
            Hind: { regular: "Hind-Regular.ttf", bold: "Hind-Bold.ttf" },
            Kalam: { regular: "Kalam-Regular.ttf", bold: "Kalam-Bold.ttf" },
            Lato: {
                regular: "Lato-Regular.ttf",
                bold: "Lato-Bold.ttf",
                italic: "Lato-Italic.ttf",
                bolditalic: "Lato-BoldItalic.ttf",
            },
            Lora: {
                regular: "Lora-Regular.ttf",
                bold: "Lora-Bold.ttf",
                italic: "Lora-Italic.ttf",
                bolditalic: "Lora-BoldItalic.ttf",
            },
            Montserrat: {
                regular: "Montserrat-Regular",
                bold: "Montserrat-Bold.ttf",
                italic: "Montserrat-Italic.ttf",
                bolditalic: "Montserrat-BoldItalic.ttf",
            },
            "Open Sans": {
                regular: "OpenSans-Regular.ttf",
                bold: "OpenSans-Bold.ttf",
                italic: "OpenSans-Italic.ttf",
                bolditalic: "OpenSans-BoldItalic.ttf",
            },
            Orbitron: {
                regular: "Orbitron-Regular.ttf",
                bold: "Orbitron-Bold.ttf",
            },
            "PT Sans": {
                regular: "pt-sans-regular.ttf",
                bold: "pt-sans-bold.ttf",
                italic: "pt-sans-italic.ttf",
                bolditalic: "pt-sans-bold-italic.ttf",
            },
            Quattrocento: {
                regular: "Quattrocento-Regular.ttf",
                bold: "Quattrocento-Bold.ttf",
            },
            "Raleway-Regular": {
                regular: "Raleway-Regular.ttf",
                bold: "Raleway-Bold.ttf",
                italic: "Raleway-Italic.ttf",
                bolditalic: "Raleway-BoldItalic.ttf",
            },
            Roboto: {
                regular: "Roboto-Regular.ttf",
                bold: "Roboto-Bold.ttf",
                italic: "Roboto-Italic.ttf",
                bolditalic: "Roboto-BoldItalic.ttf",
            },
            "Roboto condensed": {
                regular: "RobotoCondensed-Regular.ttf",
                bold: "RobotoCondensed-Bold.ttf",
                italic: "RobotoCondensed-Italic.ttf",
                bolditalic: "RobotoCondensed-BoldItalic.ttf",
            },
            Sacramento: { regular: "Sacramento-Regular.ttf" },
            Schoolbell: { regular: "Schoolbell-Regular.ttf" },
            "Source Code Pro": {
                regular: "SourceCodePro-Regular.ttf",
                bold: "SourceCodePro-Bold.ttf",
                italic: "SourceCodePro-It.ttf",
                bolditalic: "SourceCodePro-BoldIt.ttf",
            },
            Ubuntu: {
                regular: "Ubuntu-Regular.ttf",
                bold: "Ubuntu-Bold.ttf",
                italic: "Ubuntu-Italic.ttf",
                bolditalic: "Ubuntu-BoldItalic.ttf",
            },
            "Ubuntu Condensed": { regular: "ubuntu-condensed-webfont.ttf" },
            "Zilla Slab": {
                regular: "ZillaSlab-Regular.ttf",
                bold: "ZillaSlab-Bold.ttf",
                italic: "ZillaSlab-Italic.ttf",
                bolditalic: "ZillaSlab-BoldItalic.ttf",
            }, //"Open Sans Condensed": '',
            //'Special Elite':'',
        };
    function fetch_a_font(a) {
        var b,
            c = a.split(",");
        if (1 < c.length) {
            var d = c[1];
            b =
                d in font_to_file[c[0]]
                    ? font_to_file[c[0]][d]
                    : font_to_file[c[0]].regular;
        } else b = font_to_file[a].regular;
        return fetch("/static/assets/" + b)
            .then(function (b) {
                return b.ok
                    ? b.arrayBuffer()
                    : Promise.reject("failed loading font " + a); // }).catch(function(err){
                //     throw err
            })
            .then(function (b) {
                font_cache[a] = b;
            });
    }
    function test_pdf() {
        var a = new PDFDocument({ size: [1123, 1587], layout: "landscape" }),
            b = a.pipe(blobStream());
        if (
            ((render_to_pdf = !0),
            (always_reset = !0),
            (no_wobble = !0),
            slider)
        ) {
            var c = get_scale(slider, goal_width, goal_height),
                d = {
                    x: round_to(-slider.x * c, 0),
                    y: round_to(-slider.y * c, 0),
                    k: c,
                };
            render_for_pic(get_canvas_proxy_for_pdfkit(a), slider, d, !1);
        } else
            render_all(
                0,
                !1,
                !1,
                get_items_to_render,
                get_canvas_proxy_for_pdfkit(a),
            );
        (b.on("finish", function () {
            var a = b.toBlob("application/pdf"),
                c = window.URL.createObjectURL(a); //tobloburl??
            window.open(c, "_blank");
        }),
            a.end(),
            (render_to_pdf = !1),
            (always_reset = !1),
            (no_wobble = !1));
    }
    function rgba_to_rgb(a) {
        if (!a) return ["rgb(0,0,0)", 0];
        if (a.startsWith("rgba")) {
            var b = a
                .slice(5, -1)
                .split(",")
                .map(function (a) {
                    return parseFloat(a);
                });
            return [b.slice(0, 3), b[3]];
        }
        if (a.startsWith("rgb")) {
            var c = a
                .slice(4, -1)
                .split(",")
                .map(function (a) {
                    return parseFloat(a);
                });
            return [c.slice(0, 3), 1];
        }
        return [a, 1];
    }
    function get_canvas_proxy_for_pdfkit(a) {
        function b(b, f) {
            return "rotate" === f
                ? function () {
                      for (
                          var b = arguments.length, c = Array(b), d = 0;
                          d < b;
                          d++
                      )
                          c[d] = arguments[d];
                      return ((c[0] /= Math.PI / 180), a[f].apply(this, c));
                  }
                : c.includes(f)
                  ? function () {
                        for (
                            var b = arguments.length, c = Array(b), d = 0;
                            d < b;
                            d++
                        )
                            c[d] = arguments[d];
                        return a[f].apply(this, c);
                    }
                  : e.includes(f)
                    ? function () {
                          for (
                              var b = arguments.length, c = Array(b), d = 0;
                              d < b;
                              d++
                          )
                              c[d] = arguments[d];
                          return a.fillAndStroke.apply(this, c);
                      }
                    : d.includes(f)
                      ? function () {
                            return !1;
                        }
                      : function () {
                            for (
                                var b = arguments.length, c = Array(b), d = 0;
                                d < b;
                                d++
                            )
                                c[d] = arguments[d];
                            return a[f].apply(this, c);
                        };
        }
        var c = [
                "transform",
                "translate",
                "scale",
                "moveTo",
                "lineTo",
                "save",
                "restore",
                "ellipse",
                "rect",
            ],
            d = ["beginPath", ""],
            e = ["stroke", "fill"],
            f = ["fillStyle", "strokeStyle", "", ""]; //closePath
        return new Proxy(a, {
            get: function (c, e, g) {
                return "getContext" === e
                    ? function () {
                          return this;
                      }
                    : "width" === e
                      ? 500
                      : "height" === e
                        ? 500
                        : "drawImage" === e
                          ? function () {
                                for (
                                    var b = arguments.length,
                                        c = Array(b),
                                        d = 0;
                                    d < b;
                                    d++
                                )
                                    c[d] = arguments[d]; //image(image, x, y, {fit:[width,height]})
                                //return doc.image(atob(args[0].src.slice(22)), args[5], args[6], {fit:[args[7],args[8]]});
                                return a.image(c[0].src, c[5], c[6], {
                                    fit: [c[7], c[8]],
                                });
                            }
                          : "fillText" === e
                            ? function () {
                                  for (
                                      var b = arguments.length,
                                          c = Array(b),
                                          d = 0;
                                      d < b;
                                      d++
                                  )
                                      c[d] = arguments[d];
                                  return (
                                      c.push({ lineBreak: !1 }),
                                      a.text.apply(a, c)
                                  );
                              }
                            : "setLineDash" === e
                              ? function () {
                                    for (
                                        var b = arguments.length,
                                            c = Array(b),
                                            d = 0;
                                        d < b;
                                        d++
                                    )
                                        c[d] = arguments[d];
                                    return a.dash(c[0][0], { space: c[0][1] });
                                }
                              : "function" == typeof c[e]
                                ? b(c, e, g)
                                : f.includes(e)
                                  ? function () {
                                        for (
                                            var b = arguments.length,
                                                c = Array(b),
                                                d = 0;
                                            d < b;
                                            d++
                                        )
                                            c[d] = arguments[d];
                                        return a[e].apply(this, c);
                                    }
                                  : d.includes(e)
                                    ? function () {
                                          return !0;
                                      }
                                    : a[e];
            },
            set: function (b, c, d) {
                if ("fillStyle" == c)
                    a.fillColor.apply(a, _toConsumableArray(rgba_to_rgb(d)));
                else if ("strokeStyle" == c)
                    a.strokeColor.apply(a, _toConsumableArray(rgba_to_rgb(d)));
                else if ("lineWidth" == c)
                    (a.lineWidth(d), 0 === d && a.strokeColor([0, 0, 0], 0));
                else if ("font" === c) {
                    var e = "";
                    d.startsWith("bold italic") || d.startsWith("italic bold")
                        ? (e = ",bold italic")
                        : d.startsWith("italic")
                          ? (e = ",italic")
                          : d.startsWith("bold") && (e = ",bold");
                    var f = d.split("px"),
                        g = _slicedToArray(f, 2),
                        h = g[0],
                        i = g[1];
                    ((i = i.trim().replace(/"/g, "")),
                        (h = i.startsWith("Font Awe")
                            ? h.match(/\d+/g)[1]
                            : h.match(/\d+/)[0]),
                        a.fontSize(h),
                        e && !(i + e in font_cache) && (e = ""),
                        a.font(font_cache[i + e]));
                }
                return !0;
            },
        });
    }
    function get_used_fonts() {
        var a = new Set(),
            b = _.flatten(Object.values(shapes_storage.texts));
        return (
            b.forEach(function (b) {
                var c = b.font_style
                    ? b.font_family + "," + b.font_style
                    : b.font_family;
                a.has(c) || a.add(c);
            }),
            0 < shapes_storage.icons.length &&
                (a.add("Font Awesome 5 Free"), a.add("Font Awesome 5 Brands")),
            a
        );
    }
    function prep_fonts() {
        var a = get_used_fonts(),
            b = new Set(Object.keys(font_cache)),
            c = new Set();
        return (
            a.forEach(function (a) {
                b.has(a) || c.add(a);
            }),
            Promise.all(Array.from(c).map(fetch_a_font))["catch"](function (a) {
                throw a;
            })
        );
    } // function pass_some_time(x) {
    //   return new Promise(resolve => {
    //     setTimeout(() => {
    //       resolve(x);
    //     }, 1000);
    //   });
    // }
    // async function f1() {
    //   console.log('starting f1')
    //   var x = await pass_some_time('time has passed');
    //   console.log(x);
    //   console.log('done with f1')
    //   return x
    // }
    // f1();
    // async function f2(){
    //     console.log('starting f2');
    //     let x =  await f1();
    //     console.log(x);
    //     console.log('done in f2');
    // }
    // function f3(){
    //     console.log('starting f3');
    //     let x = f1();
    //     console.log(x);
    //     console.log('done in f3');
    // }
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    } //https://stackoverflow.com/questions/11381673/detecting-a-mobile-browser
    function mobilecheck() {
        var b = !1;
        return (
            (function (c) {
                (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
                    c,
                ) ||
                    /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
                        c.substr(0, 4),
                    )) &&
                    (b = !0);
            })(navigator.userAgent || navigator.vendor || window.opera),
            b
        );
    }
    $(window).on("load", function () {
        //$(function(){
        var a = !1 != quick_tut.check_cookie_for_tutorial();
        if (reloading);
        else if (start_tut && !dataFile)
            //auth_logger.reload();
            //quick_tut.end();
            a || quick_tut.start();
        else if (dataFile) {
            (quick_tut.end(!a), console.log(location.pathname));
            var b = location.pathname.split("/"),
                c = b[3],
                d = location.search.includes("zipped=true"); // show_wait_spinner("loading map " + dataFile);
            if (
                ((dataPad = location.origin + "/static/examples/" + c),
                (dataPad += d ? ".zip" : ".json"),
                !d)
            )
                $.getJSON(dataPad, function (a) {
                    loader.load_data(a, !1, !0, !1, !1, !1);
                });
            else {
                var e = new XMLHttpRequest();
                (e.open("GET", dataPad, !0),
                    (e.responseType = "blob"),
                    (e.onload = function () {
                        var a = e.response;
                        new Response(a).arrayBuffer().then(function (a) {
                            unzip_blob(a, function (a) {
                                loader.load_data(a, !1, !0, !1, !1, !1);
                            });
                        });
                    }),
                    e.send());
            }
        }
        var f = location.search.includes("viewmode=true");
        (f && view_mode_on(),
            (canvas_status.mobile_mode = mobilecheck()),
            canvas_status.mobile_mode &&
                (quick_tut.end(),
                (document.querySelector("#keyboard_button").style.display =
                    "inline"),
                dataFile ? view_mode_on() : toggle_side_bar(),
                (document.querySelector("#full_screen_button").style.display =
                    "inline")));
    });
    function load_pdf_script() {
        return Promise.all([
            add_script_to_head(location.origin + "/static/js/canvas/pdfkit.js"),
            add_script_to_head(
                location.origin + "/static/js/canvas/blob-stream.js",
            ),
        ]); //PDFDocument, blobStream
    }
    function add_script_to_head(a) {
        //https://stackoverflow.com/questions/44803944/can-i-run-a-js-script-from-another-using-fetch
        return new Promise(function (b, c) {
            var d = document.createElement("script");
            (document.body.appendChild(d),
                (d.onload = b),
                (d.onerror = c),
                (d.async = !0),
                (d.src = a));
        });
    }
    document.querySelector("#full_screen_button").onclick = toggleFullScreen;
    function unzip_blob(a, b) {
        JSZip.loadAsync(a).then(function (a) {
            Object.keys(a.files).forEach(function (c) {
                a.files[c].async("string").then(function (a) {
                    b(JSON.parse(a));
                });
            });
        });
    }
    function toggleFullScreen() {
        //https://developers.google.com/web/fundamentals/native-hardware/fullscreen/
        var a = window.document,
            b = a.documentElement,
            c =
                b.requestFullscreen ||
                b.mozRequestFullScreen ||
                b.webkitRequestFullScreen ||
                b.msRequestFullscreen,
            d =
                a.exitFullscreen ||
                a.mozCancelFullScreen ||
                a.webkitExitFullscreen ||
                a.msExitFullscreen;
        a.fullscreenElement ||
        a.mozFullScreenElement ||
        a.webkitFullscreenElement ||
        a.msFullscreenElement
            ? d.call(a)
            : c.call(b);
    }
    ((document.querySelector("#keyboard_button").onclick = function () {
        var a = document.querySelector("#mobile_text_input");
        a.style.display = "block" == a.style.display ? "none" : "block";
    }),
        (document.querySelector(
            '#mobile_text_input input[type="text"]',
        ).oninput = function () {
            var a = document.querySelector("#mobile_text_input input").value;
            ((document.querySelector(
                '#mobile_text_input input[type="text"]',
            ).value = ""),
                1 == a.length && add_text_from_mobile_input(a));
        }),
        (document.querySelector("#mobile_text_input form").onsubmit = function (
            a,
        ) {
            return (a.preventDefault(), !1);
        }));
    function add_text_from_mobile_input(a) {
        if ("border" == currentElement.iama)
            add_text_to_shape(currentElement, a);
        else if ("text" == currentElement.iama)
            (gui_cursor.insert_text(a), render());
        else if ("canvas" == currentElement.iama) {
            var c = get_new_shape_with_text(a),
                d = _slicedToArray(c, 2),
                e = d[0],
                b = d[1];
            set_current_element(b);
        }
    }
    function display_cursor_mobile_mode(a, b, c) {
        var d = document.querySelector("#mobile_text_input");
        d.style.height = 1.2 * a;
        var e = transform.apply([b, c]),
            f = _slicedToArray(e, 2);
        ((b = f[0]),
            (c = f[1]),
            (d.style.left = b + "px"),
            (d.style.top = c + "px"),
            d.querySelector('input[type="text"]').focus());
    } //TODO backspace ,
    //TODO kan nu paragraaf buiten shape verplaatsen
    ("use strict");
    function _slicedToArray(a, b) {
        return (
            _arrayWithHoles(a) ||
            _iterableToArrayLimit(a, b) ||
            _unsupportedIterableToArray(a, b) ||
            _nonIterableRest()
        );
    }
    function _nonIterableRest() {
        throw new TypeError(
            "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _iterableToArrayLimit(b, c) {
        var d =
            null == b
                ? null
                : ("undefined" != typeof Symbol && b[Symbol.iterator]) ||
                  b["@@iterator"];
        if (null != d) {
            var g,
                h,
                j,
                k,
                l = [],
                a = !0,
                m = !1;
            try {
                if (((j = (d = d.call(b)).next), 0 === c)) {
                    if (Object(d) !== d) return;
                    a = !1;
                } else
                    for (
                        ;
                        !(a = (g = j.call(d)).done) &&
                        (l.push(g.value), l.length !== c);
                        a = !0
                    );
            } catch (a) {
                ((m = !0), (h = a));
            } finally {
                try {
                    if (
                        !a &&
                        null != d["return"] &&
                        ((k = d["return"]()), Object(k) !== k)
                    )
                        return;
                } finally {
                    if (m) throw h;
                }
            }
            return l;
        }
    }
    function _arrayWithHoles(a) {
        if (Array.isArray(a)) return a;
    }
    function _toConsumableArray(a) {
        return (
            _arrayWithoutHoles(a) ||
            _iterableToArray(a) ||
            _unsupportedIterableToArray(a) ||
            _nonIterableSpread()
        );
    }
    function _nonIterableSpread() {
        throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.",
        );
    }
    function _unsupportedIterableToArray(b, c) {
        if (b) {
            if ("string" == typeof b) return _arrayLikeToArray(b, c);
            var a = {}.toString.call(b).slice(8, -1);
            return (
                "Object" === a && b.constructor && (a = b.constructor.name),
                "Map" === a || "Set" === a
                    ? Array.from(b)
                    : "Arguments" === a ||
                        /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)
                      ? _arrayLikeToArray(b, c)
                      : void 0
            );
        }
    }
    function _iterableToArray(a) {
        if (
            ("undefined" != typeof Symbol && null != a[Symbol.iterator]) ||
            null != a["@@iterator"]
        )
            return Array.from(a);
    }
    function _arrayWithoutHoles(a) {
        if (Array.isArray(a)) return _arrayLikeToArray(a);
    }
    function _arrayLikeToArray(b, c) {
        (null == c || c > b.length) && (c = b.length);
        for (var d = 0, f = Array(c); d < c; d++) f[d] = b[d];
        return f;
    }
    var math_jax_specs = {
        loaded: !1,
        busy: !1,
        must_rerender: !1,
        shape: !1,
        auto_update: !0,
        error_callback: !1,
    };
    function load_math_jax() {
        var a =
                0 < arguments.length && arguments[0] !== void 0
                    ? arguments[0]
                    : "Tex",
            b = new Promise(function (a) {
                $.getScript(
                    "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js",
                    function () {
                        ((mathjax_loaded = !0),
                            MathJax.Hub.Config({
                                showMathMenu: !1,
                                extensions: ["tex2jax.js"],
                                jax: ["input/TeX", "output/CommonHTML"], // CommonHTML: {
                                //     scale: 150
                                // },
                                SVG: {
                                    scale: 50, // useGlobalCache:false,
                                    // useFontCache: false,
                                },
                            }),
                            a());
                    },
                );
            });
        return b;
    }
    ((document.querySelector("#math_modal_auto_update").onchange = function () {
        ((math_jax_specs.auto_update = this.checked),
            (document.querySelector("#math_modal_button").style.display = this
                .checked
                ? "none"
                : "inherit"));
    }),
        (document.querySelector("#math_modal_button").onclick = function () {
            change_math(
                document.querySelector("#math_modal_input").value,
                math_jax_specs.shape,
            );
        }),
        (document.querySelector("#math_modal_input").oninput = function () {
            return (
                !!math_jax_specs.auto_update &&
                void (0 === MathJax.Hub.queue.pending &&
                0 === MathJax.Hub.queue.running
                    ? (clearTimeout(math_jax_specs.timeout),
                      change_math(this.value, math_jax_specs.shape))
                    : delayed_change(this.value, math_jax_specs.shape))
            );
        }));
    function delayed_change(a, b) {
        (clearTimeout(math_jax_specs.timeout),
            (math_jax_specs.timeout = setTimeout(function () {
                change_math(a, b);
            }, 500)));
    }
    function add_math_to_cursor(a) {
        var b = document.querySelector("#math_modal_input"),
            c = b.selectionStart,
            d = b.selectionEnd,
            e = b.value.slice(0, c),
            f = b.value.slice(d);
        ((b.value = e + " " + a + " " + f),
            b.focus(),
            (b.selectionEnd = c + a.length + 1));
    }
    function change_render_to_svg() {
        MathJax.Hub.Queue(["setRenderer", MathJax.Hub, "SVG"]);
    }
    function start_math() {
        return (
            make_math_menu(),
            load_math_jax().then(function () {
                (change_render_to_svg(), (math_jax_specs.loaded = !0));
            })
        );
    } //matrix
    function make_math_menu() {
        function a(a, b) {
            var c = document.createElement("div");
            return (
                c.classList.add("tab"),
                c.classList.add("hidden"),
                c.setAttribute("id", b + "_math_menu_tab"),
                a.appendChild(c),
                c
            );
        }
        var b = [
                "basic",
                "relations",
                "ranges",
                "logics",
                "greeks",
                "brackets",
                "trigonometric",
                "binary",
                "other",
                "examples",
            ],
            c = {
                greeks: [
                    //,'\\eth'
                    "\\alpha",
                    "\\beta",
                    "\\gamma",
                    "\\delta",
                    "\\epsilon",
                    ,
                    "\\varepsilon",
                    "\\zeta",
                    "\\eta",
                    "\\theta",
                    "\\vartheta",
                    "\\iota",
                    "\\kappa",
                    "\\lambda",
                    "\\mu",
                    "\\nu",
                    "\\xi", //, '\\o'
                    "\\pi",
                    "\\varpi",
                    "\\rho",
                    "\\varrho",
                    "\\sigma",
                    "\\varsigma",
                    "\\tau",
                    "\\upsilon",
                    "\\phi",
                    "\\varphi",
                    "\\chi",
                    "\\psi",
                    "\\omega",
                    "\\Gamma",
                    "\\Delta",
                    "\\Theta",
                    "\\Lambda",
                    "\\Xi",
                    "\\Pi",
                    "\\Sigma",
                    "\\Upsilon",
                    "\\Phi",
                    "\\Psi",
                    "\\Omega",
                    "\\partial",
                    "\\hbar",
                    "\\imath",
                    "\\jmath",
                    "\\ell",
                    "\\Re",
                    "\\Im",
                    "\\wp",
                ],
                relations: [
                    "<",
                    ">",
                    "\\le",
                    "\\ge",
                    "\\leq",
                    "\\geq",
                    "\\equiv",
                    "\\gg",
                    "\\ll",
                    "\\equiv",
                    "\\doteq",
                    "\\sim",
                    "\\simeq",
                    "\\cong",
                    "\\asymp",
                    "\\approx",
                    "\\cong",
                    "=",
                    "\\neq",
                    "\\subset",
                    "\\supset",
                    "\\subseteq",
                    "\\supseteq", //'\\nsubseteq','\\nsupseteq','\\sqsubset','\\sqsupset',
                    "\\sqsubseteq",
                    "\\sqsupseteq",
                    "\\prec",
                    "\\succ",
                    "\\dashv",
                    "\\bowtie", //'\\nparallel', '\\measuredangle',
                    "\\in",
                    "\\notin",
                    "\\ni",
                    "\\ne",
                    "\\not",
                    "\\perp",
                    "\\parallel",
                    "\\vdash",
                    "\\models",
                ],
                ranges: [
                    "\\int_{a}^{b}",
                    "\\int\\limits_{a}^{b}",
                    "\\iint_{a}^{b}",
                    "\\oint_{a}^{b}",
                    "|_0^1",
                    "\\sum_{i=1}^{10}",
                    "\\prod_{a}^{b}",
                    "\\coprod_{a}^{b}",
                    "\\bigcup_{a}^{b}",
                    "\\bigsqcup_{a}^{b}",
                    "\\bigcap_{a}^{b}",
                    "\\bigvee_{a}^{b}",
                    "\\bigwedge_{a}^{b}",
                    "\\bigoplus_{a}^{b}",
                    "\\bigodot_{a}^{b}",
                    "\\bigotimes_{a}^{b}",
                ],
                trigonometric: [
                    "\\sin",
                    "\\cos",
                    "\\tan",
                    "\\cot",
                    "\\arcsin",
                    "\\arccos",
                    "\\arctan",
                    "\\sinh",
                    "\\cosh",
                    "\\tanh",
                    "\\coth",
                    "\\sec",
                    "\\csc",
                ],
                binary: [
                    "\\pm",
                    "\\mp",
                    "\\times",
                    "\\div",
                    "\\ast",
                    "\\star",
                    "\\dagger",
                    "\\ddagger",
                    "\\cap",
                    "\\cup",
                    "\\uplus",
                    "\\sqcap",
                    "\\sqcup",
                    "\\vee",
                    "\\wedge",
                    "\\cdot",
                    "\\diamond",
                    "\\bigtriangleup",
                    "\\bigtriangledown",
                    "\\triangleleft",
                    "\\triangleright",
                    "\\bigcirc",
                    "\\bullet",
                    "\\wr",
                    "\\oplus",
                    "\\ominus",
                    "\\otimes",
                    "\\oslash",
                    "\\odot",
                    "\\circ",
                    "\\setminus",
                    "\\amalg",
                ],
                logics: [
                    //'\\nexists','\\varnothing','\\implies',
                    "\\exists",
                    "\\forall",
                    "\\neg",
                    "\\emptyset",
                    "\\subset",
                    "\\supset",
                    "\\in",
                    "\\notin",
                    "\\ni",
                    "\\land",
                    "\\lor",
                    "\\rightarrow",
                    "\\leftarrow",
                    "\\mapsto",
                    "\\iff",
                    "\\Leftrightarrow",
                    "\\leftrightarrow",
                    "\\top",
                    "\\bot",
                ],
                brackets: [
                    "\\lbrack",
                    "\\rbrack",
                    "\\vert",
                    "\\Vert",
                    "\\lbrace",
                    "\\rbrace",
                    "\\lfloor",
                    "\\rfloor",
                    "\\langle",
                    "\\rangle",
                    "\\lceil",
                    "\\rceil",
                    "{a \\over b}",
                    "{a \\atop b}",
                    "{ a \\choose b}",
                    "{ a b\\brace a b}",
                    "{ a \\brack b}",
                ],
                basic: [
                    "=",
                    "+",
                    "-",
                    "\\times",
                    "\\div",
                    "{a \\over b}",
                    "a^{2b}",
                    "\\sqrt{a}",
                    "\\sqrt[b] a",
                ],
                other: [
                    "\\infty",
                    "\\,",
                    "\\:",
                    "\\;",
                    "\\quad",
                    "\\cdots",
                    "\\vdots",
                    "\\ddots",
                    "\\not{a}",
                    "\\dot{a}",
                    "\\hat{a}",
                    "\\overrightarrow{AB}",
                    "\\overleftarrow{AB}",
                    "\\vec{a}",
                    "\\widehat{AAA}",
                    "\\overline{a}",
                    "\\underline{a}",
                    "\\prime",
                ],
                examples: [
                    "\\lim\\limits_{x \\to \\infty} \\exp(-x) = 0",
                    "\\begin{matrix} a & b & c \\\\  d & e & f \\\\  g & h & i \\end{matrix}",
                    "\\begin{pmatrix}   a_{1,1} & a_{1,2} & \\cdots & a_{1,n} \\\\   a_{2,1} & a_{2,2} & \\cdots & a_{2,n} \\\\  \\vdots  & \\vdots  & \\ddots & \\vdots  \\\\   a_{m,1} & a_{m,2} & \\cdots & a_{m,n}  \\end{pmatrix}",
                    "\\left( \\sum_{i=1}^{n-1} i \\right)",
                ],
            },
            d = document.querySelector("#math_modal"); //'\\','\\','\\','\\','\\','\\','\\','\\',
        ((function (a, b) {
            var c = document.createElement("ul");
            ((c.style.marginTop = "12px"),
                b.forEach(function (a) {
                    var b = document.createElement("li");
                    (b.classList.add("math_menu_header"),
                        (b.innerText = a),
                        (b.onclick = function () {
                            (Array.from(
                                c.parentElement.querySelectorAll(".tab"),
                            ).forEach(function (a) {
                                return a.classList.add("hidden");
                            }),
                                c.parentElement
                                    .querySelector(
                                        "#".concat(a, "_math_menu_tab"),
                                    )
                                    .classList.remove("hidden"),
                                document
                                    .querySelectorAll(
                                        "li.math_menu_header.active",
                                    )
                                    .forEach(function (a) {
                                        return a.classList.remove("active");
                                    }),
                                this.classList.add("active"));
                        }),
                        c.appendChild(b));
                }),
                a.appendChild(c));
        })(d, b),
            b.forEach(function (b) {
                var e = a(d, b),
                    f = "examples" == b ? "12px" : "18px";
                c[b].forEach(function (a) {
                    var b = document.createElement("span");
                    (b.classList.add("mathjax_clickable_item"),
                        (b.style.fontSize = f),
                        (b.innerText = "$$" + a + "$$"),
                        (b.onclick = function () {
                            (add_math_to_cursor(a),
                                math_jax_specs.auto_update &&
                                    change_math(
                                        document.querySelector(
                                            "#math_modal_input",
                                        ).value,
                                        math_jax_specs.shape,
                                    ));
                        }),
                        e.appendChild(b));
                });
            }),
            document
                .querySelector("#relations_math_menu_tab")
                .classList.remove("hidden"));
    }
    function trigger_math(a) {
        var b = document.createElement("P"); // '$$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} $$g'
        ((b.innerText = a ? "$$" + a + "$$" : "$$ X^{27} $$"),
            MathJax.Hub.Queue(
                ["Typeset", MathJax.Hub, b],
                (function (a, b) {
                    return function () {
                        var c = add_math_jax_to_new_shape(a, b);
                        set_current_element(c);
                    };
                })(b, a),
            ));
    }
    function change_math(a, b) {
        if ("math_shape" !== b.iama)
            return (
                text_to_feedback_pane(
                    "do not know what shape to change... Click a shape with math inside first",
                ),
                !1
            );
        var c = document.createElement("P"); // '$$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} $$g'
        ((c.innerText = a ? "$$" + a + "$$" : "$$ X^{27} $$"),
            MathJax.Hub.Queue(
                ["Typeset", MathJax.Hub, c],
                (function (a, b, c) {
                    return function () {
                        return change_math_jax_of_shape(a, b, c);
                    };
                })(c, a, b),
            ));
    }
    function add_math_jax_to_new_shape(a, b) {
        //document.body.appendChild(p)
        var c = a.querySelector("svg > g"),
            d = get_path_info(c),
            e = to_breakdown_shape.apply(
                void 0,
                [d, b].concat(
                    _toConsumableArray(calc_scale(a.querySelector("svg"))),
                ),
            );
        return (shapes_storage.add_shape(e), clear_defs(), e);
    }
    function check_for_error_in_mathjax_output(a) {
        return !!a.querySelector("text") && a.querySelector("text").textContent;
    }
    function change_math_jax_of_shape(a, b, c) {
        var d = a.querySelector("svg > g");
        if (!d) return !1;
        var e = check_for_error_in_mathjax_output(d);
        if (e)
            setTimeout(function () {
                return text_to_feedback_pane(e, !0, 3e3);
            }, 100);
        else {
            (close_main_feedback_func(),
                clearTimeout(math_jax_specs.error_callbacsk));
            var f = get_scale_of_math_shape(c.scale),
                g = get_path_info(d);
            c.raw_text = b;
            var i = calc_scale(a.querySelector("svg")),
                j = _slicedToArray(i, 3),
                k = j[0],
                l = j[1],
                m = j[2];
            ((c.width = l),
                (c.height = m),
                (c.scale = k),
                (c.items = g),
                alter_scale_of_math_shape(c, f));
        }
        (clear_defs(), render(), (math_jax_specs.busy = !1));
    }
    function get_path_info(a) {
        function b(a) {
            var b = { x: a.getAttribute("x"), y: a.getAttribute("y") };
            return (
                a.hasAttribute("transform") &&
                    (b.trans = parse_transform(a.getAttribute("transform"))),
                b
            );
        }
        var c = "";
        a.hasAttribute("transform") &&
            (c = parse_transform(a.getAttribute("transform")));
        var d = get_direct_children(a, "use").map(function (a) {
                return [
                    b(a),
                    Snap.path
                        .toRelative(
                            document.body
                                .querySelector(a.getAttribute("href"))
                                .getAttribute("d"),
                        )
                        .toString(),
                ];
            }),
            e = get_direct_children(a, "rect").map(function (a) {
                return {
                    x: a.getAttribute("x"),
                    y: a.getAttribute("y"),
                    width: a.getAttribute("width"),
                    height: a.getAttribute("height"),
                };
            }); //Snap.path.toRelative
        // let paths = get_direct_children(g, 'path').map(d=> [get_pos(d),
        //                     Snap.path.toRelative(d.getAttribute('d')).toString() ]) //Snap.path.toRelative
        // let rects = get_direct_children(g, 'rect').map(d=>({x: d.getAttribute('x'), y:d.getAttribute('y'),
        //                                                     width: d.getAttribute('width'), height: d.getAttribute('height') }));
        return {
            trans: c,
            paths: d,
            rects: e,
            children: get_direct_children(a, "g").map(get_path_info),
        };
    }
    function parse_transform(a) {
        return a.startsWith("translate")
            ? a
                  .match(/\+?-?\d+,\+?-?\d+/)[0]
                  .split(",")
                  .map(function (a) {
                      return parseInt(a);
                  })
            : a.startsWith("scale")
              ? a
                    .match(/\+?-?\d+\.?\d*/)[0]
                    .split(",")
                    .map(function (a) {
                        return parseFloat(a);
                    })
              : [];
    }
    function to_breakdown_shape(a, b, d, e, f) {
        var g = get_new_id(),
            h = predef_styles.get_classes()[active_style.style_class];
        return {
            raw_text: b,
            x: last_pos[0],
            y: last_pos[1],
            color: h.color,
            stroke: h.stroke,
            stroke_width: 0, //infinity.get_border_width(infinity.get_level(), active_style.style_class),
            fill: is_visible_color(h.fill) ? h.fill : "black", //active_style.fill,
            id: g,
            iama: "math_shape",
            style_class: active_style.style_class,
            font_size: infinity.get_font_size(
                infinity.get_level(),
                h.font_class,
            ),
            level: infinity.get_level(),
            items: a,
            scale: d,
            width: e,
            height: f,
        };
    }
    function calc_scale(a) {
        //12 is font size body, omdat svg width van mathjax in ex is gedefinieerd
        var b = 12 * parseFloat(a.getAttribute("width")),
            c = 12 * parseFloat(a.getAttribute("height")),
            d = parseFloat(a.getAttribute("viewBox").split(" ")[2]);
        return [d / b, b, c];
    }
    function get_direct_children(a, b) {
        return Array.from(a.children).filter(function (a) {
            return a.tagName == b;
        });
    }
    function clear_defs() {
        //MUSTDO
    }
    function math_jax_tests() {
        //fout
        //fout
        //geen verschil met bovenstaande ??
        (trigger_math("-b \\pm \\sqrt{b^2 - 4ac} \\over 2a"),
            trigger_math("-b \\pm \\sqrt{b^2 - 4ac} \\over {2a \\over 5}"),
            trigger_math(
                "\\cos (2\\theta) = \\cos^2 \\theta - \\sin^2 \\theta",
            ),
            trigger_math("\\lim\\limits_{x \\to \\infty} \\exp(-x) = 0"),
            trigger_math("k_{n+1} = n^2 + k_n^2 - k_{n-1}"),
            trigger_math("f(n) = n^5 + 4n^2 + 2 |_{n=17}"),
            trigger_math("\\frac{n!}{k!(n-k)!} = \\binom{n}{k}"),
            trigger_math("\\frac{\\frac{1}{x}+\\frac{1}{y}}{y-z}"),
            trigger_math(
                " x = a_0 + \\cfrac{1}{a_1 + \\cfrac{1}{a_2+ \\cfrac{1}{a_3 + \\cfrac{1}{a_4} } } }",
            ),
            trigger_math("\\sqrt{\\frac{a}{b}}"),
            trigger_math("\\sqrt[n]{1+x+x^2+x^3+\\dots+x^n}"),
            trigger_math("\\sum_{i=1}^{10} t_i"),
            trigger_math("\\displaystyle\\sum_{i=1}^{10} t_i"),
            trigger_math("\\int_0^\\infty \\mathrm{e}^{-x}\\,\\mathrm{d}x"),
            trigger_math("\\int\\limits_a^b"),
            trigger_math(
                "\\begin{matrix}  a & b & c \\\\  d & e & f \\\\  g & h & i \\end{matrix}",
            ),
            trigger_math(
                "f(n) =\n    \\begin{cases}\n        n/2       & \\quad \\text{if } n \\text{ is even}\\\\\n        -(n+1)/2  & \\quad \\text{if } n \\text{ is odd}\n    \\end{cases}",
            ));
    }
    function shape_to_math(a) {
        var b = get_text_with_border_id(a.id);
        (trigger_math(b[0].text), delete_shape(a));
    }
    plus_minus_generator(
        document.querySelector("#cm_math_scale"),
        function (a) {
            alter_scale_of_math_shape(currentElement, parseInt(a.value));
        },
        1,
        0,
    );
    function alter_scale_of_math_shape(a, b) {
        var c = a.scale,
            d = get_scale_of_math_shape(b);
        ((a.scale = d),
            (a.width = (a.width * c) / d),
            (a.height = (a.height * c) / d),
            render());
    }
    function get_scale_of_math_shape(a) {
        return 101 - a;
    }
    var math_menu = document.querySelector("#math_modal > div.inner"); // d3.select(math_menu).call(d3.drag()
    //     .on("drag", function(){
    //         if (d3.event.sourceEvent.target.tagName !== "TEXTAREA" ){
    //             this.parentElement.style.top =  parseInt(this.parentElement.style.top) + d3.event.dy  + 'px'
    //             this.parentElement.style.right = parseInt(this.parentElement.style.right) - d3.event.dx + 'px'
    //         }else{
    //             return true;
    //         }
    //     })
    //     .on("end", function(){
    //        if (d3.event.sourceEvent.target.tagName == "TEXTAREA" ) return true
    //     })
    // )
    ("use strict");
    function get_tokens_for_syntax_highlighting(a, b) {
        var c = Prism.tokenize(a, Prism.languages[b]);
        return c;
    }
    function get_plaintext_from_shape(a) {
        for (
            var b = get_chunks_by_par(a.id), c = "", d = 0;
            d < a.num_pars;
            d++
        )
            try {
                ((c += b[d].reduce(function (a, b) {
                    return a + b.text;
                }, "")),
                    (c += "\n"));
            } catch (a) {
                debugger;
            }
        return ((c = c.replace(/\r\n/g, "\n")), c);
    } // function syntax_highlight_paragraph(shape, par_num, language){
    //     change_par_text_to_syntax_highlight(shape, par_num, language)
    //     reset_par_and_chunk_numbering(shape.id);
    //     position_texts(shape.id);
    //     render();
    // }
    function change_par_text_to_syntax_highlight(a, b, c) {
        var d = get_chunks_in_par(a.id, b),
            e = d.reduce(function (a, b) {
                return a + b.text;
            }, ""),
            f = get_tokens_for_syntax_highlighting(e, c);
        (d.forEach(shapes_storage.remove), add_tokens_to_paragraph(a, b, f));
    } // function syntax_highlight_shape(shape, language){
    //     shape.font_family = 'Source Code Pro';
    //     for (let i=0; i < shape.num_pars; i++){
    //         change_par_text_to_syntax_highlight(shape, i, language);
    //     }
    //     shape.fill= '#2d2d2d';
    //     shape.style_class=false;
    //     reset_par_and_chunk_numbering(shape.id);
    //     position_texts(shape.id);
    //     shape.syntax_highlighted = language
    //     render();
    // }
    function syntax_highlight_shape(a, b) {
        var c =
                !(2 < arguments.length && arguments[2] !== void 0) ||
                arguments[2],
            d = get_plaintext_from_shape(a),
            e = get_tokens_for_syntax_highlighting(d, b); // console.log(tokens);
        (remove_all_text_from_shape(a),
            (a.font_family = "Source Code Pro"),
            (a.fill = c ? "#2d2d2d" : "#f5f2f0"),
            (a.text_align = "left"),
            (a.style_class = !1),
            (a.num_pars = 1),
            add_tokens_to_shape(a, e, !1, c),
            reset_par_and_chunk_numbering(a.id),
            position_texts(a.id),
            (a.syntax_highlighted = b),
            render());
    }
    function get_color_for_token(a) {
        var b =
                !(1 < arguments.length && arguments[1] !== void 0) ||
                arguments[1],
            c = b ? 0 : 1;
        return a && "type" in a && a.type in prism_color_map
            ? prism_color_map[a.type][c]
            : a && "alias" in a && a.alias in prism_color_map
              ? prism_color_map[a.alias][c]
              : ["#ccc", "black"][c];
    } // function add_tokens_to_paragraph(shape, par_num, tokens, type_overrule='plain'){
    //     tokens.forEach(token=>{
    //         var chunk_is_empty = false
    //         var chunk = get_default_text(shape);
    //         chunk.par_num = par_num;
    //         if (typeof token=== "string"){
    //             chunk.text = token
    //             chunk.has_own_style = true;
    //             chunk.color = '#ccc';
    //             if (type_overrule !=="plain"){
    //                 chunk.color = prism_color_map[type_overrule] || 'black';
    //             }
    //         }else{
    //             if (typeof token.content === "string"){
    //                 chunk.text = token.content;
    //                 chunk.has_own_style = true;
    //                 chunk.color = get_color_for_token(token)
    //             }else{
    //                 add_tokens_to_paragraph(shape, par_num, token.content, token.type)
    //                 chunk_is_empty = true;
    //             }
    //         }
    //         if (!chunk_is_empty) shapes_storage.add_text(chunk);
    //     });
    // }
    function parse_token(a, b, c) {
        a.split("\n").forEach(function (a, d) {
            if (0 == a.length) c.num_pars += 1;
            else {
                0 < d && (c.num_pars += 1);
                var e = get_default_text(c);
                ((e.par_num = c.num_pars - 1),
                    (e.has_own_style = !0),
                    (e.text = a),
                    (e.color = b),
                    shapes_storage.add_text(e));
            }
        });
    }
    function add_tokens_to_shape(a, b, c) {
        var d =
            !(3 < arguments.length && arguments[3] !== void 0) || arguments[3]; //console.log(tokens, darkmode);
        b.forEach(function (b) {
            "string" == typeof b
                ? parse_token(b, get_color_for_token(c, d), a)
                : "string" == typeof b.content
                  ? parse_token(b.content, get_color_for_token(b, d), a)
                  : add_tokens_to_shape(a, b.content, b, d);
        });
    }
    function remove_all_text_from_shape(a) {
        var b = get_text_with_border_id(a.id);
        b.forEach(shapes_storage.remove);
    }
    var multiline_test_text =
            "\n    function test(arr){\n        arr= arr.map(d=>d+1)\n        return arr\n    }\n    test([1,2,3,4])",
        prism_color_map = {
            comment: ["#999", "slategrey"],
            prolog: ["#999", "slategrey"],
            doctype: ["#999", "slategrey"],
            cdata: ["#999", "slategrey"],
            punctuation: ["#7ec6be", "#999"],
            tag: ["#e2777a", "#905"],
            "attr-name": ["#c5a5c5", "#690"],
            namespace: ["#e2777a", "#690"],
            deleted: ["#e2777a", "#905"],
            "function-name": ["#6196cc", "#cf1515"],
            boolean: ["#f08d49", "#905"],
            number: ["#f08d49", "#905"],
            function: ["#f08d49", "#cf1515"],
            property: ["#f8c555", "#905"],
            "class-name": ["#f8c555", "#cf1515"], // '#DD4A68'
            constant: ["#f8c555", "#905"],
            symbol: ["#f8c555", "#905"],
            selector: ["#cc99cd", "#690"],
            important: ["#cc99cd", "#e90"],
            atrule: ["#cc99cd", "#07a"],
            keyword: ["#cc99cd", "#07a"],
            builtin: ["#cc99cd", "#690"],
            string: ["#7ec699", "#690"],
            char: ["#7ec699", "#690"],
            "attr-value": ["#7ec699", "#07a"],
            regex: ["#7ec699", "#e90"],
            variable: ["#7ec699", "#e90"],
            operator: ["#67cdcc", "#9a6e3a"],
            entity: ["#67cdcc", "#9a6e3a"],
            url: ["#67cdcc", "#9a6e3a"],
            inserted: ["green", "#690"],
        }; //script..overerft
    document.querySelector(".form_syntax_highlight_item").onclick =
        function () {
            var a = document.querySelector(
                    "#form_language_for_syntax_highlight",
                ),
                b = a[a.selectedIndex].value;
            manage_groups.get_group(currentElement, !0).forEach(function (a) {
                "border" == a.iama &&
                    syntax_highlight_shape(
                        a,
                        b,
                        document.querySelector(
                            "#form_syntax_highlight_dark_mode",
                        ).checked,
                    );
            });
        };
})();
